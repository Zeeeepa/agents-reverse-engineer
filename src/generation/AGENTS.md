<!-- Generated by agents-reverse-engineer -->

# src/generation

Two-phase documentation pipeline orchestrator: Phase 1 (parallel file `.sum` generation via `GenerationOrchestrator.createFileTasks()` → `buildFilePrompt()` → `AIService.call()` → `writeSumFile()`), Phase 2 (post-order directory `AGENTS.md` aggregation via `createDirectoryTasks()` → `buildDirectoryPrompt()` → `writeAgentsMd()` → root `writeClaudeMdPointer()`).

## Contents

**[collector.ts](./collector.ts)** — `collectAgentsDocs(projectRoot)` recursively walks directory tree, collects `AGENTS.md` files, returns sorted `Array<{relativePath, content}>` via `path.relative()` + `localeCompare()` sorting. `collectAnnexFiles(projectRoot)` mirrors logic for `.annex.sum` files. `SKIP_DIRS` Set excludes `node_modules`, `.git`, `.agents-reverse-engineer`, `vendor`, `dist`, `build`, `__pycache__`, `.next`, `venv`, `.venv`, `target`, `.cargo`, `.gradle` from traversal.

**[complexity.ts](./complexity.ts)** — `analyzeComplexity(files, projectRoot)` returns `ComplexityMetrics` with `fileCount`, `directoryDepth` (via `path.relative()` + `split(path.sep).length - 1`), `files` array, `directories` Set. `extractDirectories()` walks upward via `path.dirname()` until `'.'` sentinel. Consumed by orchestrator for concurrency and memory planning.

**[executor.ts](./executor.ts)** — `buildExecutionPlan(plan, projectRoot)` transforms `GenerationPlan` into `ExecutionPlan` with dependency graph. Creates file tasks (`id: 'file:${relativePath}'`, `dependencies: []`, `outputPath: '${absolutePath}.sum'`), builds `directoryFileMap` via `path.dirname()` grouping, creates directory tasks sorted by `getDirectoryDepth(dirB) - getDirectoryDepth(dirA)` (descending), assigns dependencies to child file task IDs, outputs to `${dirAbsPath}/AGENTS.md`. `isDirectoryComplete(dirPath, expectedFiles)` checks `.sum` existence via `sumFileExists()`. `getReadyDirectories(executionPlan)` filters completed directories. `formatExecutionPlanAsMarkdown(plan)` emits GENERATION-PLAN.md checklist grouped by depth descending with `- [ ] \`${file}\`` format.

**[orchestrator.ts](./orchestrator.ts)** — `GenerationOrchestrator.createPlan(discoveryResult)` executes nine-step pipeline: `prepareFiles()` (read contents), `analyzeComplexity()`, `buildProjectStructure()` (directory listing), `createFileTasks()` (calls `buildFilePrompt()` with `projectPlan` context), `createDirectoryTasks()` (defers prompt construction), memory optimization (zero `PreparedFile.content` fields), telemetry emission (`phase:start`, `plan:created`, `phase:end`). Returns `GenerationPlan` with `files`, `tasks`, `complexity`, `projectStructure`.

**[types.ts](./types.ts)** — `AnalysisResult` interface (`summary: string`, `metadata: SummaryMetadata`), `SummaryMetadata` (`purpose`, optional `criticalTodos`, `relatedFiles`), `SummaryOptions` (`targetLength: 'short'|'standard'|'detailed'`, `includeCodeSnippets: boolean`). Shared contract between LLM analysis and writer components.

## Subdirectories

**[prompts/](./prompts/)** — Dual-mode template expansion: `buildFilePrompt(context)` returns `{system, user}` pairs applying `FILE_UPDATE_SYSTEM_PROMPT` when `context.existingSum` present, replaces `{{FILE_PATH}}`/`{{CONTENT}}`/`{{LANG}}`/`{{PROJECT_PLAN_SECTION}}` placeholders. `buildDirectoryPrompt(dirPath)` reads child `.sum`/`AGENTS.md` via parallel `readSumFile()`, calls `extractDirectoryImports()` for `.ts/.tsx/.js/.jsx/.py/.go/.rs/.java/.kt`, scans manifests (`package.json`, `Cargo.toml`, `go.mod`, etc.), formats import map, applies `DIRECTORY_UPDATE_SYSTEM_PROMPT` when `existingAgentsMd` present.

**[writers/](./writers/)** — `writeSumFile()` formats `SumFileContent` as YAML frontmatter (`generated_at`, `content_hash`, `purpose`, `critical_todos`, `related_files`) + markdown body, uses `formatYamlArray()` (inline `[a,b,c]` when `<=3 items <40 chars`, else multi-line `- item`). `writeAgentsMd(dirPath, content)` renames user `AGENTS.md` → `AGENTS.local.md` if missing `GENERATED_MARKER`, injects `@AGENTS.local.md` directive. `writeClaudeMdPointer(dirAbsolutePath)` generates root `CLAUDE.md` with `@CLAUDE.local.md` + `@AGENTS.md` imports.

## Architecture

### Task Creation Flow

Phase 1: `createFileTasks()` → `buildFilePrompt({filePath, content, projectPlan})` → `{systemPrompt, userPrompt}` → `AnalysisTask{type:'file'}` → `buildExecutionPlan()` → `ExecutionTask{id:'file:${path}', dependencies:[]}`.

Phase 2: `createDirectoryTasks()` → groups files by `path.dirname()` → `AnalysisTask{type:'directory', directoryInfo:{sumFiles, fileCount}}` → `ExecutionTask{id:'dir:${path}', dependencies:['file:...']}` sorted by depth descending.

### Dependency Resolution

`buildExecutionPlan()` constructs bipartite graph: file tasks (zero dependencies, parallel), directory tasks (depend on child file task IDs via `files.map(f => 'file:${f}')`, post-order traversal). `getReadyDirectories()` filters via `isDirectoryComplete()` checking all expected `.sum` files exist.

### Memory Optimization

After `createFileTasks()` embeds content into prompts, `createPlan()` zeros `PreparedFile.content` fields via `(file as {content:string}).content = ''`. Comment: "The runner re-reads files from disk."

### Post-Order Traversal

All sorting uses `getDirectoryDepth(dirB) - getDirectoryDepth(dirA)` where `getDirectoryDepth(dir)` returns `dir === '.' ? 0 : dir.split(path.sep).length`. Ensures deepest directories process first, enabling bottom-up aggregation.

## Behavioral Contracts

### Task ID Formats
```javascript
`file:${relativePath}`  // file tasks
`dir:${relativePath}`   // directory tasks
```

### Post-Order Sort
```javascript
getDirectoryDepth(dirB) - getDirectoryDepth(dirA)  // Descending depth
```

### Task Count Adjustment
```javascript
taskCount: tasks.length + 1  // +1 for CLAUDE.md task added by buildExecutionPlan()
```

### Directory Traversal Skip Pattern
```javascript
SKIP_DIRS = ['node_modules', '.git', '.agents-reverse-engineer', 'vendor',
             'dist', 'build', '__pycache__', '.next', 'venv', '.venv',
             'target', '.cargo', '.gradle']
```

### Complexity Metrics Calculation
```javascript
fileCount = files.length
directoryDepth = max(files.map(f =>
  path.relative(projectRoot, f).split(path.sep).length - 1))
directories = new Set(files.map(f => /* walk upward to '.' */))
```

### Directory Completion Check
```javascript
async isDirectoryComplete(dirPath, expectedFiles) {
  const missing = []
  for (const file of expectedFiles) {
    if (!await sumFileExists(path.join(projectRoot, file)))
      missing.push(file)
  }
  return { complete: missing.length === 0, missing }
}
```