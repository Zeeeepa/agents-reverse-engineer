<!-- Generated by agents-reverse-engineer -->

# src/generation

**Phase orchestration for three-stage AI-driven documentation pipeline: concurrent `.sum` file analysis via worker pools, post-order directory `AGENTS.md` synthesis with import map injection, and platform-specific root document generation from aggregated corpus.**

## Contents

### Orchestration & Planning

**[orchestrator.ts](./orchestrator.ts)** — `GenerationOrchestrator` class with `prepareFiles()` reading file content via `readFile()`, `createFileTasks()` calling `buildFilePrompt()` for each file, `createDirectoryTasks()` grouping files by `path.dirname(relativePath)`, `createPlan()` emitting `phase:start`/`plan:created`/`phase:end` traces and returning `GenerationPlan` with `files`, `tasks`, `complexity` from `analyzeComplexity()`, `projectStructure` from `buildProjectStructure()`; memory management via `(file as { content: string }).content = ''` after task creation.

**[executor.ts](./executor.ts)** — `buildExecutionPlan()` transforms `GenerationPlan` into `ExecutionPlan` with dependency-ordered `tasks[]`, `fileTasks[]`, `directoryTasks[]`, `rootTasks[]`, `directoryFileMap: Record<string, string[]>` via `path.dirname()` extraction, sorts directories by `getDirectoryDepth()` descending for post-order traversal; `isDirectoryComplete()` validates `.sum` file presence for expected files via `sumFileExists()`; `getReadyDirectories()` filters directories with complete file analysis; `formatExecutionPlanAsMarkdown()` renders plan with Phase 1/2/3 sections, groups files by directory with checkbox format, sorts directories by depth descending.

**[complexity.ts](./complexity.ts)** — `analyzeComplexity()` returns `ComplexityMetrics` with `fileCount`, `directoryDepth` from `calculateDirectoryDepth()` splitting `path.relative()` on `path.sep`, `directories: Set<string>` from `extractDirectories()` walking parent chain via `path.dirname()` loop.

**[types.ts](./types.ts)** — Defines `AnalysisResult` with `summary: string`, `metadata: SummaryMetadata` (`purpose`, `criticalTodos?`, `relatedFiles?`); `SummaryOptions` with `targetLength: 'short' | 'standard' | 'detailed'`, `includeCodeSnippets: boolean`.

### Document Collection

**[collector.ts](./collector.ts)** — `collectAgentsDocs()` recursively traverses directories via internal `walk()` closure using `readdir()` with `withFileTypes: true`, reads all `AGENTS.md` files via `readFile()`, computes relative paths via `path.relative()`, sorts results by `relativePath` via `localeCompare()`, skips 13 vendor directories (`node_modules`, `.git`, `.agents-reverse-engineer`, `vendor`, `dist`, `build`, `__pycache__`, `.next`, `venv`, `.venv`, `target`, `.cargo`, `.gradle`) via `SKIP_DIRS.has(entry.name)` predicate; returns `AgentsDocs` array with `{ relativePath, content }` objects.

## Subdirectories

**[prompts/](./prompts/)** — Exports `buildFilePrompt()` constructing Phase 1 `.sum` analysis prompts with import context and incremental update support via `FILE_UPDATE_SYSTEM_PROMPT`, `buildDirectoryPrompt()` aggregating child summaries into Phase 2 `AGENTS.md` synthesis prompts with manifest detection (9 types: package.json, Cargo.toml, go.mod, pyproject.toml, pom.xml, build.gradle, Gemfile, composer.json, CMakeLists.txt/Makefile) and `extractDirectoryImports()` for source files matching `/\.(ts|tsx|js|jsx|py|go|rs|java|kt)$/`, `buildRootPrompt()` collecting all `AGENTS.md` files via `collectAgentsDocs()` for Phase 3 platform-specific root document generation; templates enforce density rules (every sentence references identifiers, ban filler phrases), anchor term preservation (exact casing), path accuracy (use only Import Map paths); user documentation preserved via `AGENTS.local.md` prepending with comment block wrapper.

**[writers/](./writers/)** — Exports `writeSumFile()` serializing YAML frontmatter with SHA-256 `content_hash` via `formatSumFile()`, `readSumFile()` parsing frontmatter via regex-based `parseSumFile()` with null on parse failure, `getSumPath()` appending `.sum` extension, `sumFileExists()` checking filesystem via `readSumFile()` null test; `writeAgentsMd()` implementing four-step protocol: in-place `AGENTS.md` → `AGENTS.local.md` rename if missing `GENERATED_MARKER`, fallback `AGENTS.local.md` load, marker stripping from LLM content, assembly with user content prepended in comment block; `parseYamlArray()`/`formatYamlArray()` supporting inline `[a, b, c]` and multi-line `- item` formats.

## Architecture

### Three-Phase Pipeline

**Phase 1: Concurrent File Analysis**
1. `GenerationOrchestrator.prepareFiles()` reads source file content via `readFile()`
2. `createFileTasks()` calls `buildFilePrompt()` for each file with import context from `extractDirectoryImports()`
3. Worker pool executes file tasks in parallel (default concurrency: 2 for WSL, 5 elsewhere)
4. `writeSumFile()` persists `.sum` files with YAML frontmatter containing `generated_at`, `content_hash`, `purpose`, optional `critical_todos`/`related_files`

**Phase 2: Post-Order Directory Aggregation**
1. `buildExecutionPlan()` sorts directories by `getDirectoryDepth()` descending (deepest first)
2. `isDirectoryComplete()` waits for all child `.sum` files to exist via `sumFileExists()` predicate
3. `buildDirectoryPrompt()` reads child `.sum` files via `readSumFile()`, detects manifests (package.json, Cargo.toml, etc.), extracts import maps via `extractDirectoryImports()`
4. `writeAgentsMd()` renames user `AGENTS.md` → `AGENTS.local.md` if non-generated, prepends user content to LLM output

**Phase 3: Root Document Synthesis**
1. `collectAgentsDocs()` recursively aggregates all `AGENTS.md` files
2. `buildRootPrompt()` reads root `package.json` for project metadata (`name`, `version`, `description`, `packageManager`, `scripts`)
3. Sequential execution (concurrency=1) generates `CLAUDE.md`, `GEMINI.md`, `OPENCODE.md`
4. Templates enforce synthesis-only constraint (no invention/extrapolation, every claim traceable to `AGENTS.md`)

### Dependency Graph Construction

`buildExecutionPlan()` constructs task dependencies:
- File tasks: `id: 'file:${path}'`, `dependencies: []`, `outputPath: ${absolutePath}.sum`
- Directory tasks: `id: 'dir:${dir}'`, `dependencies` array populated from `directoryFileMap[dir]` paths mapped to `file:${path}` task IDs, `metadata.depth` from `getDirectoryDepth(dir)`, `metadata.directoryFiles` as file list
- Root tasks: `id: 'root:CLAUDE.md'`, `dependencies` array containing all directory task IDs

Directory tasks wait for child file tasks via `isDirectoryComplete()` checking `.sum` file existence. Root tasks wait for all directory tasks via dependency array containing every `dir:${path}` task ID.

### Incremental Update Support

`buildFilePrompt()` switches to `FILE_UPDATE_SYSTEM_PROMPT` when `existingSum` detected, instructing: "preserve structure/headings/phrasing verbatim where code unchanged, add/remove sections only when code introduces/deletes concepts". Similarly `buildDirectoryPrompt()` switches to `DIRECTORY_UPDATE_SYSTEM_PROMPT` when `existingAgentsMd` present. Reduces version control churn during `are update` workflow by minimizing unnecessary rewrites.

## File Relationships

**Consumed by src/orchestration/runner.ts:**
- Calls `createOrchestrator()` from `orchestrator.ts` to instantiate `GenerationOrchestrator`
- Calls `orchestrator.createPlan()` to generate `GenerationPlan`
- Calls `buildExecutionPlan()` from `executor.ts` to transform plan into dependency-ordered `ExecutionPlan`
- Executes tasks respecting `dependencies[]` ordering via worker pool

**Consumes src/imports/extractor.ts:**
- Calls `extractDirectoryImports()` in `buildFilePrompt()` to inject import context for Phase 1 file analysis
- Calls `extractDirectoryImports()` in `buildDirectoryPrompt()` to inject import maps for Phase 2 directory synthesis

**Consumes src/ai/service.ts:**
- `runner.ts` invokes `AIService.call()` for each task, passing `systemPrompt`/`userPrompt` from `ExecutionTask`
- LLM responses populate `AnalysisResult` with `summary`/`metadata` for `.sum` file writing

**Consumed by src/cli/generate.ts:**
- Imports `createOrchestrator` to orchestrate three-phase pipeline
- Imports `buildExecutionPlan` to transform plan into executable tasks
- Imports `formatExecutionPlanAsMarkdown` to write `GENERATION-PLAN.md`

**Consumed by src/update/orchestrator.ts:**
- Calls `readSumFile()` to extract `content_hash` for SHA-256 comparison during incremental updates
- Calls `buildFilePrompt()` with `existingSum` parameter to trigger update-specific prompts

**Consumed by src/quality/inconsistency/code-vs-doc.ts:**
- Calls `readSumFile()` to extract exported symbols from `.sum` summaries for consistency validation

## Integration Points

**Trace Emission:** `GenerationOrchestrator.createPlan()` emits `phase:start`, `plan:created`, `phase:end` traces via `ITraceWriter` from `src/orchestration/trace.ts`.

**Progress Tracking:** `formatExecutionPlanAsMarkdown()` output written to `GENERATION-PLAN.md` via `PlanTracker` in `src/orchestration/plan-tracker.ts`.

**Memory Management:** `prepareFiles()` clears `content` fields on `PreparedFile` objects after `createFileTasks()` to release file content strings since content is already embedded in task prompts.

**Quality Validation:** Exported symbols extracted via regex in `src/quality/inconsistency/code-vs-doc.ts` compared against `.sum` summary text via substring search; phantom paths extracted from `AGENTS.md` via three regex patterns in `src/quality/phantom-paths/validator.ts` resolved against filesystem via `existsSync()`.