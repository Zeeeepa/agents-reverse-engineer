<!-- Generated by agents-reverse-engineer -->

# generation

**Orchestrates ARE's three-phase documentation generation pipeline: Phase 1 concurrent file analysis via worker pools generating `.sum` files with SHA-256 hashes, Phase 2 post-order directory aggregation synthesizing `AGENTS.md` from child summaries, Phase 3 sequential root document synthesis producing `CLAUDE.md`/`GEMINI.md`/`OPENCODE.md` from complete corpus.**

## Contents

### Pipeline Coordination

**[orchestrator.ts](./orchestrator.ts)** — `GenerationOrchestrator` class exports `createPlan()` method constructing `GenerationPlan` via four-step workflow: `prepareFiles()` loads file content into `PreparedFile[]`, `analyzeComplexity()` computes `directoryDepth` and unique `directories` set, `buildProjectStructure()` formats compact directory tree, `createFileTasks()` builds `AnalysisTask[]` with prompts via `buildFilePrompt()`, `createDirectoryTasks()` groups files by directory returning directory-level tasks. Emits trace events (`phase:start`, `plan:created`, `phase:end`) via injected `ITraceWriter`. Clears `PreparedFile.content` after prompt embedding to free heap memory. Returns `{ files, tasks, complexity, projectStructure }`.

**[executor.ts](./executor.ts)** — Transforms `GenerationPlan` into dependency-aware `ExecutionPlan` via `buildExecutionPlan()`: groups files by directory into `directoryFileMap`, creates `fileTasks[]` with `id: 'file:${path}'` and empty `dependencies[]`, sorts by depth descending for leaf-first processing, creates `directoryTasks[]` depending on child file task IDs for post-order traversal, creates `rootTasks[]` depending on all directory task IDs. Exports `isDirectoryComplete()` predicate checking child `.sum` file existence via `sumFileExists()` and `getReadyDirectories()` async filter. `formatExecutionPlanAsMarkdown()` generates `GENERATION-PLAN.md` with three-phase checklist grouped by directory depth.

**[complexity.ts](./complexity.ts)** — `analyzeComplexity()` computes `ComplexityMetrics` via `calculateDirectoryDepth()` (max depth via `split(sep).length - 1`) and `extractDirectories()` (unique directories via upward `dirname()` traversal). Returns `{ fileCount, directoryDepth, files, directories }` consumed by orchestrator for concurrency tuning and Phase 2 directory queue construction.

**[collector.ts](./collector.ts)** — Exports `collectAgentsDocs()` recursively walking project tree collecting `AGENTS.md` files as `AgentsDocs` array of `{ relativePath, content }` sorted alphabetically, and `collectAnnexFiles()` similarly collecting `.annex.md` files. Both skip `SKIP_DIRS` set (13 entries: node_modules, .git, vendor, dist, build, etc.) and silently suppress permission errors.

**[types.ts](./types.ts)** — Defines `AnalysisResult` containing `summary: string` and `metadata: SummaryMetadata` returned by Phase 1 AI subprocess calls, `SummaryMetadata` YAML frontmatter schema with `purpose`, `criticalTodos?`, `relatedFiles?` fields, and `SummaryOptions` for summary verbosity configuration.

## Subdirectories

**[prompts/](./prompts/)** — Template-based prompt construction pipeline: `buildFilePrompt()` injects file path/content/imports into `FILE_USER_PROMPT` with density rules and identifier preservation constraints, `buildDirectoryPrompt()` aggregates `.sum` files and child `AGENTS.md` with manifest detection (9 types) and import maps via `extractDirectoryImports()`, `buildRootPrompt()` synthesizes `CLAUDE.md` from complete `AGENTS.md` corpus with synthesis-only constraints prohibiting invented features. Exports six prompt constants with mustache-style placeholders (`{{FILE_PATH}}`, `{{CONTENT}}`), prohibited filler phrases, YAML frontmatter format, and annex reference format.

**[writers/](./writers/)** — YAML frontmatter-based file I/O layer: `writeSumFile()`/`readSumFile()` implement `.sum` persistence with SHA-256 `content_hash` via regex-based field extraction and dual-format YAML array handling (inline `[a,b,c]` vs multi-line), `writeAgentsMd()` preserves user-authored `AGENTS.md` by renaming to `AGENTS.local.md` and prepending above generated content with `GENERATED_MARKER` injection/stripping, `writeAnnexFile()` archives verbatim source for reproduction-critical files (prompt templates, config schemas). Exports `sumFileExists()` predicate for change detection and `isGeneratedAgentsMd()` marker detection.

## Three-Phase Execution Strategy

**Phase 1: Concurrent File Analysis**
- Orchestrator creates `fileTasks[]` with prompts via `buildFilePrompt()` embedding import maps and project structure
- Runner spawns worker pool (`src/orchestration/pool.ts`) executing tasks concurrently (default concurrency: 2 for WSL, 5 elsewhere)
- Each worker calls `AIService.call()` → `runSubprocess()` → `execFile()` spawning AI CLI subprocesses with resource limits (`--max-old-space-size=512`, `UV_THREADPOOL_SIZE=4`, `CLAUDE_CODE_DISABLE_BACKGROUND_TASKS=1`)
- Worker writes `AnalysisResult` via `writeSumFile()` with YAML frontmatter containing SHA-256 `content_hash` and markdown summary body

**Phase 2: Post-Order Directory Aggregation**
- Executor sorts `directoryTasks[]` by depth descending (deepest first) via `getDirectoryDepth()` ensuring child directories complete before parents
- Runner sequentially processes directories checking readiness via `isDirectoryComplete()` predicate polling for child `.sum` file existence
- Prompt builder calls `buildDirectoryPrompt()` reading child `.sum` files via `readSumFile()`, aggregating subdirectory `AGENTS.md`, extracting imports via `extractDirectoryImports()`, detecting manifests (9 types: package.json, Cargo.toml, go.mod, etc.)
- Runner writes `AGENTS.md` via `writeAgentsMd()` preserving any `AGENTS.local.md` user content above generated sections

**Phase 3: Sequential Root Synthesis**
- Executor creates `rootTasks[]` depending on all directory task IDs enforcing sequential execution (concurrency=1)
- Prompt builder calls `buildRootPrompt()` consuming all `AGENTS.md` files via `collectAgentsDocs()`, reading root `package.json` metadata, embedding synthesis constraints prohibiting invented features
- Runner writes platform-specific root documents (`CLAUDE.md`, `GEMINI.md`, `OPENCODE.md`) via `src/integration/generate.ts`

## Post-Order Traversal Mechanism

Executor sorts directory tasks by depth descending:
```typescript
directoryTasks.sort((a, b) => 
  getDirectoryDepth(b.path) - getDirectoryDepth(a.path)
)
```

where `getDirectoryDepth('.')` returns `0`, `getDirectoryDepth('src')` returns `1`, `getDirectoryDepth('src/cli')` returns `2`. Deepest directories process first ensuring child `AGENTS.md` exist before parent aggregation attempts. Runner polls `isDirectoryComplete()` checking all expected `.sum` files exist via `sumFileExists()` before processing directory task.

## Memory Management Pattern

Orchestrator clears `PreparedFile.content` after prompt construction:
```typescript
for (const file of files) {
  (file as { content: string }).content = ''
}
```

This frees heap memory since file content already embedded in `AnalysisTask.userPrompt` strings. Runner re-reads files from disk during execution if needed. Prevents memory exhaustion on large codebases (10k+ files).

## Integration Points

Consumes:
- `DiscoveryResult` from `src/discovery/walker.ts` (file list input)
- `Config` from `src/config/schema.ts` (concurrency, timeout, model settings)
- `ITraceWriter` from `src/orchestration/trace.ts` (event emission)
- `buildFilePrompt`, `buildDirectoryPrompt`, `buildRootPrompt` from `./prompts/builder.ts`
- `writeSumFile`, `writeAgentsMd` from `./writers/`
- `extractDirectoryImports` from `src/imports/extractor.ts`
- `collectAgentsDocs` from `./collector.ts`

Produces:
- `GenerationPlan` consumed by `src/orchestration/runner.ts`
- `ExecutionPlan` consumed by Phase 1/2/3 execution loops
- `.sum` files consumed by `src/update/orchestrator.ts` for change detection
- `AGENTS.md` files consumed by Phase 3 root synthesis and `src/specify/index.ts`
- `GENERATION-PLAN.md` consumed by progress tracking

Referenced by:
- `src/cli/generate.ts` (command entry point)
- `src/cli/update.ts` (incremental update workflow)
- `src/orchestration/runner.ts` (phase execution orchestrator)

## Behavioral Contracts

### Depth Calculation (executor.ts)
```typescript
getDirectoryDepth('.')          → 0
getDirectoryDepth('src')        → 1
getDirectoryDepth('src/cli')    → 2
getDirectoryDepth('a/b/c/d')    → 4
```

### File Task Dependencies (executor.ts)
```typescript
fileTasks.forEach(task => task.dependencies = [])  // No dependencies, all parallel
```

### Directory Task Dependencies (executor.ts)
```typescript
directoryTask.dependencies = directoryFileMap[dirPath].map(f => `file:${f}`)
```

### Root Task Dependencies (executor.ts)
```typescript
rootTask.dependencies = directoryTasks.map(t => t.id)  // All directories
```

### SKIP_DIRS Set (collector.ts)
```typescript
['node_modules', '.git', '.agents-reverse-engineer', 'vendor', 'dist', 
 'build', '__pycache__', '.next', 'venv', '.venv', 'target', '.cargo', '.gradle']
```

### Manifest Detection Array (prompts/builder.ts)
```typescript
['package.json', 'Cargo.toml', 'go.mod', 'pyproject.toml', 'pom.xml',
 'build.gradle', 'Gemfile', 'composer.json', 'CMakeLists.txt', 'Makefile']
```

### Language Detection Map (prompts/builder.ts)
```typescript
.ts → typescript, .tsx → typescript, .js → javascript, .jsx → javascript,
.py → python, .go → go, .rs → rust, .java → java, .kt → kotlin,
.rb → ruby, .php → php, .c → c, .cpp → cpp, .cs → csharp,
.swift → swift, .scala → scala, .sh → bash, .md → markdown,
.yaml → yaml, .yml → yaml, .json → json, .toml → toml
Default: text
```

## Annex References

- Full prompt template text: [prompts/templates.ts.annex.md](./prompts/templates.ts.annex.md)
- `SUMMARY_GUIDELINES` object structure: [prompts/types.ts.annex.md](./prompts/types.ts.annex.md)
- Phase 2/3 execution workflow details: [../orchestration/runner.ts.annex.md](../orchestration/runner.ts.annex.md)