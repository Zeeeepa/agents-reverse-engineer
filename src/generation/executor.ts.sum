---
generated_at: 2026-02-09T16:10:33.258Z
content_hash: ce2e011f7fef57965d65e9ef53021b1c55e08a731d46740a22fe9df388a8a907
purpose: Transforms GenerationPlan into ExecutionPlan with dependency-ordered tasks for the three-phase documentation pipeline...
---
**Transforms GenerationPlan into ExecutionPlan with dependency-ordered tasks for the three-phase documentation pipeline, enforcing post-order directory traversal via depth-based sorting.**

## Exported Types

**ExecutionTask** — Individual work unit for AI processing with dependency tracking
- `id: string` — Unique identifier (format: `file:<path>` | `dir:<path>` | `root:<filename>`)
- `type: 'file' | 'directory' | 'root-doc'` — Task category determining pipeline phase
- `path: string` — Relative path from project root
- `absolutePath: string` — Resolved filesystem path
- `systemPrompt: string` — AI system context (placeholder for dir/root, actual for file)
- `userPrompt: string` — AI generation instructions (placeholder for dir/root, actual for file)
- `dependencies: string[]` — Task IDs that must complete before this task can execute
- `outputPath: string` — Target file for generated content (`.sum`, `AGENTS.md`, `CLAUDE.md`)
- `metadata: { directoryFiles?: string[]; depth?: number; packageRoot?: string }` — Task-specific context

**ExecutionPlan** — Complete dependency graph for pipeline execution
- `projectRoot: string` — Absolute project base path
- `tasks: ExecutionTask[]` — All tasks in dependency-satisfying order
- `fileTasks: ExecutionTask[]` — Phase 1 tasks (parallel-eligible)
- `directoryTasks: ExecutionTask[]` — Phase 2 tasks (post-order sorted by depth descending)
- `rootTasks: ExecutionTask[]` — Phase 3 tasks (sequential, depends on all directories)
- `directoryFileMap: Record<string, string[]>` — Directory to file paths mapping for completion tracking
- `projectStructure?: string` — Compact file tree for directory prompt context

## Core Functions

**buildExecutionPlan(plan: GenerationPlan, projectRoot: string): ExecutionPlan** — Constructs execution plan with post-order directory traversal

Creates three task categories:
1. **fileTasks**: Maps `plan.tasks` with `type === 'file'` to ExecutionTask, generates IDs via `file:${task.filePath}`, outputs to `${absolutePath}.sum`, zero dependencies, sorts by directory depth descending via `getDirectoryDepth(path.dirname(a.path))` comparison
2. **directoryTasks**: Builds from `directoryFileMap` entries sorted by `getDirectoryDepth(dirB) - getDirectoryDepth(dirA)`, assigns `dependencies` as `files.map(f => 'file:${f}')`, placeholder prompts ("Built at execution time by buildDirectoryPrompt()"), outputs to `${dirAbsPath}/AGENTS.md`, stores `metadata.depth` and `metadata.directoryFiles`
3. **rootTasks**: Single task `root:CLAUDE.md` depending on all directory task IDs, placeholder prompts ("Built at runtime by buildRootPrompt()"), outputs to `${projectRoot}/CLAUDE.md`

**isDirectoryComplete(dirPath: string, expectedFiles: string[], projectRoot: string): Promise<{ complete: boolean; missing: string[] }>** — Verifies all files in directory have `.sum` artifacts via `sumFileExists()`

Iterates `expectedFiles`, resolves each via `path.join(projectRoot, relativePath)`, checks `sumFileExists(absolutePath)`, accumulates missing paths, returns completion status and missing array.

**getReadyDirectories(executionPlan: ExecutionPlan): Promise<string[]>** — Filters directories with all `.sum` files present

Iterates `executionPlan.directoryFileMap` entries, calls `isDirectoryComplete(dir, files, executionPlan.projectRoot)`, collects directories where `complete === true`.

**formatExecutionPlanAsMarkdown(plan: ExecutionPlan): string** — Generates GENERATION-PLAN.md with post-order task breakdown

Produces markdown with:
- Header: `# Documentation Generation Plan` with ISO date from `new Date().toISOString().split('T')[0]` and `plan.projectRoot`
- Summary: Task counts (`plan.tasks.length`, `plan.fileTasks.length`, `plan.directoryTasks.length`, `plan.rootTasks.length`) and traversal strategy ("Post-order (children before parents)")
- Phase 1: Groups `plan.fileTasks` by directory via `task.path.lastIndexOf('/')`, outputs sections `### Depth ${depth}: ${dir}/ (${files.length} files)` using `plan.directoryTasks` order, checkbox items `- [ ] \`${file}\``
- Phase 2: Groups `plan.directoryTasks` by `metadata.depth`, sorts depths descending, outputs `### Depth ${depth}` sections with `- [ ] \`${dir}/AGENTS.md\`` items
- Phase 3: Hardcoded `- [ ] \`CLAUDE.md\`` entry

## Dependency Relationships

**Input:** GenerationPlan from `src/generation/orchestrator.ts` containing `tasks[]` with `type/filePath/systemPrompt/userPrompt`, `files[]` with `relativePath`

**Output:** ExecutionPlan consumed by `src/orchestration/runner.ts` for phase execution

**External dependencies:**
- `sumFileExists()` from `src/generation/writers/sum.ts` — Checks `.sum` file existence for completion tracking
- `path.join()`, `path.dirname()`, `path.sep` — Path manipulation for task ID generation and depth calculation

## Post-Order Traversal Strategy

**getDirectoryDepth(dir: string): number** — Calculates directory nesting level

Returns 0 for root `"."`, otherwise counts path segments via `dir.split(path.sep).length`. Examples: `"src"` → 1, `"src/cli"` → 2, `"src/generation/prompts"` → 3.

Sorting pattern: `(a, b) => getDirectoryDepth(dirB) - getDirectoryDepth(dirA)` ensures deepest directories process first, guaranteeing child `AGENTS.md` exist before parent synthesis (Phase 2 requirement documented in `src/generation/orchestrator.ts`).

## Task ID Format

**File tasks:** `file:<relativePath>` (e.g., `file:src/cli/index.ts`)
**Directory tasks:** `dir:<relativePath>` (e.g., `dir:src/cli`)
**Root tasks:** `root:<filename>` (e.g., `root:CLAUDE.md`)

Dependency arrays reference these IDs exactly: `directoryTask.dependencies = files.map(f => 'file:${f}')`, `rootTask.dependencies = allDirTaskIds`.

## Placeholder Prompts

Directory and root tasks store placeholder strings for `systemPrompt`/`userPrompt`:
- Directory: `"Built at execution time by buildDirectoryPrompt()"` / `"Directory "${dir}" — ${files.length} files. Prompt populated from .sum files at runtime."`
- Root: `"Built at runtime by buildRootPrompt()"` / `"Root document — prompt populated from AGENTS.md files at runtime."`

Actual prompts constructed in `src/orchestration/runner.ts` Phase 2/3 via `buildDirectoryPrompt()` and `buildRootPrompt()` consuming `.sum` and `AGENTS.md` files. Placeholders exist only for plan display via `formatExecutionPlanAsMarkdown()` and dependency graph structure.