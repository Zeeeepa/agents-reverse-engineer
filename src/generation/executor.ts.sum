---
generated_at: 2026-02-09T17:45:21.026Z
content_hash: ce2e011f7fef57965d65e9ef53021b1c55e08a731d46740a22fe9df388a8a907
purpose: executor.ts builds ExecutionPlan from GenerationPlan with dependency graph, post-order directory traversal sorting (d...
---
**executor.ts builds ExecutionPlan from GenerationPlan with dependency graph, post-order directory traversal sorting (deepest-first), directory completion tracking via sumFileExists(), and markdown plan formatting for GENERATION-PLAN.md output.**

## Exported Types

**ExecutionTask** represents a single AI processing job with fields:
- `id: string` — unique identifier with format `"file:{path}"`, `"dir:{path}"`, or `"root:{docname}"`
- `type: 'file' | 'directory' | 'root-doc'` — discriminates task category
- `path: string` — relative path to file or directory
- `absolutePath: string` — resolved absolute path
- `systemPrompt: string` — AI system prompt (placeholder for dir/root tasks, built at runtime)
- `userPrompt: string` — AI user prompt (placeholder for dir/root tasks, built at runtime)
- `dependencies: string[]` — array of task IDs that must complete first
- `outputPath: string` — destination path for generated content (`.sum` for files, `AGENTS.md` for dirs, root doc name for root)
- `metadata: { directoryFiles?: string[], depth?: number, packageRoot?: string }` — tracking metadata

**ExecutionPlan** aggregates all tasks with dependency relationships:
- `projectRoot: string` — absolute project root path
- `tasks: ExecutionTask[]` — all tasks in execution order
- `fileTasks: ExecutionTask[]` — Phase 1 file analysis tasks (parallel eligible)
- `directoryTasks: ExecutionTask[]` — Phase 2 directory aggregation tasks (post-order sorted)
- `rootTasks: ExecutionTask[]` — Phase 3 root document synthesis tasks (sequential)
- `directoryFileMap: Record<string, string[]>` — maps directory path to relative file paths
- `projectStructure?: string` — optional compact directory listing for prompt context

## Core Functions

**buildExecutionPlan(plan: GenerationPlan, projectRoot: string): ExecutionPlan** constructs dependency graph from GenerationPlan:
1. Populates `directoryFileMap` by extracting `path.dirname()` from each `file.relativePath`
2. Creates file tasks with `id: "file:{filePath}"`, `type: 'file'`, `dependencies: []`, `outputPath: "{absolutePath}.sum"`
3. Sorts file tasks by directory depth descending via `getDirectoryDepth(path.dirname(a.path))` comparison (deepest first for post-order traversal)
4. Sorts directories by depth descending via `Object.entries(directoryFileMap).sort(([dirA], [dirB]) => getDirectoryDepth(dirB) - getDirectoryDepth(dirA))`
5. Creates directory tasks with `id: "dir:{dir}"`, `type: 'directory'`, `dependencies: fileTaskIds` (all file tasks in directory), `outputPath: "{dirAbsPath}/AGENTS.md"`, `metadata: { directoryFiles, depth }`
6. Creates root tasks with `id: "root:CLAUDE.md"`, `type: 'root-doc'`, `dependencies: allDirTaskIds`, `outputPath: "{projectRoot}/CLAUDE.md"`
7. Returns ExecutionPlan with fileTasks/directoryTasks/rootTasks arrays and directoryFileMap

**getDirectoryDepth(dir: string): number** calculates path segment count:
- Returns `0` for root directory `"."`
- Returns `dir.split(path.sep).length` for non-root directories

**isDirectoryComplete(dirPath: string, expectedFiles: string[], projectRoot: string): Promise<{ complete: boolean; missing: string[] }>** checks if all files have `.sum` outputs:
- Iterates `expectedFiles` array, resolves absolute path via `path.join(projectRoot, relativePath)`
- Calls `sumFileExists(absolutePath)` for each file
- Returns `{ complete: missing.length === 0, missing }` with array of paths lacking `.sum` files

**getReadyDirectories(executionPlan: ExecutionPlan): Promise<string[]>** identifies directories eligible for AGENTS.md generation:
- Iterates `executionPlan.directoryFileMap` entries
- Calls `isDirectoryComplete(dir, files, executionPlan.projectRoot)` for each directory
- Returns array of directory paths where `complete === true`

**formatExecutionPlanAsMarkdown(plan: ExecutionPlan): string** generates GENERATION-PLAN.md content:
- Writes header with ISO date (`new Date().toISOString().split('T')[0]`) and `plan.projectRoot`
- Writes summary section with task counts: `plan.tasks.length`, `plan.fileTasks.length`, `plan.directoryTasks.length`, `plan.rootTasks.length`
- Writes Phase 1 section grouping files by directory, outputting in post-order using `plan.directoryTasks` traversal order
- Writes Phase 2 section grouping directories by depth (descending), outputting `{dir}/AGENTS.md` with `(root)` suffix for `dir === "."`
- Writes Phase 3 section listing `CLAUDE.md`
- Returns markdown string with checkbox format: `- [ ] \`{path}\``

## Post-Order Traversal Strategy

buildExecutionPlan() enforces post-order traversal (children before parents) via two sorting operations:
1. **File tasks**: sorted by `getDirectoryDepth(path.dirname(a.path))` descending so deepest files process first
2. **Directory tasks**: sorted by `getDirectoryDepth(dirB) - getDirectoryDepth(dirA)` descending so child directories generate AGENTS.md before parent directories

This ensures child AGENTS.md files exist before parent directory aggregation prompts consume them (referenced in src/generation/prompts/builder.ts buildDirectoryPrompt() via collectAgentsDocs() recursive traversal).

## Integration Points

- **GenerationPlan import** from `./orchestrator.js` consumed by buildExecutionPlan()
- **sumFileExists()** from `./writers/sum.js` checks for `.sum` file presence in isDirectoryComplete()
- **Dependency tracking** via `dependencies: string[]` enforces Phase 1 → Phase 2 → Phase 3 sequencing in src/orchestration/runner.ts
- **Prompt placeholders** for directory/root tasks (`"Built at runtime by buildRootPrompt()"`) signal runtime prompt construction in runner.ts Phase 2/3

## Placeholder Prompt Pattern

ExecutionTask includes `systemPrompt` and `userPrompt` fields populated with placeholders for directory/root tasks:
- Directory tasks: `systemPrompt: "Built at execution time by buildDirectoryPrompt()"`, `userPrompt: "Directory \"{dir}\" — {files.length} files. Prompt populated from .sum files at runtime."`
- Root tasks: `systemPrompt: "Built at runtime by buildRootPrompt()"`, `userPrompt: "Root document — prompt populated from AGENTS.md files at runtime."`

These placeholders exist for plan display (formatExecutionPlanAsMarkdown()) and dependency tracking; actual prompts constructed at execution time in runner.ts via buildDirectoryPrompt() and buildRootPrompt() from src/generation/prompts/builder.ts.