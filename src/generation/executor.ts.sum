---
generated_at: 2026-02-09T15:07:31.553Z
content_hash: ce2e011f7fef57965d65e9ef53021b1c55e08a731d46740a22fe9df388a8a907
purpose: Builds ExecutionPlan with dependency-ordered tasks from GenerationPlan, tracking file-to-directory relationships and ...
---
**Builds ExecutionPlan with dependency-ordered tasks from GenerationPlan, tracking file-to-directory relationships and post-order traversal depth for three-phase pipeline orchestration.**

## Exported Types

**ExecutionTask** defines AI-ready work unit with fields:
- `id: string` — Unique identifier (patterns: `file:${path}`, `dir:${path}`, `root:${docName}`)
- `type: 'file' | 'directory' | 'root-doc'` — Task category
- `path: string` — Relative path
- `absolutePath: string` — Full filesystem path
- `systemPrompt: string` — AI system context
- `userPrompt: string` — AI user instructions
- `dependencies: string[]` — Task IDs that must complete first (enables topological execution)
- `outputPath: string` — Destination for generated content (`.sum` for files, `AGENTS.md` for dirs, root doc names for root tasks)
- `metadata: { directoryFiles?: string[], depth?: number, packageRoot?: string }` — Tracking metadata

**ExecutionPlan** structures dependency graph with fields:
- `projectRoot: string` — Base directory
- `tasks: ExecutionTask[]` — All tasks in flattened array
- `fileTasks: ExecutionTask[]` — Phase 1 file analysis tasks (parallel-eligible)
- `directoryTasks: ExecutionTask[]` — Phase 2 directory aggregation tasks (post-order sorted by depth descending)
- `rootTasks: ExecutionTask[]` — Phase 3 root document synthesis tasks (sequential)
- `directoryFileMap: Record<string, string[]>` — Maps directory paths to contained file paths
- `projectStructure?: string` — Compact project tree for directory prompt context

## Core Functions

**buildExecutionPlan(plan: GenerationPlan, projectRoot: string): ExecutionPlan** transforms GenerationPlan into dependency-ordered execution structure:
1. Builds `directoryFileMap` by extracting `path.dirname()` from each file's `relativePath`
2. Creates file tasks with `id: 'file:${filePath}'`, empty `dependencies`, `outputPath` as `${absolutePath}.sum`
3. Sorts file tasks by directory depth descending via `getDirectoryDepth(path.dirname(a.path))` comparison
4. Sorts directories by depth descending via `getDirectoryDepth(dirB) - getDirectoryDepth(dirA)` (enables post-order traversal)
5. Creates directory tasks with `id: 'dir:${dir}'`, `dependencies` as array of file task IDs from that directory, `metadata.depth` from `getDirectoryDepth(dir)`, `metadata.directoryFiles` as file list
6. Creates root tasks with `id: 'root:CLAUDE.md'`, `dependencies` as all directory task IDs, placeholder prompts "Built at runtime by buildRootPrompt()" (actual prompts constructed in `runner.ts` Phase 3)
7. Returns ExecutionPlan with concatenated task arrays and computed `projectStructure` from input plan

**getDirectoryDepth(dir: string): number** computes path segment count:
- Returns `0` for root directory `'.'`
- Returns `dir.split(path.sep).length` for all other paths
- Examples: `"src"` → 1, `"src/cli"` → 2

**isDirectoryComplete(dirPath: string, expectedFiles: string[], projectRoot: string): Promise<{ complete: boolean; missing: string[] }>** validates readiness:
1. Iterates `expectedFiles` array
2. Joins each `relativePath` with `projectRoot` to get `absolutePath`
3. Calls `sumFileExists(absolutePath)` to check for `.sum` file existence
4. Appends to `missing[]` array if absent
5. Returns `{ complete: missing.length === 0, missing }` object

**getReadyDirectories(executionPlan: ExecutionPlan): Promise<string[]>** filters directories with complete file analysis:
1. Iterates `Object.entries(executionPlan.directoryFileMap)`
2. Awaits `isDirectoryComplete(dir, files, executionPlan.projectRoot)`
3. Pushes `dir` to `ready[]` array if `complete === true`
4. Returns ready directory paths

**formatExecutionPlanAsMarkdown(plan: ExecutionPlan): string** renders human-readable plan with post-order visualization:
1. Builds markdown header with `plan.projectRoot`, current date, task counts (`plan.tasks.length`, `plan.fileTasks.length`, `plan.directoryTasks.length`, `plan.rootTasks.length`)
2. Groups file tasks by directory into `filesByDir: Record<string, Set<string>>` using `path.substring(0, task.path.lastIndexOf('/'))` extraction (deduplicated via Set)
3. Outputs **Phase 1: File Analysis** section iterating `plan.directoryTasks` (preserves post-order) and rendering each directory's files with `- [ ] \`${file}\`` checkbox format
4. Groups directory tasks by depth into `dirsByDepth: Record<number, string[]>` using `task.metadata.depth ?? 0`
5. Outputs **Phase 2: Directory AGENTS.md** section with depths sorted descending via `Object.keys(dirsByDepth).map(Number).sort((a, b) => b - a)`, renders `- [ ] \`${dir}/AGENTS.md\`` with root directory suffix
6. Outputs **Phase 3: Root Documents** section with hardcoded `- [ ] \`CLAUDE.md\`` entry
7. Returns concatenated markdown string

## Dependencies

Imports `GenerationPlan` from `./orchestrator.js` (input structure with files/tasks/projectStructure), `sumFileExists` from `./writers/sum.js` (checks `.sum` file presence for dependency resolution).

## Design Patterns

**Post-Order Traversal Enforcement**: Both file and directory task arrays sorted by `getDirectoryDepth()` descending ensures child directories processed before parents (deepest nodes first, root last).

**Dependency Graph Construction**: File tasks populate directory task `dependencies[]` arrays by mapping `directoryFileMap[dir]` paths to `file:${path}` task IDs; all directory task IDs become dependencies for root tasks.

**Runtime Prompt Deferral**: Directory and root task prompts contain placeholder strings (`"Built at runtime by buildDirectoryPrompt()"`, `"Built at runtime by buildRootPrompt()"`) because actual prompts require reading generated `.sum` and `AGENTS.md` files not available during plan construction.

## Integration Points

**Orchestrator Input**: Consumes `GenerationPlan` from `src/generation/orchestrator.ts` with `files[]`, `tasks[]`, `projectStructure` fields.

**Runner Execution**: ExecutionPlan passed to `src/orchestration/runner.ts` which executes tasks respecting `dependencies[]` ordering and populates runtime prompts.

**Plan Tracking**: Markdown output from `formatExecutionPlanAsMarkdown()` written to `GENERATION-PLAN.md` via `PlanTracker` in `src/orchestration/plan-tracker.ts`.