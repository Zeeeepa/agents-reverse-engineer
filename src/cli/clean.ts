/**
 * `are clean` command - Delete all generated documentation artifacts
 *
 * Removes .sum files, generated AGENTS.md files, generated CLAUDE.md files,
 * and the GENERATION-PLAN.md file. Restores user-authored .local.md files.
 */

import path from 'node:path';
import { access, readFile, rename, unlink } from 'node:fs/promises';
import { constants } from 'node:fs';
import fg from 'fast-glob';
import pc from 'picocolors';
import { findProjectRoot } from '../config/loader.js';
import { createLogger } from '../output/logger.js';
import { GENERATED_MARKER } from '../generation/writers/agents-md.js';

/**
 * Options for the clean command.
 */
export interface CleanOptions {
  /**
   * Show files that would be deleted without deleting them.
   * @default false
   */
  dryRun: boolean;
}

/**
 * Execute the `are clean` command.
 *
 * Finds and deletes all generated documentation artifacts:
 * - `*.sum` files
 * - Generated `AGENTS.md` files (marker-checked)
 * - Generated `CLAUDE.md` files (marker-checked)
 * - `.agents-reverse-engineer/GENERATION-PLAN.md`
 *
 * @param targetPath - Project root directory (defaults to current working directory)
 * @param options - Command options
 */
export async function cleanCommand(
  targetPath: string,
  options: CleanOptions
): Promise<void> {
  const resolvedPath = await findProjectRoot(path.resolve(targetPath || process.cwd()));

  const logger = createLogger({ colors: true });

  // Verify target path exists
  try {
    await access(resolvedPath, constants.R_OK);
  } catch (err) {
    const error = err as NodeJS.ErrnoException;
    if (error.code === 'ENOENT') {
      logger.error(`Directory not found: ${resolvedPath}`);
      process.exit(1);
    }
    if (error.code === 'EACCES' || error.code === 'EPERM') {
      logger.error(`Permission denied: ${resolvedPath}`);
      process.exit(1);
    }
    throw error;
  }

  // Find all artifacts (*.sum glob catches both .sum and .annex.sum)
  const [sumFiles, agentsFiles, localAgentsFiles, claudeFiles, localClaudeFiles] = await Promise.all([
    fg.glob('**/*.sum', {
      cwd: resolvedPath,
      absolute: true,
      onlyFiles: true,
      dot: true,
      ignore: ['**/node_modules/**', '**/.git/**'],
    }),
    fg.glob('**/AGENTS.md', {
      cwd: resolvedPath,
      absolute: true,
      onlyFiles: true,
      dot: true,
      ignore: ['**/node_modules/**', '**/.git/**'],
    }),
    fg.glob('**/AGENTS.local.md', {
      cwd: resolvedPath,
      absolute: true,
      onlyFiles: true,
      dot: true,
      ignore: ['**/node_modules/**', '**/.git/**'],
    }),
    fg.glob('**/CLAUDE.md', {
      cwd: resolvedPath,
      absolute: true,
      onlyFiles: true,
      dot: true,
      ignore: ['**/node_modules/**', '**/.git/**'],
    }),
    fg.glob('**/CLAUDE.local.md', {
      cwd: resolvedPath,
      absolute: true,
      onlyFiles: true,
      dot: true,
      ignore: ['**/node_modules/**', '**/.git/**'],
    }),
  ]);

  // Filter AGENTS.md to only those generated by ARE (contain the marker).
  // User-authored AGENTS.md files (e.g. SDK docs) must not be deleted.
  const generatedAgentsFiles: string[] = [];
  const skippedAgentsFiles: string[] = [];
  for (const file of agentsFiles) {
    try {
      const content = await readFile(file, 'utf-8');
      if (content.includes(GENERATED_MARKER)) {
        generatedAgentsFiles.push(file);
      } else {
        skippedAgentsFiles.push(file);
      }
    } catch {
      // Can't read — skip silently
    }
  }

  // Filter CLAUDE.md to only those generated by ARE (contain the marker).
  const generatedClaudeFiles: string[] = [];
  const skippedClaudeFiles: string[] = [];
  for (const file of claudeFiles) {
    try {
      const content = await readFile(file, 'utf-8');
      if (content.includes(GENERATED_MARKER)) {
        generatedClaudeFiles.push(file);
      } else {
        skippedClaudeFiles.push(file);
      }
    } catch {
      // Can't read — skip silently
    }
  }

  // Check for plan file
  const singleFiles: string[] = [];
  const planFile = path.join(resolvedPath, '.agents-reverse-engineer', 'GENERATION-PLAN.md');

  try {
    await access(planFile, constants.F_OK);
    singleFiles.push(planFile);
  } catch {
    // File doesn't exist - skip
  }

  const allLocalFiles = [...localAgentsFiles, ...localClaudeFiles];
  const allFiles = [...sumFiles, ...generatedAgentsFiles, ...generatedClaudeFiles, ...singleFiles];

  if (allFiles.length === 0 && allLocalFiles.length === 0) {
    logger.info('No generated artifacts found.');
    return;
  }

  // Display found files
  const relativePath = (absPath: string): string =>
    path.relative(resolvedPath, absPath);

  if (options.dryRun) {
    logger.info('Files that would be deleted:');
  }

  for (const file of allFiles) {
    logger.info(`  ${relativePath(file)}`);
  }

  const allSkippedFiles = [...skippedAgentsFiles, ...skippedClaudeFiles];
  if (allSkippedFiles.length > 0) {
    logger.info('');
    logger.info('Preserving user-authored files:');
    for (const file of allSkippedFiles) {
      logger.info(`  ${relativePath(file)}`);
    }
  }

  if (allLocalFiles.length > 0) {
    logger.info('');
    logger.info(options.dryRun ? 'Files that would be restored:' : 'Restoring user-defined files:');
    for (const file of localAgentsFiles) {
      const target = path.join(path.dirname(file), 'AGENTS.md');
      logger.info(`  ${relativePath(file)} → ${relativePath(target)}`);
    }
    for (const file of localClaudeFiles) {
      const target = path.join(path.dirname(file), 'CLAUDE.md');
      logger.info(`  ${relativePath(file)} → ${relativePath(target)}`);
    }
  }

  logger.info('');
  logger.info(
    `${pc.bold(String(sumFiles.length))} .sum file(s), ` +
    `${pc.bold(String(generatedAgentsFiles.length))} AGENTS.md file(s), ` +
    `${pc.bold(String(generatedClaudeFiles.length))} CLAUDE.md file(s), ` +
    `${pc.bold(String(allLocalFiles.length))} local file(s) to restore`
  );

  if (options.dryRun) {
    logger.info('');
    logger.info(pc.yellow('Dry run — no files were changed.'));
    return;
  }

  // Delete all generated files
  let deleted = 0;
  for (const file of allFiles) {
    try {
      await unlink(file);
      deleted++;
    } catch (err) {
      logger.error(`Failed to delete ${relativePath(file)}: ${(err as Error).message}`);
    }
  }

  // Restore AGENTS.local.md → AGENTS.md and CLAUDE.local.md → CLAUDE.md
  let restored = 0;
  for (const localFile of localAgentsFiles) {
    const agentsPath = path.join(path.dirname(localFile), 'AGENTS.md');
    try {
      await rename(localFile, agentsPath);
      restored++;
    } catch (err) {
      logger.error(`Failed to restore ${relativePath(localFile)}: ${(err as Error).message}`);
    }
  }
  for (const localFile of localClaudeFiles) {
    const claudePath = path.join(path.dirname(localFile), 'CLAUDE.md');
    try {
      await rename(localFile, claudePath);
      restored++;
    } catch (err) {
      logger.error(`Failed to restore ${relativePath(localFile)}: ${(err as Error).message}`);
    }
  }

  logger.info('');
  const parts = [`Deleted ${deleted} file(s)`];
  if (restored > 0) {
    parts.push(`restored ${restored} local file(s)`);
  }
  logger.info(pc.green(`${parts.join(', ')}.`));
}
