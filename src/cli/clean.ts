/**
 * `are clean` command - Delete all generated documentation artifacts
 *
 * Removes .sum files, AGENTS.md files, root documents (CLAUDE.md),
 * and the GENERATION-PLAN.md file.
 */

import path from 'node:path';
import { access, readFile, rename, unlink } from 'node:fs/promises';
import { constants } from 'node:fs';
import fg from 'fast-glob';
import pc from 'picocolors';
import { createLogger } from '../output/logger.js';
import { GENERATED_MARKER } from '../generation/writers/agents-md.js';

/**
 * Options for the clean command.
 */
export interface CleanOptions {
  /**
   * Show files that would be deleted without deleting them.
   * @default false
   */
  dryRun: boolean;
}

/**
 * Execute the `are clean` command.
 *
 * Finds and deletes all generated documentation artifacts:
 * - `*.sum` files
 * - `AGENTS.md` files
 * - `CLAUDE.md` at project root
 * - `.agents-reverse-engineer/GENERATION-PLAN.md`
 *
 * @param targetPath - Project root directory (defaults to current working directory)
 * @param options - Command options
 */
export async function cleanCommand(
  targetPath: string,
  options: CleanOptions
): Promise<void> {
  const resolvedPath = path.resolve(targetPath || process.cwd());

  const logger = createLogger({ colors: true });

  // Verify target path exists
  try {
    await access(resolvedPath, constants.R_OK);
  } catch (err) {
    const error = err as NodeJS.ErrnoException;
    if (error.code === 'ENOENT') {
      logger.error(`Directory not found: ${resolvedPath}`);
      process.exit(1);
    }
    if (error.code === 'EACCES' || error.code === 'EPERM') {
      logger.error(`Permission denied: ${resolvedPath}`);
      process.exit(1);
    }
    throw error;
  }

  // Find all artifacts
  const [sumFiles, annexFiles, agentsFiles, localAgentsFiles] = await Promise.all([
    fg.glob('**/*.sum', {
      cwd: resolvedPath,
      absolute: true,
      onlyFiles: true,
      dot: true,
      ignore: ['**/node_modules/**', '**/.git/**'],
    }),
    fg.glob('**/*.annex.md', {
      cwd: resolvedPath,
      absolute: true,
      onlyFiles: true,
      dot: true,
      ignore: ['**/node_modules/**', '**/.git/**'],
    }),
    fg.glob('**/AGENTS.md', {
      cwd: resolvedPath,
      absolute: true,
      onlyFiles: true,
      dot: true,
      ignore: ['**/node_modules/**', '**/.git/**'],
    }),
    fg.glob('**/AGENTS.local.md', {
      cwd: resolvedPath,
      absolute: true,
      onlyFiles: true,
      dot: true,
      ignore: ['**/node_modules/**', '**/.git/**'],
    }),
  ]);

  // Filter AGENTS.md to only those generated by ARE (contain the marker).
  // User-authored AGENTS.md files (e.g. SDK docs) must not be deleted.
  const generatedAgentsFiles: string[] = [];
  const skippedAgentsFiles: string[] = [];
  for (const file of agentsFiles) {
    try {
      const content = await readFile(file, 'utf-8');
      if (content.includes(GENERATED_MARKER)) {
        generatedAgentsFiles.push(file);
      } else {
        skippedAgentsFiles.push(file);
      }
    } catch {
      // Can't read — skip silently
    }
  }

  // Check for root docs and plan file
  const singleFiles: string[] = [];
  const claudeMd = path.join(resolvedPath, 'CLAUDE.md');
  const planFile = path.join(resolvedPath, '.agents-reverse-engineer', 'GENERATION-PLAN.md');

  for (const filePath of [claudeMd, planFile]) {
    try {
      await access(filePath, constants.F_OK);
      singleFiles.push(filePath);
    } catch {
      // File doesn't exist - skip
    }
  }

  const allFiles = [...sumFiles, ...annexFiles, ...generatedAgentsFiles, ...singleFiles];

  if (allFiles.length === 0 && localAgentsFiles.length === 0) {
    logger.info('No generated artifacts found.');
    return;
  }

  // Display found files
  const relativePath = (absPath: string): string =>
    path.relative(resolvedPath, absPath);

  if (options.dryRun) {
    logger.info('Files that would be deleted:');
  }

  for (const file of allFiles) {
    logger.info(`  ${relativePath(file)}`);
  }

  if (skippedAgentsFiles.length > 0) {
    logger.info('');
    logger.info('Preserving user-authored AGENTS.md:');
    for (const file of skippedAgentsFiles) {
      logger.info(`  ${relativePath(file)}`);
    }
  }

  if (localAgentsFiles.length > 0) {
    logger.info('');
    logger.info(options.dryRun ? 'Files that would be restored:' : 'Restoring user-defined files:');
    for (const file of localAgentsFiles) {
      const target = path.join(path.dirname(file), 'AGENTS.md');
      logger.info(`  ${relativePath(file)} → ${relativePath(target)}`);
    }
  }

  logger.info('');
  logger.info(
    `${pc.bold(String(sumFiles.length))} .sum file(s), ` +
    `${pc.bold(String(annexFiles.length))} .annex.md file(s), ` +
    `${pc.bold(String(generatedAgentsFiles.length))} AGENTS.md file(s), ` +
    `${pc.bold(String(singleFiles.length))} root doc(s), ` +
    `${pc.bold(String(localAgentsFiles.length))} AGENTS.local.md to restore`
  );

  if (options.dryRun) {
    logger.info('');
    logger.info(pc.yellow('Dry run — no files were changed.'));
    return;
  }

  // Delete all generated files
  let deleted = 0;
  for (const file of allFiles) {
    try {
      await unlink(file);
      deleted++;
    } catch (err) {
      logger.error(`Failed to delete ${relativePath(file)}: ${(err as Error).message}`);
    }
  }

  // Restore AGENTS.local.md → AGENTS.md (undo the rename from generation)
  let restored = 0;
  for (const localFile of localAgentsFiles) {
    const agentsPath = path.join(path.dirname(localFile), 'AGENTS.md');
    try {
      await rename(localFile, agentsPath);
      restored++;
    } catch (err) {
      logger.error(`Failed to restore ${relativePath(localFile)}: ${(err as Error).message}`);
    }
  }

  logger.info('');
  const parts = [`Deleted ${deleted} file(s)`];
  if (restored > 0) {
    parts.push(`restored ${restored} AGENTS.local.md file(s)`);
  }
  logger.info(pc.green(`${parts.join(', ')}.`));
}
