---
generated_at: 2026-02-09T15:06:59.303Z
content_hash: 787eac676eca6402f9981c174edd6821e9ff2bae0ed51b3970dc7018800513b7
purpose: generateCommand orchestrates three-phase AI-driven documentation generation: discovers files, resolves AI backend, ex...
---
**generateCommand orchestrates three-phase AI-driven documentation generation: discovers files, resolves AI backend, executes concurrent file analysis via CommandRunner producing .sum files, then synthesizes AGENTS.md per directory and root documents (CLAUDE.md, GEMINI.md, OPENCODE.md).**

## Exported Interface

**generateCommand(targetPath: string, options: GenerateOptions): Promise<void>**
- Main entry point resolving absolutePath via `path.resolve(targetPath)`
- Loads config via `loadConfig(absolutePath, { tracer, debug })`
- Discovers files via `discoverFiles(absolutePath, config, { tracer, debug })`
- Creates GenerationPlan via `createOrchestrator(config, absolutePath, { tracer, debug }).createPlan(discoveryResult)`
- Resolves AI backend via `resolveBackend(createBackendRegistry(), config.ai.backend)`
- Builds ExecutionPlan via `buildExecutionPlan(plan, absolutePath)`
- Executes via `CommandRunner.executeGenerate(executionPlan)` with concurrency from `options.concurrency ?? config.ai.concurrency`
- Writes telemetry via `aiService.finalize(absolutePath)`
- Cleans old traces via `cleanupOldTraces(absolutePath)` when `options.trace` enabled
- Exit codes: 0 (all succeeded), 1 (partial failure), 2 (total failure)

**GenerateOptions interface**
- `dryRun?: boolean` — shows execution plan via `buildExecutionPlan()` without AI calls
- `concurrency?: number` — overrides `config.ai.concurrency` for worker pool size
- `failFast?: boolean` — passed to CommandRunner to abort on first failure
- `debug?: boolean` — enables `aiService.setDebug(true)` for subprocess logging
- `trace?: boolean` — enables NDJSON trace output via `createTraceWriter(absolutePath, true)`

**formatPlan(plan: GenerationPlan): string**
- Formats GenerationPlan summary displaying `plan.files.length`, `plan.tasks.length`, `plan.complexity.fileCount`, `plan.complexity.directoryDepth`

## Core Dependencies

**Config & Discovery:**
- `loadConfig(absolutePath, { tracer, debug })` from `../config/loader.js` returns validated Config schema
- `discoverFiles(absolutePath, config, { tracer, debug })` from `../discovery/run.js` returns FilterResult with `included` and `excluded` arrays
- Maps FilterResult to DiscoveryResult format via `{ files: filterResult.included, excluded: filterResult.excluded.map(e => ({ path: e.path, reason: e.reason })) }`

**AI Backend Resolution:**
- `createBackendRegistry()` from `../ai/index.js` returns BackendRegistry with Claude/Gemini/OpenCode adapters
- `resolveBackend(registry, config.ai.backend)` throws AIServiceError with `code: 'CLI_NOT_FOUND'` when no backend available
- `getInstallInstructions(registry)` returns formatted installation guide for all backends
- `AIService(backend, { timeoutMs, maxRetries, model, telemetry })` wraps subprocess execution with retry logic

**Execution Pipeline:**
- `createOrchestrator(config, absolutePath, { tracer, debug })` from `../generation/orchestrator.js` returns Orchestrator instance
- `buildExecutionPlan(plan, absolutePath)` from `../generation/executor.js` returns ExecutionPlan with `fileTasks`, `directoryTasks`, `rootTasks`, `directoryFileMap`
- `CommandRunner(aiService, { concurrency, failFast, debug, tracer, progressLog })` from `../orchestration/index.js` executes three-phase pipeline
- `runner.executeGenerate(executionPlan)` returns RunSummary with `filesProcessed`, `filesFailed`, `directoriesProcessed`, `rootDocsGenerated`

**Telemetry & Tracing:**
- `createTraceWriter(absolutePath, options.trace ?? false)` from `../orchestration/index.js` returns ITraceWriter (NullTraceWriter or TraceWriter)
- `tracer.filePath` available when trace enabled for console display
- `ProgressLog.create(absolutePath)` from `../orchestration/index.js` creates streamable `.agents-reverse-engineer/progress.log`
- `progressLog.write(message)` appends timestamped lines for `tail -f` monitoring
- `aiService.setSubprocessLogDir(logDir)` enables per-subprocess stdout/stderr capture to `.agents-reverse-engineer/subprocess-logs/<timestamp>/`
- `aiService.finalize(absolutePath)` writes run log to `.agents-reverse-engineer/logs/run-<timestamp>.json`
- `cleanupOldTraces(absolutePath)` from `../orchestration/index.js` enforces 500-trace retention limit

## Dry-Run Mode

When `options.dryRun` is true:
- Calls `buildExecutionPlan(plan, absolutePath)` to compute task counts
- Extracts directory count via `Object.keys(executionPlan.directoryFileMap).length`
- Displays summary with `executionPlan.fileTasks.length`, `executionPlan.directoryTasks.length`, `executionPlan.rootTasks.length`, `executionPlan.tasks.length`
- Iterates `executionPlan.fileTasks` to display file paths
- Returns early without calling `resolveBackend()` or creating CommandRunner

## Exit Code Strategy

Exit code determined from RunSummary:
- `summary.filesProcessed === 0 && summary.filesFailed > 0` → exit code 2 (total failure)
- `summary.filesFailed > 0` → exit code 1 (partial failure)
- Default → exit code 0 (all succeeded or no files to process)

## Debug Output

When `options.debug` is true:
- Logs backend name via `backend.name`
- Logs CLI command via `backend.cliCommand`
- Logs model via `config.ai.model`
- Calls `aiService.setDebug(true)` to enable subprocess heap/RSS metrics
- Passed to `loadConfig()`, `discoverFiles()`, `createOrchestrator()`, CommandRunner for verbose logging

## Trace Integration

Tracer created early (before config loading) and threaded through:
- `loadConfig(absolutePath, { tracer, debug })`
- `discoverFiles(absolutePath, config, { tracer, debug })`
- `createOrchestrator(config, absolutePath, { tracer, debug })`
- `CommandRunner(aiService, { concurrency, failFast, debug, tracer, progressLog })`

Trace file path displayed via `console.error(pc.dim('[trace] Writing to ${tracer.filePath}'))` when enabled.

Subprocess logs routed to timestamped directory: `.agents-reverse-engineer/subprocess-logs/<ISO-timestamp>/` via `aiService.setSubprocessLogDir(logDir)`.

## Progress Monitoring

ProgressLog initialized with banner:
```
=== ARE Generate (<ISO-timestamp>) ===
Project: <absolutePath>
Files: <fileCount> | Directories: <dirCount>
```

Real-time monitoring via `tail -f .agents-reverse-engineer/progress.log`.

Finalized after runner completes via `progressLog.finalize()`.