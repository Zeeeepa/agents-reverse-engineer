<!-- Generated by agents-reverse-engineer -->

# src/ai

**Backend-agnostic AI CLI orchestration layer implementing subprocess pooling, exponential backoff retry, token cost telemetry with NDJSON persistence, and trace emission for concurrency debugging.**

## Contents

**[index.ts](./index.ts)** — Public API barrel exporting `AIService`, `AIBackend`, `AIResponse`, `AICallOptions`, `SubprocessResult`, `RetryOptions`, `TelemetryEntry`, `RunLog`, `FileRead`, `AIServiceError` from types, `BackendRegistry`, `createBackendRegistry()`, `resolveBackend()`, `detectBackend()`, `getInstallInstructions()` from registry, `withRetry()`, `DEFAULT_RETRY_OPTIONS` from retry, `runSubprocess()`, `isCommandOnPath()` from subprocess/backends.

**[registry.ts](./registry.ts)** — `BackendRegistry` stores AIBackend instances by name with insertion-order priority (Claude → Gemini → OpenCode), `createBackendRegistry()` pre-populates with backend adapters, `detectBackend()` returns first available via `backend.isAvailable()` iteration, `resolveBackend()` handles explicit names and 'auto' mode throwing `AIServiceError` with `CLI_NOT_FOUND` code and aggregated install instructions on miss.

**[retry.ts](./retry.ts)** — `withRetry<T>()` executes async operations with exponential backoff via `baseDelayMs * multiplier^attempt` capped at `maxDelayMs` plus 0-500ms jitter, terminates immediately on non-retryable errors via `isRetryable()` predicate, invokes `onRetry()` callback before each attempt, throws last error after exhausting `maxRetries`, `DEFAULT_RETRY_OPTIONS` defines 3 retries with 1s base delay, 8s max delay, 2x multiplier.

**[service.ts](./service.ts)** — `AIService` orchestrates AI calls via `call()` wrapping `runSubprocess()` with `withRetry()`, detects rate limits via stderr patterns ("rate limit", "429", "too many requests", "overloaded"), refuses to retry timeouts (inline comment: "spawning another heavyweight subprocess on a struggling system makes things worse"), emits `subprocess:spawn/exit` and `retry` trace events, accumulates `TelemetryEntry` records via `TelemetryLogger`, serializes writes to subprocess log files via promise-chain queue, exposes `finalize()` for `RunLog` persistence and retention enforcement via `cleanupOldLogs()`, tracks active subprocesses for debug logging with heap/RSS metrics.

**[subprocess.ts](./subprocess.ts)** — `runSubprocess()` spawns CLI via `execFile()` with 10MB `maxBuffer`, SIGTERM timeout via `killSignal`, stdin piping for prompt delivery, unref'd SIGKILL escalation timer at `timeoutMs + 5000ms`, process group termination via `kill(-pid, 'SIGKILL')` on completion, module-level `activeSubprocesses` Map tracking PIDs with spawn timestamps, exposes `getActiveSubprocessCount()` and `getActiveSubprocesses()` for concurrency debugging, never throws (always resolves `SubprocessResult`).

**[types.ts](./types.ts)** — Defines `AIBackend` interface with `isAvailable()`, `buildArgs()`, `parseResponse()`, `getInstallInstructions()` methods, `AICallOptions` with `prompt`, optional `systemPrompt/model/timeoutMs/maxTurns/taskLabel`, `AIResponse` with normalized `text/model/inputTokens/outputTokens/cacheReadTokens/cacheCreationTokens/durationMs/exitCode/raw`, `SubprocessResult` with `stdout/stderr/exitCode/signal/durationMs/timedOut/childPid`, `RetryOptions` with exponential backoff config and predicates, `TelemetryEntry` per-call log with token counts and file reads, `RunLog` aggregate summary, `AIServiceError` with typed codes `CLI_NOT_FOUND/TIMEOUT/PARSE_ERROR/SUBPROCESS_ERROR/RATE_LIMIT`, `FileRead` with path/sizeBytes.

## Architecture

**Three-Layer Abstraction**

1. **Subprocess Layer** (`subprocess.ts`): Raw `execFile()` wrapper with timeout enforcement, process group killing, stdin piping, active subprocess tracking. Returns `SubprocessResult` on all code paths (never throws).

2. **Retry Layer** (`retry.ts`): Generic exponential backoff with jitter, caller-provided `isRetryable()` predicate, optional `onRetry()` callback. Terminates immediately on permanent errors.

3. **Service Layer** (`service.ts`): Integrates subprocess + retry + telemetry + tracing. Detects rate limits via stderr patterns, refuses to retry timeouts, accumulates token counts, emits trace events for concurrency debugging, serializes subprocess log writes via promise chain.

**Backend Registry**

`BackendRegistry` stores `AIBackend` instances with insertion-order priority determining auto-detection sequence. `createBackendRegistry()` registers ClaudeBackend, GeminiBackend, OpenCodeBackend in priority order. `resolveBackend()` handles two modes: explicit name lookups with availability validation, 'auto' mode calling `detectBackend()` which iterates backends invoking `isAvailable()` until first match. Throws `AIServiceError` with `CLI_NOT_FOUND` code and aggregated install instructions on failure.

**Retry Strategy**

Rate limit detection via `isRateLimitStderr()` checking lowercase stderr for patterns: "rate limit", "429", "too many requests", "overloaded". Only rate limit errors are retryable—timeouts are permanent failures (inline rationale: "spawning another heavyweight subprocess on a system that's already struggling or against an unresponsive API makes things worse and can exhaust system resources"). `withRetry()` invoked with custom predicate: `error instanceof AIServiceError && error.code === 'RATE_LIMIT'`.

**Telemetry Pipeline**

`TelemetryLogger` accumulates `TelemetryEntry` records in memory via `addEntry()` calls after each subprocess completion. Each entry captures `timestamp`, `prompt`, `systemPrompt`, `response`, `model`, token counts (`inputTokens`, `outputTokens`, `cacheReadTokens`, `cacheCreationTokens`), `latencyMs`, `exitCode`, `retryCount`, `filesRead[]` array. Command orchestrator calls `addFilesReadToLastEntry()` post-execution to attach file metadata (`path`, `sizeBytes`, `linesRead`). `finalize()` invokes `logger.toRunLog()` producing aggregate `RunLog` with summary (`totalCalls`, `totalInputTokens`, `totalDurationMs`, `errorCount`, `uniqueFilesRead` via Set deduplication), then serializes via `writeRunLog()` to `.agents-reverse-engineer/logs/run-<timestamp>.json`, enforces retention via `cleanupOldLogs(keepCount)`.

**Trace Emission**

`AIService` accepts optional `ITraceWriter` via `setTracer()` for concurrency debugging. Emits three event types: `subprocess:spawn` with `childPid/taskLabel/timestamp`, `subprocess:exit` with `childPid/exitCode/signal/durationMs/timedOut`, `retry` with `attempt/taskLabel/errorCode`. Trace writer (from `src/orchestration/trace.ts`) serializes events to `.agents-reverse-engineer/traces/trace-<timestamp>.ndjson` via promise-chain serialization ensuring write order matches emission order despite concurrent workers.

**Subprocess Resource Management**

`runSubprocess()` tracks active subprocesses in module-level Map with PID → `{ command, spawnedAt }` mapping. Exposes `getActiveSubprocessCount()` and `getActiveSubprocesses()` for debugging. `AIService.call()` increments `activeSubprocesses` counter before spawn, decrements after completion, logs pre-spawn debug message with active count, heap usage, RSS via `process.memoryUsage()`, and configured timeout. Post-completion debug log includes PID, exit code, duration, updated active count.

**Process Lifecycle**

`runSubprocess()` sequence: spawn with 10MB `maxBuffer` and SIGTERM `killSignal`, track in `activeSubprocesses` Map, invoke `onSpawn()` callback synchronously for trace emission, write `options.input` to stdin then `.end()` to close stream, set unref'd SIGKILL escalation timer at `timeoutMs + 5000ms`, on callback clear timer, attempt process group kill via `kill(-pid, 'SIGKILL')` with single-process fallback, remove from `activeSubprocesses`, resolve with `SubprocessResult`. Timeout detection via `error.killed === true` from execFile. Exit code extracted from `error.code` (if number) else `child.exitCode` else defaults to 1 (failure) or 0 (success).

## Behavioral Contracts

**Rate Limit Patterns** (service.ts `RATE_LIMIT_PATTERNS`):
```javascript
["rate limit", "429", "too many requests", "overloaded"]
```

**Exponential Backoff Formula** (retry.ts):
```typescript
min(baseDelayMs * multiplier^attempt, maxDelayMs) + Math.random() * 500
```

**Default Retry Configuration** (retry.ts `DEFAULT_RETRY_OPTIONS`):
```typescript
{ maxRetries: 3, baseDelayMs: 1000, maxDelayMs: 8000, multiplier: 2 }
```

**Subprocess Timeout** (subprocess.ts):
- SIGTERM sent at `timeoutMs` via execFile `killSignal` option
- SIGKILL escalation at `timeoutMs + 5000ms` via unref'd timer

**Process Group Termination** (subprocess.ts):
```javascript
process.kill(-child.pid, 'SIGKILL')  // Negative PID targets process group
```

**Debug Memory Formatting** (service.ts `formatBytes()`):
- `< 1024` → `${bytes}B`
- `< 1048576` → `${(bytes / 1024).toFixed(1)}KB`
- `≥ 1048576` → `${(bytes / 1048576).toFixed(1)}MB`

**Telemetry Filename Format** (telemetry/run-log.ts):
```typescript
`run-${runLog.startTime.replace(/[:.]/g, '-')}.json`
// "2026-02-09T12:34:56.789Z" → "run-2026-02-09T12-34-56-789Z.json"
```

**Subprocess Log Filename Sanitization** (service.ts):
```typescript
taskLabel.replace(/\//g, '--').replace(/[^a-zA-Z0-9._-]/g, '_')
```

## Subdirectories

**[backends/](./backends/)** — ClaudeBackend with Zod-validated JSON parsing extracting token counts from usage/modelUsage objects, GeminiBackend/OpenCodeBackend stubs throwing `SUBPROCESS_ERROR` until output formats stabilize, shared `isCommandOnPath()` splitting `process.env.PATH` by platform delimiter with Windows `PATHEXT` iteration, CLI arguments with stdin prompt delivery and platform-specific flags (`--output-format json`, `--permission-mode bypassPermissions`).

**[telemetry/](./telemetry/)** — `TelemetryLogger` accumulating `TelemetryEntry` records in memory with `addEntry()` and `getSummary()` computing token sums/error counts/unique file deduplication, `writeRunLog()` serializing `RunLog` to `.agents-reverse-engineer/logs/run-<timestamp>.json` with ISO timestamp transformation, `cleanupOldLogs()` deleting oldest files beyond retention threshold via lexicographic sort.

## Integration Points

**Upstream Consumers:**
- `src/orchestration/runner.ts` — Instantiates AIService with resolved backend and config options, invokes `call()` per task, attaches file reads via `addFilesReadToLastEntry()`, finalizes telemetry via `finalize()`.
- `src/generation/orchestrator.ts` — Threads AIService through three-phase pipeline (file analysis, directory aggregation, root synthesis).

**Downstream Dependencies:**
- `src/orchestration/trace.ts` — `ITraceWriter` interface for trace event emission.
- `src/config/schema.ts` — `AIConfig` with backend selection, timeout, concurrency, telemetry retention.
- `node:child_process` — `execFile()` for subprocess spawning.
- `node:fs/promises` — File I/O for subprocess logs and telemetry persistence.