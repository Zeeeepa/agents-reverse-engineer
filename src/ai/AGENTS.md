<!-- Generated by agents-reverse-engineer -->

# src/ai

AI service layer for subprocess-based AI CLI interaction, providing backend abstraction, retry logic, timeout enforcement, telemetry recording, and trace event emission.

## Contents

### [types.ts](./types.ts)
Defines contract layer: `SubprocessResult` (stdout/stderr/exitCode/durationMs/timedOut/signal/childPid), `AICallOptions` (prompt/systemPrompt/model/timeoutMs/maxTurns/taskLabel), `AIResponse` (text/model/tokens/durationMs/exitCode/raw), `AIBackend` interface (name/cliCommand/isAvailable/buildArgs/parseResponse/getInstallInstructions), `RetryOptions` (maxRetries/baseDelayMs/maxDelayMs/multiplier/isRetryable/onRetry), `FileRead` (path/sizeBytes), `TelemetryEntry` (timestamp/prompt/response/tokens/latency/exitCode/error/retryCount/thinking/filesRead), `RunLog` (runId/startTime/endTime/entries/summary), `AIServiceError` (code/message), `AIServiceErrorCode` union (`CLI_NOT_FOUND`/`TIMEOUT`/`PARSE_ERROR`/`SUBPROCESS_ERROR`/`RATE_LIMIT`).

### [subprocess.ts](./subprocess.ts)
Exports `runSubprocess(command, args, options)` spawning CLI child processes via `execFile()`, enforces timeout with SIGTERM→SIGKILL escalation after `SIGKILL_GRACE_MS` (5000ms), pipes stdin with EOF signaling (see RESEARCH.md Pitfall 1), tracks active subprocesses in Map for `getActiveSubprocessCount()` and `getActiveSubprocesses()`, invokes `onSpawn(pid)` callback at spawn time for trace emission, resolves with `SubprocessResult` including childPid, never rejects.

### [retry.ts](./retry.ts)
Exports `withRetry(fn, options)` applying exponential backoff with jitter: `min(baseDelayMs * multiplier^attempt, maxDelayMs) + Math.random() * 500`, throws immediately if `isRetryable(error)` returns false, calls `onRetry(attempt, error)` before each retry. Exports `DEFAULT_RETRY_OPTIONS` partial (`maxRetries: 3`, `baseDelayMs: 1000`, `maxDelayMs: 8000`, `multiplier: 2`) requiring caller-supplied `isRetryable`/`onRetry`.

### [service.ts](./service.ts)
`AIService` class orchestrates AI calls: constructor takes `AIBackend` and `AIServiceOptions` (timeoutMs/maxRetries/model/telemetry.keepRuns), delegates CLI argument construction to `backend.buildArgs()` and response parsing to `backend.parseResponse()`, wraps `runSubprocess()` in `withRetry()` retrying only `RATE_LIMIT` errors (stderr patterns: `['rate limit', '429', 'too many requests', 'overloaded']`), emits trace events (`subprocess:spawn`/`subprocess:exit`/`retry`) via `setTracer()`, records `TelemetryEntry` via internal `TelemetryLogger`, logs subprocess output to `.log` files when `subprocessLogDir` is set (serialized via promise chain), throws `AIServiceError` for TIMEOUT/PARSE_ERROR/SUBPROCESS_ERROR. `finalize()` writes run log via `writeRunLog()`, calls `cleanupOldLogs()`, returns log path and summary. Debug mode logs memory usage and subprocess lifecycle to stderr.

### [registry.ts](./registry.ts)
`BackendRegistry` stores `AIBackend` instances in insertion-order Map. `createBackendRegistry()` registers `ClaudeBackend`, `GeminiBackend`, `OpenCodeBackend` in priority order for auto-detection. `detectBackend(registry)` iterates `getAll()` calling `backend.isAvailable()`, returns first available or null. `resolveBackend(registry, requested)` handles `'auto'` mode via `detectBackend()` or explicit backend name via `registry.get()`, throws `AIServiceError` with code `CLI_NOT_FOUND` and formatted install instructions from `getInstallInstructions()` if unavailable.

### [index.ts](./index.ts)
Barrel export enforcing encapsulation: re-exports `AIBackend`, `AIResponse`, `AICallOptions`, `SubprocessResult`, `RetryOptions`, `TelemetryEntry`, `RunLog`, `FileRead` from `./types.js`, `AIServiceOptions`, `AIService` from `./service.js`, `AIServiceError` from `./types.js`, `BackendRegistry`, `createBackendRegistry`, `resolveBackend`, `detectBackend`, `getInstallInstructions` from `./registry.js`, `withRetry`, `DEFAULT_RETRY_OPTIONS` from `./retry.js`, `runSubprocess` from `./subprocess.js`, `isCommandOnPath` from `./backends/claude.js`. Documentation explicitly states "No other module should reach into `src/ai/backends/` or `src/ai/telemetry/` directly".

## Subdirectories

### [backends/](./backends/)
AI CLI adapters implementing `AIBackend` interface: `ClaudeBackend` (fully implemented with JSON/NDJSON parsing, Zod validation via `ClaudeResponseSchema`), `GeminiBackend` (stub throwing `SUBPROCESS_ERROR` "not yet implemented"), `OpenCodeBackend` (stub throwing `SUBPROCESS_ERROR` "not yet implemented"). Registered in `registry.ts` for runtime selection.

### [telemetry/](./telemetry/)
In-memory `TelemetryLogger` (accumulates `TelemetryEntry`, computes summary via `getSummary()`, produces `RunLog` via `toRunLog()`), persistent run log writer `writeRunLog()` (serializes to `.agents-reverse-engineer/logs/run-{sanitizedTimestamp}.json`), log retention `cleanupOldLogs()` (deletes all but N most recent `run-*.json` files).

## Architecture

Three-layer design: subprocess management (`subprocess.ts`) provides timeout-enforced child process execution with SIGTERM/SIGKILL escalation, backend abstraction (`backends/*.ts` + `registry.ts`) normalizes CLI-specific argument construction and response parsing, orchestration (`service.ts`) combines subprocess execution with retry logic (exponential backoff for rate limits), telemetry recording (per-call tokens/latency/errors), and trace event emission. Service layer delegates to backend `buildArgs()` for CLI arguments, wraps `runSubprocess()` in `withRetry()`, parses output via backend `parseResponse()`, emits `subprocess:spawn`/`subprocess:exit`/`retry` trace events, records telemetry entries, optionally writes subprocess logs to disk (serialized via promise chain), and finalizes with persistent run log + cleanup.

## Behavioral Contracts

**Rate Limit Patterns** (service.ts):  
`['rate limit', '429', 'too many requests', 'overloaded']` (case-insensitive stderr matching)

**SIGKILL Grace Period** (subprocess.ts):  
`SIGKILL_GRACE_MS = 5000` (milliseconds after SIGTERM before force-kill)

**Exponential Backoff Formula** (retry.ts):  
`min(baseDelayMs * multiplier^attempt, maxDelayMs) + jitter` where `jitter ∈ [0, 500]` ms

**Subprocess Log Format** (service.ts):  
```
task:      ${taskLabel}
pid:       ${childPid}
command:   ${backend.cliCommand}
exit:      ${exitCode}
signal:    ${signal}
duration:  ${durationMs}ms
timed_out: ${timedOut}

--- stdout ---
${stdout}

--- stderr ---
${stderr}
```

**Subprocess Log Filename Sanitization** (service.ts):  
`/\//g` → `'--'`, `/[^a-zA-Z0-9._-]/g` → `'_'`, format: `${sanitizedLabel}_pid${childPid}.log`

**Active Subprocess Count**: Tracked via Map keyed by PID, incremented before spawn, decremented after exit, queryable via `getActiveSubprocessCount()` and `getActiveSubprocesses()`.

**Error Code Classification**:
- `CLI_NOT_FOUND`: Backend unavailable (PATH check fails or registry.get() returns undefined)
- `TIMEOUT`: Subprocess exceeded timeoutMs (detected via `result.timedOut`)
- `RATE_LIMIT`: Non-zero exit + stderr matches rate limit patterns (retryable)
- `SUBPROCESS_ERROR`: Non-zero exit without rate limit stderr (not retryable)
- `PARSE_ERROR`: Response parsing failed (Zod validation or JSON.parse error)

**Debug Output Format** (service.ts):  
```
[debug] Spawning subprocess for "${taskLabel}" (active: ${activeSubprocesses}, heapUsed: ${formatBytes(mem.heapUsed)}, rss: ${formatBytes(mem.rss)}, timeout: ${(timeoutMs / 1000).toFixed(0)}s)
[debug] Subprocess exited for "${taskLabel}" (PID ${childPid}, exitCode: ${exitCode}, duration: ${(durationMs / 1000).toFixed(1)}s, active: ${activeSubprocesses})
[warn] Subprocess timed out after ${(durationMs / 1000).toFixed(1)}s for "${taskLabel}" (PID ${childPid}, timeout was ${(timeoutMs / 1000).toFixed(0)}s)
[warn] Retrying "${taskLabel}" (attempt ${attempt}/${maxRetries}, reason: ${errorCode})
```

## File Relationships

`AIService.call()` invokes `backend.buildArgs()` for CLI arguments, wraps `runSubprocess()` in `withRetry()`, parses output via `backend.parseResponse()`, emits trace events via `tracer`, records telemetry via internal `TelemetryLogger`, enqueues subprocess log writes (serialized promise chain), throws `AIServiceError` on failures. `finalize()` invokes `telemetry/run-log.ts` `writeRunLog()` and `telemetry/cleanup.ts` `cleanupOldLogs()`. `registry.ts` holds backend instances, `detectBackend()` iterates calling `backend.isAvailable()` from `backends/*.ts`. Subprocess tracking in `subprocess.ts` populates `activeSubprocesses` Map queried by service debug logging. Consumed by `src/orchestration/runner.ts` which instantiates `AIService`, calls `setTracer()`, and delegates file analysis tasks.