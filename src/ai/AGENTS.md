<!-- Generated by agents-reverse-engineer v0.8.2 -->

# src/ai

AI service orchestration layer: subprocess spawning (`claude`/`gemini`/`opencode` CLI tools), exponential backoff retry (rate-limit only), timeout enforcement (SIGTERM → SIGKILL escalation), backend auto-detection (PATH scanning), telemetry accumulation (TelemetryEntry → RunLog JSON), trace emission (NDJSON events), and provider abstraction (AIProvider interface decoupling transport from business logic).

## Contents

**[index.ts](./index.ts)** — Barrel export consolidating public API: `AIService` orchestrator, `BackendRegistry` factory, `createBackendRegistry()`, `resolveBackend()`, `detectBackend()`, `withRetry()`, `runSubprocess()`, `SubprocessProvider`, `isCommandOnPath()`, `DEFAULT_RETRY_OPTIONS`, `getInstallInstructions()`. Re-exports types: `AIProvider`, `AIBackend`, `AIResponse`, `AICallOptions`, `SubprocessResult`, `RetryOptions`, `TelemetryEntry`, `RunLog`, `FileRead`, `AIServiceError`, `AIServiceOptions`.

**[registry.ts](./registry.ts)** — `BackendRegistry` class indexes `AIBackend` instances by `name` in insertion-order Map with `register()`, `get()`, `getAll()`. `createBackendRegistry()` pre-populates `ClaudeBackend`, `GeminiBackend`, `OpenCodeBackend` in auto-detection priority. `detectBackend(registry)` iterates `registry.getAll()` calling `backend.isAvailable()`, returns first available or `null`. `resolveBackend(registry, requested)` auto-detects via `detectBackend()` when `requested === 'auto'`, validates explicit backend name via `registry.get()` + `isAvailable()` check, throws `AIServiceError('CLI_NOT_FOUND')` with aggregated `getInstallInstructions()` on failure.

**[retry.ts](./retry.ts)** — `withRetry<T>(fn, options)` executes async function with exponential backoff: `delay = min(baseDelayMs * multiplier^attempt, maxDelayMs) + random(0-500ms)`, attempts up to `maxRetries + 1`, calls `onRetry(attempt, error)` before each wait, throws immediately if `isRetryable(error) === false` or retries exhausted. `DEFAULT_RETRY_OPTIONS`: `{ maxRetries: 3, baseDelayMs: 1000, maxDelayMs: 8000, multiplier: 2 }`.

**[service.ts](./service.ts)** — `AIService` wraps `AIProvider | AIBackend` with retry/telemetry/tracing. Constructor auto-wraps `AIBackend` in `SubprocessProvider` via `isAIBackend()` type guard. `call(options)` wraps `provider.call()` in `withRetry()` configured with `isRetryable: (err) => err.code === 'RATE_LIMIT'` (timeouts NOT retried), records `TelemetryEntry` via `logger.addEntry()` with `timestamp`, `prompt`, `systemPrompt`, `response`, `model`, `inputTokens`, `outputTokens`, `cacheReadTokens`, `cacheCreationTokens`, `latencyMs`, `exitCode`, `retryCount`, `thinking: 'not supported'`, `filesRead: []`, emits `{type: 'retry', attempt, taskLabel, errorCode}` trace events on retries. `finalize(projectRoot)` writes `writeRunLog()`, calls `cleanupOldLogs(projectRoot, keepRuns)`, returns log path and summary. `setTracer(tracer)` forwards to `SubprocessProvider.setTracer()`, `setDebug(enabled)` controls verbose subprocess logging, `setSubprocessLogDir(dir)` enables per-subprocess `.log` files, `addFilesReadToLastEntry(filesRead)` mutates most recent telemetry entry, `getSummary()` returns current telemetry snapshot without finalizing.

**[subprocess.ts](./subprocess.ts)** — `runSubprocess(command, args, options)` spawns CLI subprocess via `execFile()`, pipes `options.input` to stdin then calls `.end()`, enforces `options.timeoutMs` via `timeout` option (SIGTERM), schedules SIGKILL escalation at `timeoutMs + SIGKILL_GRACE_MS` (5000ms) with process group kill pattern `process.kill(-childPid, 'SIGKILL')`, invokes `options.onSpawn?.(pid)` synchronously after spawn, tracks active subprocesses in Map, returns `SubprocessResult` with `stdout`, `stderr`, `exitCode`, `signal`, `durationMs`, `timedOut`, `childPid`. Always resolves (never rejects). `getActiveSubprocessCount()` / `getActiveSubprocesses()` expose concurrency introspection. Exit code priority: `error === null ? 0 : typeof error.code === 'number' ? error.code : child.exitCode ?? 1`.

**[types.ts](./types.ts)** — Type definitions: `SubprocessResult` (CLI execution outcome: `stdout`, `stderr`, `exitCode`, `signal`, `durationMs`, `timedOut`, `childPid`), `AICallOptions` (call parameters: `prompt`, `systemPrompt`, `model`, `timeoutMs`, `maxTurns`, `taskLabel`), `AIResponse` (normalized output: `text`, `model`, `inputTokens`, `outputTokens`, `cacheReadTokens`, `cacheCreationTokens`, `durationMs`, `exitCode`, `raw`), `AIProvider` (transport abstraction: `call(options): Promise<AIResponse>`), `AIBackend` (CLI adapter contract: `name`, `cliCommand`, `isAvailable()`, `buildArgs()`, `parseResponse()`, `getInstallInstructions()`), `RetryOptions` (exponential backoff: `maxRetries`, `baseDelayMs`, `maxDelayMs`, `multiplier`, `isRetryable`, `onRetry`), `FileRead` (context file: `path`, `sizeBytes`), `TelemetryEntry` (per-call log: `timestamp`, `prompt`, `systemPrompt`, `response`, `model`, `inputTokens`, `outputTokens`, `cacheReadTokens`, `cacheCreationTokens`, `latencyMs`, `exitCode`, `error`, `retryCount`, `thinking`, `filesRead`), `RunLog` (session aggregate: `runId`, `startTime`, `endTime`, `backend`, `model`, `command`, `entries`, `summary`), `AIServiceError` (typed exception: `code`, `message` with codes `'CLI_NOT_FOUND' | 'TIMEOUT' | 'PARSE_ERROR' | 'SUBPROCESS_ERROR' | 'RATE_LIMIT'`).

## Subdirectories

**[backends/](./backends/)** — CLI adapters implementing AIBackend interface: `ClaudeBackend` (production: tri-format JSON parser via `extractResultJson()` handling CLI ≥2.1.38 arrays, NDJSON, legacy single-object, Zod `ClaudeResponseSchema` validation, `modelUsage`/`usage`/`total_cost_usd`/`duration_ms` extraction, args `['-p', '--output-format', 'json', '--no-session-persistence', '--allowedTools', 'Read', 'Write', '--model', '--system-prompt', '--max-turns']`), `GeminiBackend` (stub throwing `AIServiceError('SUBPROCESS_ERROR', 'not yet implemented')`), `OpenCodeBackend` (production: NDJSON parser via `parseNdjson()` aggregating `text` events and `step_finish` token metrics from `OpenCodeStepFinishSchema`/`OpenCodeTextSchema`, `calculateCostFromTokens()` fallback with constants `INPUT_COST_PER_MTOK=15`, `OUTPUT_COST_PER_MTOK=75`, `CACHE_WRITE_COST_PER_MTOK=18.75`, `CACHE_READ_COST_PER_MTOK=1.50`, args `['run', '--format', 'json', '--model']`, model always `'unknown'`). Shared `isCommandOnPath()` utility scans `process.env.PATH` with Windows `PATHEXT` support via `fs.stat()`.

**[telemetry/](./telemetry/)** — `TelemetryLogger` accumulates `TelemetryEntry[]` in memory via `addEntry()`, mutates last entry via `setFilesReadOnLastEntry()`, computes aggregate `totalCalls`, `totalInputTokens`, `totalOutputTokens`, `totalCacheReadTokens`, `totalCacheCreationTokens`, `totalDurationMs`, `errorCount`, `totalFilesRead`, `uniqueFilesRead` via `getSummary()` on-demand iteration, exports `toRunLog(): RunLog` snapshot with ISO 8601 `startTime`/`endTime`. `writeRunLog(projectRoot, runLog)` creates `.agents-reverse-engineer/logs/` via `recursive: true`, writes `JSON.stringify(runLog, null, 2)` to `run-{safeCommand}-{safeBackend}-{safeModel}-{safeTimestamp}.json` (sanitizes command/backend/model via `/[^a-z0-9]/g` → `'-'`, timestamp via `/[:.]/g` → `'-'`), returns absolute path. `cleanupOldLogs(projectRoot, keepCount)` deletes old `run-*.json` files via lexicographic sort descending (`entries.sort(); entries.reverse()`), returns deletion count or 0 on ENOENT.

## Architecture

### Request Flow
`src/cli/*.ts` → `src/orchestration/runner.ts` `CommandRunner.run()` → `src/generation/executor.ts` `runPool(tasks)` → `AIService.call(options)` → `withRetry(() => provider.call(options))` → `SubprocessProvider.call()` → `runSubprocess(backend.cliCommand, backend.buildArgs(options), {input: prompt, timeoutMs})` → `backend.parseResponse(stdout, durationMs, exitCode)` → `AIResponse` → telemetry accumulation → trace emission → finalization writes RunLog.

### Retry Policy
`withRetry()` configured with `isRetryable: (err) => err instanceof AIServiceError && err.code === 'RATE_LIMIT'`. Timeouts explicitly NOT retried (comment: "spawning another heavyweight subprocess on a system that's already struggling... makes things worse and can exhaust system resources"). Delay formula: `min(1000 * 2^attempt, 8000) + random(0-500ms)`. Max 3 retries (`DEFAULT_RETRY_OPTIONS.maxRetries`).

### Timeout Strategy
`execFile()` sends SIGTERM at `options.timeoutMs`. `setTimeout(() => process.kill(-childPid, 'SIGKILL'), timeoutMs + 5000)` escalates to SIGKILL if process doesn't exit within grace period. Timer unref'd via `.unref()` to prevent blocking event loop. Process group kill pattern `process.kill(-childPid, ...)` targets entire process tree. Cleanup fallback: single-process `process.kill(childPid, 'SIGKILL')` on error.

### Backend Auto-Detection
`detectBackend(registry)` iterates `registry.getAll()` in insertion order (priority: Claude > Gemini > OpenCode), calls `backend.isAvailable()` (PATH lookup via `isCommandOnPath()`), returns first available backend or `null`. `resolveBackend(requested: 'auto')` auto-detects, throws `AIServiceError('CLI_NOT_FOUND')` with aggregated install instructions if none found. Explicit backend names validated via `registry.get()` + `isAvailable()` check.

### Telemetry Lifecycle
`AIService` instantiates `TelemetryLogger(runId, backend, model, command)` at construction. `call()` records `TelemetryEntry` post-execution via `logger.addEntry()`. `addFilesReadToLastEntry(filesRead)` mutates most recent entry after `CommandRunner.run()` attaches FileRead metadata. `finalize(projectRoot)` converts `logger.toRunLog()`, writes via `writeRunLog()` to `.agents-reverse-engineer/logs/run-{timestamp}.json`, calls `cleanupOldLogs(projectRoot, config.ai.telemetry.keepRuns)` for retention enforcement, returns log path and summary.

### Trace Emission
`SubprocessProvider.call()` emits two event types: `subprocess:spawn` (after `onSpawn` callback: `childPid`, `command`, `taskLabel`, `spawnTimestamp`), `subprocess:exit` (after await: `childPid`, `exitCode`, `signal`, `durationMs`, `timedOut`). Optional `ITraceWriter` (late-bound via `setTracer()`) writes NDJSON to `.agents-reverse-engineer/traces/trace-{ISO8601}.ndjson` when `--trace` flag set. `AIService.call()` emits `{type: 'retry', attempt, taskLabel, errorCode}` on each retry via `onRetry` callback.

## Behavioral Contracts

### Rate-Limit Detection
```javascript
RATE_LIMIT_PATTERNS = ['rate limit', '429', 'too many requests', 'overloaded']
RATE_LIMIT_PATTERNS.some(pattern => stderr.toLowerCase().includes(pattern))
```

### Timeout Detection
```javascript
timedOut = error !== null && 'killed' in error && error.killed === true
// Relies on execFile setting killed: true when timeout triggers SIGTERM
```

### Process Group Kill
```javascript
process.kill(-child.pid, 'SIGKILL')  // Negative PID targets process group
// Fallback: process.kill(child.pid, 'SIGKILL')
```

### Stdin Close Requirement
Must call `child.stdin.end()` after writing `options.input` (or immediately if no input). Child process blocks waiting for EOF otherwise.

### Backend Auto-Wrapping
```javascript
isAIBackend(obj) = 'buildArgs' in obj && 'parseResponse' in obj && 'cliCommand' in obj
// If true, wrap in SubprocessProvider(backend, options)
```

### Timestamp Sanitization
```javascript
safeTimestamp = runLog.startTime.replace(/[:.]/g, '-')
safeCommand = runLog.command.replace(/[^a-z0-9]/g, '-')
safeBackend = runLog.backend.replace(/[^a-z0-9]/g, '-')
safeModel = runLog.model.replace(/[^a-z0-9]/g, '-')
// Filename: run-${safeCommand}-${safeBackend}-${safeModel}-${safeTimestamp}.json
```

### Lexicographic Retention
```javascript
entries.sort().reverse()  // Descending (ISO timestamps sort correctly)
toDelete = entries.slice(keepCount)
```

### Unique File Counting
```javascript
uniqueFilesRead = new Set(entries.flatMap(e => e.filesRead?.map(f => f.path) ?? [])).size
```

### Claude Output Format Detection
`extractResultJson()` handles three CLI versions:
1. **JSON array** (CLI ≥2.1.38): `[{system}, {assistant}, {result}]` — finds `type:"result"` element
2. **NDJSON**: line-delimited `{...}\n{...}\n{"type":"result",...}` — splits by `\n`, finds result line
3. **Legacy** (CLI ≤2.1.31): `Non-JSON text{"type":"result",...}` — slices from first `{`

Throws `AIServiceError('PARSE_ERROR')` if no result object found.

### OpenCode Cost Calculation
```javascript
INPUT_COST_PER_MTOK = 15
OUTPUT_COST_PER_MTOK = 75
CACHE_WRITE_COST_PER_MTOK = 18.75
CACHE_READ_COST_PER_MTOK = 1.50
// Applied when totalCost === 0 && (inputTokens > 0 || outputTokens > 0)
```