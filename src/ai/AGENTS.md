<!-- Generated by agents-reverse-engineer -->

# src/ai

AI service orchestration layer providing backend-agnostic CLI invocation with subprocess management, exponential backoff retry, telemetry logging, and trace event emission.

## Contents

**[index.ts](./index.ts)** — Barrel export defining public API surface. Re-exports `AIService`, `AIServiceOptions`, `BackendRegistry`, `createBackendRegistry`, `resolveBackend`, `detectBackend`, `getInstallInstructions`, `withRetry`, `DEFAULT_RETRY_OPTIONS`, `runSubprocess`, `isCommandOnPath` plus all types: `AIBackend`, `AIResponse`, `AICallOptions`, `SubprocessResult`, `RetryOptions`, `TelemetryEntry`, `RunLog`, `FileRead`, `AIServiceError`.

**[types.ts](./types.ts)** — Central type registry. Defines `AIBackend` interface (backend adapter contract with `name`, `cliCommand`, `isAvailable`, `buildArgs`, `parseResponse`, `getInstallInstructions`), `AICallOptions` (request spec with `prompt`, optional `systemPrompt`, `model`, `timeoutMs`, `maxTurns`, `taskLabel`), `AIResponse` (normalized response with `text`, `model`, token counts, `durationMs`, `exitCode`, `raw`), `SubprocessResult` (process outcome with `stdout`, `stderr`, `exitCode`, `signal`, `durationMs`, `timedOut`, `childPid`), `RetryOptions` (backoff config with `maxRetries`, `baseDelayMs`, `maxDelayMs`, `multiplier`, `isRetryable` predicate, `onRetry` callback), `TelemetryEntry` (per-call log record), `RunLog` (aggregated run stats), `FileRead` (context file metadata), `AIServiceError` (typed error with `code` field), `AIServiceErrorCode` union.

**[service.ts](./service.ts)** — `AIService` orchestrator managing backend calls with retry, telemetry, trace emission. Constructor accepts `AIBackend` and `AIServiceOptions` (`timeoutMs`, `maxRetries`, `model`, `telemetry.keepRuns`). `call(options)` wraps `runSubprocess` in `withRetry`, detects rate limits via `isRateLimitStderr` (matches `RATE_LIMIT_PATTERNS`: "rate limit", "429", "too many requests", "overloaded"), logs `TelemetryEntry`, emits `subprocess:spawn`/`subprocess:exit`/`retry` trace events via `ITraceWriter`. `finalize(projectRoot)` writes `RunLog` via `writeRunLog`, enforces retention via `cleanupOldLogs`, returns `logPath` and `summary`. `setTracer`, `setDebug`, `setSubprocessLogDir`, `addFilesReadToLastEntry`, `getSummary` provide runtime config and introspection. Tracks `activeSubprocesses` count, formats debug output with `formatBytes` helper, serializes per-subprocess `.log` writes via `logWriteQueue` promise chain.

**[subprocess.ts](./subprocess.ts)** — `runSubprocess(command, args, options)` spawns CLI via `execFile` with stdin piping, timeout enforcement (SIGTERM → SIGKILL escalation after 5s grace period), process group killing (`kill(-pid)`) to terminate subprocess tree. Returns `SubprocessResult` always resolving (never rejects). `getActiveSubprocessCount()`, `getActiveSubprocesses()` expose concurrency tracking via internal `activeSubprocesses` Map. `SubprocessOptions` configures `timeoutMs`, optional `input` (stdin), `onSpawn` callback. Sets `maxBuffer: 10MB`, `killSignal: 'SIGTERM'`, unref'd SIGKILL timer.

**[retry.ts](./retry.ts)** — `withRetry<T>(fn, options)` wraps async operations with exponential backoff. Computes delay as `min(baseDelayMs * multiplier^attempt, maxDelayMs) + jitter[0,500ms]`. Calls `options.isRetryable(error)` to distinguish transient/permanent failures, invokes `options.onRetry(attempt, error)` before delays. `DEFAULT_RETRY_OPTIONS` constant defines `maxRetries: 3`, `baseDelayMs: 1000`, `maxDelayMs: 8000`, `multiplier: 2`.

**[registry.ts](./registry.ts)** — `BackendRegistry` stores `AIBackend` instances keyed by `backend.name` in insertion order. `createBackendRegistry()` populates with `ClaudeBackend`, `GeminiBackend`, `OpenCodeBackend` (priority: Claude > Gemini > OpenCode). `detectBackend(registry)` returns first available backend via `backend.isAvailable()` or null. `resolveBackend(registry, requested)` handles two paths: `'auto'` triggers detection with formatted error via `getInstallInstructions()` on failure; explicit name validates availability and throws `AIServiceError('CLI_NOT_FOUND')` if missing.

## Subdirectories

**[backends/](./backends/)** — CLI adapters implementing `AIBackend`: `ClaudeBackend` (parses JSON via `ClaudeResponseSchema`, extracts model from `modelUsage` keys, exports `isCommandOnPath` PATH detection helper), `GeminiBackend` stub (throws `SUBPROCESS_ERROR` until JSON output stable), `OpenCodeBackend` stub (throws `SUBPROCESS_ERROR` until JSONL parsing implemented). All check CLI availability via `isCommandOnPath`, build argument arrays, normalize responses to `AIResponse`.

**[telemetry/](./telemetry/)** — Lifecycle managers: `TelemetryLogger` accumulates `TelemetryEntry` in memory (`addEntry`, `setFilesReadOnLastEntry`, `getSummary`, `toRunLog`), `writeRunLog` persists `RunLog` to `.agents-reverse-engineer/logs/run-<timestamp>.json`, `cleanupOldLogs` enforces retention by deleting oldest logs exceeding `keepCount`.

## Architecture

`AIService` orchestrates: (1) Backend resolution via `BackendRegistry`, (2) CLI argument construction via `backend.buildArgs`, (3) Subprocess execution via `runSubprocess` with stdin delivery, (4) Retry wrapping via `withRetry` filtering rate limit errors, (5) Response parsing via `backend.parseResponse`, (6) Telemetry accumulation via `TelemetryLogger`, (7) Trace emission via `ITraceWriter` (from `../orchestration/trace.js`), (8) Log persistence via `writeRunLog` + `cleanupOldLogs`. Backends delegate process invocation to shared `runSubprocess` (handles timeout, SIGKILL escalation, process group killing), enabling uniform subprocess management across CLIs.

## Error Handling

`AIService.call()` throws `AIServiceError` with typed `code`: `CLI_NOT_FOUND` (backend unavailable), `TIMEOUT` (subprocess exceeded `timeoutMs`), `RATE_LIMIT` (matched stderr patterns), `SUBPROCESS_ERROR` (non-zero exit without rate limit), `PARSE_ERROR` (backend parsing failed). Retry logic only retries `RATE_LIMIT` (via `isRetryable` predicate in `withRetry`); timeouts fail immediately to avoid resource exhaustion. Backend `parseResponse` implementations throw `PARSE_ERROR` on schema validation failure or missing JSON.

## Concurrency Tracking

`subprocess.ts` maintains `activeSubprocesses` Map (`pid -> {command, spawnedAt}`) for debugging. `AIService` increments `activeSubprocesses` before spawn, decrements after callback, logs count in debug mode. `getActiveSubprocessCount()`, `getActiveSubprocesses()` expose real-time concurrency state for orchestration layer (`src/orchestration/pool.ts` enforces concurrency limits).

## Telemetry Flow

1. CLI command instantiates `TelemetryLogger(runId)` capturing `startTime`
2. `AIService.call()` records `TelemetryEntry` after each subprocess (tokens, duration, errors, `thinking: 'not supported'`, `filesRead: []`)
3. Command runner calls `addFilesReadToLastEntry(filesRead)` post-hoc (async file metadata)
4. `AIService.finalize(projectRoot)` converts logger to `RunLog` via `toRunLog()` (computes `summary` with `totalInputTokens`, `totalCacheReadTokens`, `errorCount`, `uniqueFilesRead`), writes via `writeRunLog`, enforces retention via `cleanupOldLogs`

## Rate Limit Strategy

`isRateLimitStderr(stderr)` matches case-insensitive patterns: "rate limit", "429", "too many requests", "overloaded". `call()` checks stderr on non-zero exit → throws `RATE_LIMIT` error → `withRetry` retries with exponential backoff. Jitter (`[0,500ms]`) prevents thundering herd when concurrent pool workers hit simultaneous rate limits. `onRetry` callback logs warnings, emits `retry` trace events with `attemptNumber`, `error`.

## Trace Integration

`AIService.setTracer(tracer)` configures `ITraceWriter` from `../orchestration/trace.js`. Emits `subprocess:spawn` (via `onSpawn` callback with `pid`), `subprocess:exit` (with `childPid`, `exitCode`, `signal`, `durationMs`, `timedOut`), `retry` (with `attemptNumber`, `error`). Debug mode logs active subprocess count, heap usage, RSS, timeout via `formatBytes` helper.

## Subprocess Log Persistence

`setSubprocessLogDir(dir)` enables per-subprocess `.log` file writes. `enqueueSubprocessLog(result, taskLabel)` serializes writes via `logWriteQueue` promise chain (prevents concurrent `mkdir` races), logs format: `taskLabel`, `childPid`, `command`, `exitCode`, `signal`, `durationMs`, `timedOut`, stdout, stderr. Failures silently swallowed (non-critical).