<!-- Generated by agents-reverse-engineer -->

# src/ai

Backend-agnostic AI service orchestration layer: subprocess-spawning adapters for Claude Code/Gemini/OpenCode CLIs, exponential backoff retry logic with rate limit detection, timeout enforcement via SIGTERM/SIGKILL escalation, NDJSON telemetry logging with token cost tracking, and trace event emission for concurrent pool workflows.

## Contents

**[index.ts](./index.ts)** — Barrel export consolidating AIService, BackendRegistry, createBackendRegistry, resolveBackend, detectBackend, getInstallInstructions, withRetry, runSubprocess, isCommandOnPath with type re-exports (AIBackend, AIResponse, AICallOptions, SubprocessResult, RetryOptions, TelemetryEntry, RunLog, FileRead, AIServiceError).

**[registry.ts](./registry.ts)** — BackendRegistry stores AIBackend implementations in insertion-order Map with `register(backend)`, `get(name)`, `getAll()` methods; createBackendRegistry() pre-populates ClaudeBackend/GeminiBackend/OpenCodeBackend; resolveBackend(registry, 'auto'|name) performs auto-detection or explicit lookup throwing CLI_NOT_FOUND with install instructions.

**[retry.ts](./retry.ts)** — withRetry() executes async function with exponential backoff (delay = min(baseDelayMs × multiplier^attempt, maxDelayMs) + jitter[0..500ms]) calling isRetryable(error) predicate before each retry, invoking onRetry(attempt, error) callback for telemetry.

**[service.ts](./service.ts)** — AIService orchestrates call(options) via runSubprocess() wrapped in withRetry(), detects rate limits via stderr pattern matching (['rate limit', '429', 'too many requests', 'overloaded']), emits subprocess:spawn/exit/retry trace events, accumulates TelemetryEntry records via internal TelemetryLogger, writes RunLog to `.agents-reverse-engineer/logs/run-<timestamp>.json` on finalize(), enforces cleanup via cleanupOldLogs(keepRuns).

**[subprocess.ts](./subprocess.ts)** — runSubprocess() spawns child process via execFile() with stdin piping, timeout enforcement (SIGTERM at timeoutMs, SIGKILL after 5s grace), process group killing (`kill(-pid)`) for tree termination, concurrent subprocess tracking via Map<pid, {command, spawnedAt}>, returns SubprocessResult with stdout/stderr/exitCode/signal/durationMs/timedOut/childPid.

**[types.ts](./types.ts)** — Defines AIBackend interface (isAvailable/buildArgs/parseResponse/getInstallInstructions), AICallOptions (prompt/systemPrompt/model/timeoutMs/maxTurns/taskLabel), AIResponse (text/model/inputTokens/outputTokens/cacheReadTokens/cacheCreationTokens/durationMs/exitCode/raw), SubprocessResult, RetryOptions, TelemetryEntry, RunLog with summary aggregation, FileRead, AIServiceError with discriminated codes ('CLI_NOT_FOUND'|'TIMEOUT'|'PARSE_ERROR'|'SUBPROCESS_ERROR'|'RATE_LIMIT').

## Subdirectories

**[backends/](./backends/)** — ClaudeBackend with Zod-validated JSON parsing extracting usage.input_tokens/output_tokens/cache_read_input_tokens/cache_creation_input_tokens, GeminiBackend/OpenCodeBackend stubs throwing SUBPROCESS_ERROR, isCommandOnPath() cross-platform PATH detection with Windows PATHEXT extension iteration.

**[telemetry/](./telemetry/)** — TelemetryLogger accumulates per-call entries computing aggregate summary (totalInputTokens/totalCacheReadTokens/errorCount/uniqueFilesRead), writeRunLog() serializes to `.agents-reverse-engineer/logs/run-<timestamp>.json` with filename sanitization (`/[:.]/g → '-'`), cleanupOldLogs() enforces retention via lexicographic sort on ISO 8601 filenames.

## Architecture

### Three-Layer Design

**Backend Adapter Layer** (backends/): AIBackend implementations translate AICallOptions into CLI-specific argv arrays via buildArgs(), parse stdout JSON into normalized AIResponse via parseResponse(), detect availability via isCommandOnPath() checking PATH directories with Windows PATHEXT handling.

**Subprocess Execution Layer** (subprocess.ts): runSubprocess() spawns execFile() with 10MB maxBuffer, writes input to stdin via Buffer.byteLength() computed payload, enforces timeout via SIGTERM then SIGKILL escalation with unref()'d timer, kills process groups via negative PID (`process.kill(-child.pid, 'SIGKILL')`), tracks active subprocesses in Map for concurrency monitoring.

**Service Orchestration Layer** (service.ts): AIService wraps runSubprocess() calls in withRetry() with isRateLimitStderr() predicate detecting ['rate limit', '429', 'too many requests', 'overloaded'] patterns, emits subprocess:spawn/exit trace events via ITraceWriter, accumulates TelemetryEntry[] via TelemetryLogger, finalizes RunLog with summary (totalInputTokens, totalCacheReadTokens, errorCount, uniqueFilesRead).

### Retry Strategy

withRetry() executes fn() up to maxRetries+1 times with exponential backoff: `min(baseDelayMs * multiplier^attempt, maxDelayMs) + random(0..500ms)`. Checks isRetryable(error) before each sleep—permanently fails on auth errors or non-retryable signals. Invokes onRetry(attempt, error) before delay for trace emission. AIService.call() only retries RATE_LIMIT errors (code === 'RATE_LIMIT'), treats TIMEOUT as permanent failure to prevent resource exhaustion.

### Timeout Enforcement

runSubprocess() sends SIGTERM at timeoutMs via execFile killSignal option. Sets unref()'d SIGKILL timer at `timeoutMs + 5000ms`. Clears timer in callback if process exits before escalation. Process group killing (`kill(-pid)`) terminates entire subprocess tree. Falls back to single-process kill if group signal fails.

### Telemetry Pipeline

AIService.call() records TelemetryEntry after each subprocess completion with timestamp/prompt/systemPrompt/response/model/inputTokens/outputTokens/cacheReadTokens/cacheCreationTokens/latencyMs/exitCode/error/retryCount/thinking/filesRead. TelemetryLogger.addEntry() appends to in-memory entries[]. AIService.addFilesReadToLastEntry(filesRead) mutates most recent entry to attach FileRead[] metadata (path + sizeBytes). AIService.finalize() calls TelemetryLogger.toRunLog() computing summary, writes to `.agents-reverse-engineer/logs/run-<timestamp>.json` via writeRunLog(), enforces retention via cleanupOldLogs(keepRuns).

### Resource Management

Subprocess limits injected by AIService via environment variables (set in src/ai/service.ts, executed in subprocess.ts):
- `NODE_OPTIONS='--max-old-space-size=512'` — limits heap to 512MB per subprocess
- `UV_THREADPOOL_SIZE='4'` — constrains libuv thread pool to 4 threads
- `CLAUDE_CODE_DISABLE_BACKGROUND_TASKS='1'` — prevents background task spawning
- CLI args: `--disallowedTools Task` — blocks subagent spawning

activeSubprocesses Map tracks concurrent processes keyed by PID with {command, spawnedAt}. getActiveSubprocessCount() returns Map size. getActiveSubprocesses() computes runningMs as `Date.now() - spawnedAt`.

### Debug Logging

AIService.setDebug(true) enables stderr output before/after subprocess with heapUsed/rss metrics via formatBytes(). AIService.setSubprocessLogDir(dir) writes per-subprocess `.log` files with metadata header (task/pid/command/exit/signal/duration/timed_out) followed by stdout/stderr sections. Serialized via logWriteQueue promise chain preventing concurrent mkdir races. Failures silently swallowed (non-critical).

## Integration Points

**Phase 1 Orchestration**: `src/generation/executor.ts` calls AIService.call() for each .sum file generation passing prompt from `src/generation/prompts/builder.ts`, attaches filesRead metadata via addFilesReadToLastEntry() after file analysis.

**Worker Pool**: `src/orchestration/pool.ts` shares single AIService instance across N workers (default 2 for WSL, 5 elsewhere), monitors concurrency via getActiveSubprocessCount(), emits trace events via AIService.setTracer(tracer).

**Trace Emission**: AIService subprocess:spawn/exit events serialized to `.agents-reverse-engineer/traces/trace-<timestamp>.ndjson` via `src/orchestration/trace.ts` TraceWriter with promise-chain ordering guarantees.

**Registry Auto-Detection**: `src/cli/generate.ts` calls createBackendRegistry() then resolveBackend(registry, config.ai.backend) for backend selection, throws CLI_NOT_FOUND with install instructions when backend unavailable.

**Incremental Updates**: `src/update/orchestrator.ts` reuses same AIService instance for modified file regeneration, shares telemetry accumulation across discovery + analysis phases.

## Behavioral Contracts

### Rate Limit Detection Patterns

```javascript
['rate limit', '429', 'too many requests', 'overloaded'].some(p => 
  stderr.toLowerCase().includes(p)
)
```

### Timeout Detection

```javascript
result.timedOut === true  // set when error.killed === true in execFile callback
```

### Exit Code Extraction

```javascript
error === null ? 0
: typeof error.code === 'number' ? error.code
: child.exitCode !== null ? child.exitCode
: 1
```

### Process Group Killing

```javascript
process.kill(-child.pid, 'SIGKILL')  // negative PID targets process group
```

### Filename Sanitization

```javascript
runLog.startTime.replace(/[:.]/g, '-')  // ISO 8601 → filesystem-safe
// Example: 2026-02-07T12:00:00.000Z → run-2026-02-07T12-00-00-000Z.json
```

### Log File Filtering

```javascript
name.startsWith('run-') && name.endsWith('.json')
```