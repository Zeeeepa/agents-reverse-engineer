<!-- Generated by agents-reverse-engineer -->

# src/ai

AI service orchestration layer providing multi-backend LLM invocation with subprocess management, exponential backoff retry, telemetry collection, and trace emission.

## Contents

### Core Service

**[service.ts](./service.ts)** — `AIService` orchestrates AI CLI subprocess invocations via `runSubprocess()`, wraps calls in `withRetry()` for transient `RATE_LIMIT` errors, records `TelemetryEntry` instances in `TelemetryLogger`, emits `subprocess:spawn`/`subprocess:exit`/`retry` events to `ITraceWriter`, writes per-subprocess `.log` files via serialized `logWriteQueue`, exposes `call(options: AICallOptions)` returning `AIResponse`, `finalize(projectRoot)` persisting run log and returning `{ logPath, summary }`, `addFilesReadToLastEntry(filesRead)` attaching file metadata, `setTracer(tracer)` enabling trace emission, `setDebug(enabled)` enabling verbose subprocess logging with heap/RSS/PID/duration metrics.

**[subprocess.ts](./subprocess.ts)** — `runSubprocess(command, args, options)` spawns CLI child process via `execFile` with `timeoutMs` enforcement, SIGTERM on timeout with SIGKILL escalation after `SIGKILL_GRACE_MS` (5000ms), pipes `options.input` to stdin, tracks active subprocesses in `activeSubprocesses` Map, returns `SubprocessResult` with `stdout`, `stderr`, `exitCode`, `signal`, `durationMs`, `timedOut`, `childPid`.

**[retry.ts](./retry.ts)** — `withRetry(fn, options)` wraps async functions with exponential backoff retry logic using formula `min(baseDelayMs * multiplier^attempt, maxDelayMs) + jitter` where jitter is random [0, 500ms], checks `isRetryable(error)` predicate, invokes `onRetry(attempt, error)` callback, throws immediately on permanent errors or exhausted retries; `DEFAULT_RETRY_OPTIONS` provides `maxRetries: 3`, `baseDelayMs: 1_000`, `maxDelayMs: 8_000`, `multiplier: 2`.

**[types.ts](./types.ts)** — Defines complete type system: `AIBackend` interface with `isAvailable()`, `buildArgs()`, `parseResponse()`, `getInstallInstructions()` methods; `AICallOptions` with `prompt`, optional `systemPrompt`/`model`/`timeoutMs`/`maxTurns`/`taskLabel`; `AIResponse` with `text`, `model`, token counts, `durationMs`, `exitCode`; `SubprocessResult` with process outcome fields; `TelemetryEntry` with per-call metrics; `RunLog` with aggregated entries and summary; `AIServiceError` with typed `code` field from `AIServiceErrorCode` union.

### Backend Management

**[registry.ts](./registry.ts)** — `BackendRegistry` stores `AIBackend` instances in insertion order, `createBackendRegistry()` pre-populates with `ClaudeBackend`, `GeminiBackend`, `OpenCodeBackend`, `detectBackend(registry)` returns first available via `isAvailable()` checks, `resolveBackend(registry, requested)` resolves by name or auto-detection throwing `AIServiceError` with code `CLI_NOT_FOUND` and install instructions when unavailable.

**[index.ts](./index.ts)** — Barrel export enforcing import boundary, re-exports all types/classes/functions from service, registry, retry, subprocess, types modules, comments prohibit direct imports from `src/ai/backends/` or `src/ai/telemetry/`.

## Subdirectories

**[backends/](./backends/)** — `ClaudeBackend`, `GeminiBackend`, `OpenCodeBackend` implementing `AIBackend` interface, `ClaudeBackend` parsing JSON array/NDJSON/legacy formats via `ClaudeResponseSchema` Zod validation, shared `isCommandOnPath()` PATH detection.

**[telemetry/](./telemetry/)** — `TelemetryLogger` accumulating `TelemetryEntry` instances, `writeRunLog()` persisting `RunLog` to `.agents-reverse-engineer/logs/run-${timestamp}.json`, `cleanupOldLogs()` enforcing retention policies.

## Architecture

### Request Flow

1. `AIService.call()` receives `AICallOptions` with prompt text
2. Merges service-level default `model` into call options
3. `backend.buildArgs(options)` constructs CLI argument array
4. `withRetry()` wraps `runSubprocess(backend.cliCommand, args, { input: prompt, timeoutMs, onSpawn })`
5. `runSubprocess()` spawns child process, pipes stdin, enforces timeout with SIGTERM/SIGKILL escalation
6. `backend.parseResponse(stdout, durationMs, exitCode)` normalizes output to `AIResponse`
7. `logger.addEntry()` records telemetry with tokens/latency/errors
8. Optional `tracer.emit()` broadcasts subprocess lifecycle events

### Error Handling Strategy

`AIService.call()` distinguishes error codes:
- **TIMEOUT**: `SubprocessResult.timedOut === true`, not retried
- **RATE_LIMIT**: `isRateLimitStderr(stderr)` matching patterns `['rate limit', '429', 'too many requests', 'overloaded']`, retried with exponential backoff
- **PARSE_ERROR**: `backend.parseResponse()` throws, wrapped in `AIServiceError`
- **SUBPROCESS_ERROR**: Non-zero exit code without rate limit signal, includes first 500 chars stderr

### Telemetry Lifecycle

1. `AIService` constructor creates `TelemetryLogger` with ISO timestamp `runId`
2. Each `call()` appends `TelemetryEntry` with prompt/response/tokens/latency/retryCount
3. Command runners call `addFilesReadToLastEntry(filesRead)` post-hoc to attach file metadata
4. `finalize(projectRoot)` calls `logger.toRunLog()` computing summary statistics, writes via `writeRunLog()`, cleans up via `cleanupOldLogs(projectRoot, keepRuns)`, returns `{ logPath, summary }`

### Concurrency Management

`activeSubprocesses` Map in subprocess.ts tracks `{ command, spawnedAt }` by PID. `getActiveSubprocessCount()` and `getActiveSubprocesses()` expose concurrency metrics. Debug mode logs heap usage, RSS, active subprocess count before/after spawn. Serialized `logWriteQueue` in service.ts prevents corrupted subprocess log writes from concurrent pool workers.

## Behavioral Contracts

### Rate Limit Detection Patterns

```typescript
['rate limit', '429', 'too many requests', 'overloaded']
```

Matched against `stderr.toLowerCase()` to distinguish retryable rate limits from permanent errors.

### Timeout Escalation

SIGTERM sent at `options.timeoutMs`, SIGKILL sent at `options.timeoutMs + 5000ms` targeting process group via `process.kill(-childPid, 'SIGKILL')` with fallback to single-process kill.

### Exponential Backoff Formula

```typescript
delay = min(baseDelayMs * multiplier^attempt, maxDelayMs) + Math.random() * 500
```

Default values: `baseDelayMs: 1000`, `multiplier: 2`, `maxDelayMs: 8000`, jitter window: [0, 500ms].

### Subprocess Log Filename Sanitization

```typescript
taskLabel.replace(/\//g, '--').replace(/[^a-zA-Z0-9_\-]/g, '_') + `_pid${childPid}.log`
```

### Trace Event Types

- `subprocess:spawn` with `childPid`, `command`, `taskLabel`
- `subprocess:exit` with `childPid`, `command`, `taskLabel`, `exitCode`, `signal`, `durationMs`, `timedOut`
- `retry` with `attempt`, `taskLabel`, `errorCode`

## File Relationships

`service.ts` imports `runSubprocess` from subprocess.ts, `withRetry` from retry.ts, `TelemetryLogger` from telemetry/logger.ts, `ITraceWriter` from `../orchestration/trace.js`. `registry.ts` imports backend implementations from backends/ subdirectory. `subprocess.ts` imports `SubprocessResult` from types.ts. All modules import type definitions from types.ts establishing shared vocabulary. `index.ts` re-exports all public symbols enforcing single import boundary.