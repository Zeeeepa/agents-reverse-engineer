---
generated_at: 2026-02-09T17:45:02.917Z
content_hash: 232da2af981eb6c44ab5f5e8908ea14d6ee97fe4295f950b83f42ee45e40a95a
purpose: AIService orchestrates AI CLI subprocess execution with retry logic, telemetry logging, timeout enforcement, and rate...
---
**AIService orchestrates AI CLI subprocess execution with retry logic, telemetry logging, timeout enforcement, and rate-limit detection for agents-reverse-engineer's three-phase documentation pipeline.**

## Exported Interface

**class AIService** — Main entry point for AI calls with integrated subprocess management, exponential backoff retry, telemetry accumulation, and run log finalization.

**constructor(backend: AIBackend, options: AIServiceOptions)** — Initializes service with backend adapter (Claude/Gemini/OpenCode) and configuration for timeouts, retries, telemetry retention.

**async call(options: AICallOptions): Promise<AIResponse>** — Executes AI call with retry wrapper around `runSubprocess()`, records `TelemetryEntry` on success/failure, merges service-level `model` default with per-call override, emits `subprocess:spawn/exit` and `retry` trace events via `ITraceWriter`.

**async finalize(projectRoot: string): Promise<{ logPath: string; summary: RunLog['summary'] }>** — Writes accumulated run log via `writeRunLog()`, invokes `cleanupOldLogs()` for retention enforcement, returns log path and summary statistics.

**setTracer(tracer: ITraceWriter): void** — Attaches trace writer for subprocess lifecycle and retry event emission.

**setDebug(enabled: boolean): void** — Enables stderr logging of spawn metadata (active subprocess count, heap/RSS, timeout, PID, exit code, duration).

**setSubprocessLogDir(dir: string): void** — Enables per-subprocess `.log` file writes containing task label, PID, command, exit code, signal, duration, stdout, stderr.

**addFilesReadToLastEntry(filesRead: FileRead[]): void** — Attaches file-read metadata to most recent `TelemetryEntry` via `TelemetryLogger.setFilesReadOnLastEntry()`.

**getSummary(): RunLog['summary']** — Returns current aggregated statistics without finalizing.

**interface AIServiceOptions** — Service configuration with `timeoutMs`, `maxRetries`, optional `model`, and nested `telemetry.keepRuns`.

## Call Execution Flow

`call()` increments `callCount`, merges effective options (service-level `model` as default), builds CLI args via `backend.buildArgs()`, wraps `runSubprocess()` in `withRetry()` configured to retry only `RATE_LIMIT` errors (timeouts are NOT retried per MEMORY.md resource constraint rationale), increments/decrements `activeSubprocesses` counter before/after subprocess completion, emits `subprocess:spawn` via `onSpawn` callback at actual spawn time (not after completion), emits `subprocess:exit` after completion with `childPid`, `exitCode`, `signal`, `durationMs`, `timedOut`, invokes `enqueueSubprocessLog()` fire-and-forget for optional log writes, parses response via `backend.parseResponse()` wrapped in try-catch throwing `AIServiceError('PARSE_ERROR')` on parse failure, records `TelemetryEntry` with prompt, systemPrompt, response, model, tokens (input/output/cacheRead/cacheCreation), latencyMs, exitCode, retryCount, thinking='not supported', filesRead=[] (populated later via `addFilesReadToLastEntry`), throws `AIServiceError('TIMEOUT')` on `SubprocessResult.timedOut`, throws `AIServiceError('RATE_LIMIT')` when stderr matches patterns via `isRateLimitStderr()`, throws `AIServiceError('SUBPROCESS_ERROR')` on non-zero exit codes not matching rate-limit patterns.

## Rate Limit Detection

**const RATE_LIMIT_PATTERNS = ['rate limit', '429', 'too many requests', 'overloaded']** — Substring patterns for detecting transient rate-limit errors in subprocess stderr.

**function isRateLimitStderr(stderr: string): boolean** — Case-insensitive substring search across `RATE_LIMIT_PATTERNS`.

## Retry Configuration

`withRetry()` invoked with spread `DEFAULT_RETRY_OPTIONS` (maxRetries=3, baseDelayMs=1000, maxDelayMs=8000, multiplier=2) plus custom `isRetryable` predicate accepting only `AIServiceError.code === 'RATE_LIMIT'` (timeouts excluded per resource constraint mitigation), `onRetry` callback emitting `console.error()` warnings and `tracer.emit({ type: 'retry', attempt, taskLabel, errorCode })` events.

## Subprocess Logging

**private enqueueSubprocessLog(result: SubprocessResult, taskLabel: string): void** — Fire-and-forget serialized write via `logWriteQueue` promise chain, sanitizes taskLabel by replacing `/` with `--` and non-alphanumeric chars with `_`, writes `${sanitized}_pid${childPid}.log` containing metadata header (task/pid/command/exit/signal/duration/timed_out) plus stdout/stderr sections, silently swallows errors (log loss acceptable).

## Debug Output

When `debug=true`, `call()` logs to stderr before spawn (active count, heap/RSS via `formatBytes()`, timeout), after exit (PID, exitCode, duration, active count), plus timeout warnings showing elapsed time exceeding configured `timeoutMs`.

**function formatBytes(bytes: number): string** — Human-readable byte formatting with B/KB/MB units.

## Telemetry Accumulation

**private readonly logger: TelemetryLogger** — In-memory accumulator instantiated with `runId = new Date().toISOString()`.

**private callCount: number = 0** — Running total of `call()` invocations.

**private activeSubprocesses: number = 0** — Tracks concurrent subprocess count for debug logging.

**private subprocessLogDir: string | null = null** — Optional directory for subprocess output logs.

**private logWriteQueue: Promise<void> = Promise.resolve()** — Serializes `mkdir()` and `writeFile()` operations to prevent race conditions from concurrent workers.

## Dependencies

Imports `AIBackend`, `AICallOptions`, `AIResponse`, `SubprocessResult`, `TelemetryEntry`, `RunLog`, `FileRead`, `AIServiceError` from `./types.js`; `runSubprocess` from `./subprocess.js`; `withRetry`, `DEFAULT_RETRY_OPTIONS` from `./retry.js`; `TelemetryLogger` from `./telemetry/logger.js`; `writeRunLog` from `./telemetry/run-log.js`; `cleanupOldLogs` from `./telemetry/cleanup.js`; `ITraceWriter` from `../orchestration/trace.js`; `writeFile`, `mkdir` from `node:fs/promises`; `path` from `node:path`.

## Integration Pattern

Used by `src/orchestration/runner.ts` which creates one `AIService` instance per CLI command execution, calls `setTracer()` and `setDebug()` based on CLI flags, invokes `call()` for each file/directory/root task via worker pool or sequential executor, calls `addFilesReadToLastEntry()` after each call to attach file metadata from prompt builder, calls `finalize()` at end of run to persist telemetry and enforce retention limits.