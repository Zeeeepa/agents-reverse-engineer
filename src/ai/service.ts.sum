---
generated_at: 2026-02-09T15:06:45.101Z
content_hash: 232da2af981eb6c44ab5f5e8908ea14d6ee97fe4295f950b83f42ee45e40a95a
purpose: AIService orchestrates AI CLI subprocess invocations with retry logic, timeout enforcement, telemetry logging, and tr...
---
**AIService orchestrates AI CLI subprocess invocations with retry logic, timeout enforcement, telemetry logging, and trace emission for concurrent worker pools.**

## Exported Symbols

**AIServiceOptions** interface defines service configuration with `timeoutMs: number`, `maxRetries: number`, `model?: string`, and `telemetry: { keepRuns: number }`.

**AIService** class provides `constructor(backend: AIBackend, options: AIServiceOptions)`, `call(options: AICallOptions): Promise<AIResponse>`, `finalize(projectRoot: string): Promise<{ logPath: string; summary: RunLog['summary'] }>`, `setTracer(tracer: ITraceWriter): void`, `setDebug(enabled: boolean): void`, `setSubprocessLogDir(dir: string): void`, `addFilesReadToLastEntry(filesRead: FileRead[]): void`, and `getSummary(): RunLog['summary']`.

## Core Orchestration Flow

AIService.call() executes: (1) builds CLI args via `AIBackend.buildArgs()`, (2) wraps `runSubprocess()` in `withRetry()` exponential backoff, (3) parses response via `AIBackend.parseResponse()`, (4) records `TelemetryEntry` via `TelemetryLogger.addEntry()`, (5) throws `AIServiceError` on failure with codes `TIMEOUT`/`RATE_LIMIT`/`PARSE_ERROR`/`SUBPROCESS_ERROR`.

Model resolution merges service-level default (`options.model`) with per-call override (`AICallOptions.model`) via spread operator: `effectiveOptions = { ...options, model: options.model ?? this.options.model }`.

## Rate Limit Detection

`isRateLimitStderr()` scans stderr against `RATE_LIMIT_PATTERNS` array containing `['rate limit', '429', 'too many requests', 'overloaded']` via case-insensitive substring matching.

`withRetry()` uses custom `isRetryable` predicate allowing only `AIServiceError` with `code === 'RATE_LIMIT'`. Timeouts (`code === 'TIMEOUT'`) are NOT retried to prevent resource exhaustion on overloaded systems.

## Subprocess Lifecycle Tracing

`call()` increments `activeSubprocesses` counter before `runSubprocess()`, decrements on completion, emits `subprocess:spawn` trace event via `onSpawn` callback with `childPid` synchronously available, emits `subprocess:exit` trace event after completion with `exitCode`, `signal`, `durationMs`, `timedOut` fields.

Retry attempts emit `retry` trace event with `attempt`, `taskLabel`, `errorCode` via `withRetry()` `onRetry` callback.

## Telemetry Recording

`TelemetryLogger` accumulates `TelemetryEntry[]` in-memory during run. Each `call()` invocation appends entry with `timestamp`, `prompt`, `systemPrompt`, `response`, `model`, `inputTokens`, `outputTokens`, `cacheReadTokens`, `cacheCreationTokens`, `latencyMs`, `exitCode`, `retryCount`, `thinking: 'not supported'`, `filesRead: []`.

Failed calls record `error: string` field with `response: ''` and `exitCode: 1`.

`addFilesReadToLastEntry()` mutates most recent entry's `filesRead` array via `TelemetryLogger.setFilesReadOnLastEntry()` after prompt context is determined.

`finalize()` calls `TelemetryLogger.toRunLog()` → `writeRunLog(projectRoot, runLog)` → `cleanupOldLogs(projectRoot, keepRuns)` returning `{ logPath, summary }`.

## Debug and Diagnostic Logging

`setDebug(true)` enables stderr logging before subprocess spawn showing `taskLabel`, `activeSubprocesses`, `heapUsed`, `rss`, `timeout` via `formatBytes()` conversion and after exit showing `childPid`, `exitCode`, `duration`, `activeSubprocesses`.

`setSubprocessLogDir()` enables per-subprocess `.log` file writes via `enqueueSubprocessLog()` serialized through promise chain `logWriteQueue` to prevent concurrent `mkdir()` races. Log filename sanitizes `taskLabel` replacing `/` with `--` and non-alphanumerics with `_`, writes metadata header with `task`, `pid`, `command`, `exit`, `signal`, `duration`, `timed_out` followed by `--- stdout ---` and `--- stderr ---` sections.

Timeout warnings logged via `console.error()` showing `taskLabel`, `PID`, `durationMs`, configured `timeoutMs`.

## Dependencies

Imports `runSubprocess()` from `./subprocess.js` for `execFile()` wrapper with timeout/retry handling, `withRetry()` and `DEFAULT_RETRY_OPTIONS` from `./retry.js` for exponential backoff, `TelemetryLogger` from `./telemetry/logger.js` for entry accumulation, `writeRunLog()` from `./telemetry/run-log.js` for disk persistence, `cleanupOldLogs()` from `./telemetry/cleanup.js` for retention enforcement, `ITraceWriter` from `../orchestration/trace.js` for NDJSON event emission.

Uses types `AIBackend`, `AICallOptions`, `AIResponse`, `SubprocessResult`, `TelemetryEntry`, `RunLog`, `FileRead`, `AIServiceError` from `./types.js`.

## State Management

Instance fields: `backend: AIBackend` (CLI adapter), `options: AIServiceOptions` (config), `logger: TelemetryLogger` (in-memory entries), `callCount: number` (incremented per `call()`), `tracer: ITraceWriter | null` (optional trace sink), `debug: boolean` (stderr logging toggle), `activeSubprocesses: number` (concurrency metric), `subprocessLogDir: string | null` (diagnostic output path), `logWriteQueue: Promise<void>` (serialization chain).