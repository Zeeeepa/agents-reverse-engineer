---
generated_at: 2026-02-09T21:28:55.695Z
content_hash: 232da2af981eb6c44ab5f5e8908ea14d6ee97fe4295f950b83f42ee45e40a95a
purpose: AIService orchestrates AI CLI invocations with subprocess management, exponential backoff retry, telemetry recording,...
---
**AIService orchestrates AI CLI invocations with subprocess management, exponential backoff retry, telemetry recording, and trace emission.**

## Exported Class

`AIService` — Main orchestrator for AI calls with retry logic, timeout enforcement, and telemetry aggregation.

**Constructor signature:**
```typescript
constructor(backend: AIBackend, options: AIServiceOptions)
```

**Public methods:**
- `async call(options: AICallOptions): Promise<AIResponse>` — Execute AI call with retry and telemetry recording
- `async finalize(projectRoot: string): Promise<{ logPath: string; summary: RunLog['summary'] }>` — Write run log to disk and cleanup old logs
- `setTracer(tracer: ITraceWriter): void` — Attach trace writer for subprocess/retry event emission
- `setDebug(enabled: boolean): void` — Enable verbose subprocess logging to stderr
- `setSubprocessLogDir(dir: string): void` — Set directory for writing subprocess stdout/stderr log files
- `addFilesReadToLastEntry(filesRead: FileRead[]): void` — Attach file-read metadata to most recent telemetry entry
- `getSummary(): RunLog['summary']` — Get current run summary without finalizing

## Configuration Types

`AIServiceOptions` interface with fields:
- `timeoutMs: number` — Default subprocess timeout in milliseconds
- `maxRetries: number` — Maximum retry attempts for transient errors
- `model?: string` — Default model identifier applied to all calls unless overridden per-call
- `telemetry.keepRuns: number` — Number of most recent run logs to keep on disk

## Call Flow

`call()` method executes:
1. Merge service-level `model` with per-call `options.model` (per-call wins)
2. Build CLI args via `backend.buildArgs(effectiveOptions)`
3. Wrap subprocess invocation in `withRetry()` with `DEFAULT_RETRY_OPTIONS` and `maxRetries` from service options
4. Increment `activeSubprocesses` counter before spawn, decrement after completion
5. Invoke `runSubprocess(backend.cliCommand, args, { timeoutMs, input: options.prompt, onSpawn })` with `onSpawn` callback emitting `subprocess:spawn` trace event
6. Emit `subprocess:exit` trace event after completion with `childPid`, `exitCode`, `signal`, `durationMs`, `timedOut` fields
7. Enqueue non-critical subprocess log write via `enqueueSubprocessLog()` promise chain
8. If `result.timedOut`, throw `AIServiceError('TIMEOUT', 'Subprocess timed out')`
9. If `exitCode !== 0`, check `isRateLimitStderr(result.stderr)` → throw `AIServiceError('RATE_LIMIT', ...)` or `AIServiceError('SUBPROCESS_ERROR', ...)`
10. Parse response via `backend.parseResponse(result.stdout, result.durationMs, result.exitCode)`, catch errors and wrap in `AIServiceError('PARSE_ERROR', ...)`
11. On success: record telemetry entry via `logger.addEntry()` with token counts, latency, retry count
12. On failure: record telemetry entry with error message and latency
13. Return `AIResponse` or rethrow error

## Retry Strategy

`withRetry()` invoked with custom `isRetryable` predicate:
- **Retryable:** `AIServiceError` with `code === 'RATE_LIMIT'` only
- **Non-retryable:** All other errors including `TIMEOUT`, `SUBPROCESS_ERROR`, `PARSE_ERROR`

Rationale (from inline comment): "Timeouts are NOT retried because spawning another heavyweight subprocess on a system that's already struggling (or against an unresponsive API) makes things worse and can exhaust system resources."

`onRetry` callback:
- Increments `retryCount` local variable
- Logs warning to stderr: `[warn] Retrying "${taskLabel}" (attempt ${attempt}/${this.options.maxRetries}, reason: ${errorCode})`
- Emits `retry` trace event with `attempt`, `taskLabel`, `errorCode` fields

## Rate Limit Detection

`isRateLimitStderr(stderr: string)` checks for patterns in `RATE_LIMIT_PATTERNS`:
- `"rate limit"`
- `"429"`
- `"too many requests"`
- `"overloaded"`

Case-insensitive substring matching via `stderr.toLowerCase().includes(pattern)`.

## Telemetry Recording

`TelemetryLogger` instance created in constructor with `new Date().toISOString()` as run timestamp.

`addEntry()` called on both success and failure paths with `TelemetryEntry` containing:
- `timestamp`, `prompt`, `systemPrompt`, `response`, `model`
- `inputTokens`, `outputTokens`, `cacheReadTokens`, `cacheCreationTokens`
- `latencyMs`, `exitCode`, `retryCount`, `error` (on failure)
- `thinking: 'not supported'` (hardcoded constant)
- `filesRead: []` (populated via `addFilesReadToLastEntry()` by command runner after call completes)

`finalize()` workflow:
1. Call `logger.toRunLog()` to aggregate entries into `RunLog` structure
2. Write via `writeRunLog(projectRoot, runLog)` returning log file path
3. Cleanup via `cleanupOldLogs(projectRoot, options.telemetry.keepRuns)` to enforce retention limit
4. Return `{ logPath, summary: runLog.summary }`

## Debug Logging

When `debug` flag enabled via `setDebug(true)`:
- Pre-spawn: Log `[debug] Spawning subprocess for "${taskLabel}" (active: ${activeSubprocesses}, heapUsed: ${formatBytes(mem.heapUsed)}, rss: ${formatBytes(mem.rss)}, timeout: ${(timeoutMs / 1000).toFixed(0)}s)`
- Post-completion: Log `[debug] Subprocess exited for "${taskLabel}" (PID ${childPid ?? 'unknown'}, exitCode: ${exitCode}, duration: ${(durationMs / 1000).toFixed(1)}s, active: ${activeSubprocesses})`

Memory stats retrieved via `process.memoryUsage()` with `heapUsed` and `rss` fields formatted via `formatBytes()`.

## Subprocess Output Logging

`setSubprocessLogDir(dir)` enables logging of subprocess stdout/stderr to individual `.log` files.

`enqueueSubprocessLog(result, taskLabel)` private method:
- Sanitizes `taskLabel` via `.replace(/\//g, '--').replace(/[^a-zA-Z0-9._-]/g, '_')`
- Generates filename: `${sanitized}_pid${result.childPid ?? 0}.log`
- Serializes writes via `logWriteQueue` promise chain to prevent concurrent mkdir races
- Writes header with `task`, `pid`, `command`, `exit`, `signal`, `duration`, `timed_out` metadata followed by stdout and stderr sections
- Failures silently swallowed (fire-and-forget pattern, log loss acceptable)

## State Management

Instance fields:
- `backend: AIBackend` — Resolved backend adapter from registry
- `options: AIServiceOptions` — Service configuration
- `logger: TelemetryLogger` — In-memory telemetry accumulator
- `callCount: number` — Running count of calls made (initialized to 0)
- `tracer: ITraceWriter | null` — Trace writer for concurrency debugging (null until `setTracer()` called)
- `debug: boolean` — Debug mode flag (default false)
- `activeSubprocesses: number` — Count of currently active subprocesses (incremented before spawn, decremented after completion)
- `subprocessLogDir: string | null` — Directory for subprocess logs (null = disabled)
- `logWriteQueue: Promise<void>` — Promise chain for serializing subprocess log writes (initialized to `Promise.resolve()`)

## Helper Functions

`formatBytes(bytes: number): string` — Human-readable byte formatting with thresholds:
- `< 1024` → `${bytes}B`
- `< 1024 * 1024` → `${(bytes / 1024).toFixed(1)}KB`
- `≥ 1024 * 1024` → `${(bytes / (1024 * 1024)).toFixed(1)}MB`

## Dependencies

Imports from project modules:
- `./types.js` — `AIBackend`, `AICallOptions`, `AIResponse`, `SubprocessResult`, `TelemetryEntry`, `RunLog`, `FileRead`, `AIServiceError`
- `./subprocess.js` — `runSubprocess`
- `./retry.js` — `withRetry`, `DEFAULT_RETRY_OPTIONS`
- `./telemetry/logger.js` — `TelemetryLogger`
- `./telemetry/run-log.js` — `writeRunLog`
- `./telemetry/cleanup.js` — `cleanupOldLogs`
- `../orchestration/trace.js` — `ITraceWriter`

Node.js built-ins:
- `node:fs/promises` — `writeFile`, `mkdir`
- `node:path` — Path manipulation for subprocess log filenames