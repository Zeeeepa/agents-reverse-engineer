<!-- Generated by agents-reverse-engineer v0.9.10 -->

# src/ai/providers

This directory contains provider implementations that wrap AI backends into a consistent interface. Currently hosts `SubprocessProvider`, which adapts CLI-based backends to the `AIProvider` contract with subprocess lifecycle management, timeout enforcement, and rate-limit detection.

## Contents

- [subprocess.ts](./subprocess.ts) – `SubprocessProvider` class wrapping `AIBackend` instances; spawns subprocess with `call(options: AICallOptions)`, detects rate limits via `isRateLimitStderr()`, enforces timeouts, and writes structured logs asynchronously via `setSubprocessLogDir()`.

## Architecture

`SubprocessProvider` implements `AIProvider` by delegating to `AIBackend` (injected via constructor). The call flow is: `call(AICallOptions)` → build args via `backend.buildArgs()` → invoke `runSubprocess()` with timeout enforcement → parse `SubprocessResult` → throw on error or return `AIResponse`. Rate-limit detection intercepts stderr before error propagation.

## Rate-Limit Detection & Error Handling

Rate limits are identified by `RATE_LIMIT_PATTERNS` (case-insensitive substring matches: `'rate limit'`, `'429'`, `'too many requests'`, `'overloaded'`). `isRateLimitStderr()` returns true if any pattern matches; matching triggers `AIServiceError('RATE_LIMIT', ...)`. Non-rate-limit errors throw `AIServiceError` with `'TIMEOUT'`, `'SUBPROCESS_ERROR'`, or `'PARSE_ERROR'` codes. Stderr/stdout truncated to 200–500 characters in error messages.

## Subprocess Lifecycle & Tracing

`call()` emits two structured trace events via optional `tracer: ITraceWriter`:
- `subprocess:spawn` with `{type, childPid, command, taskLabel}`
- `subprocess:exit` with `{type, childPid, command, taskLabel, exitCode, signal, durationMs, timedOut}`

Debug mode (`debug: true`) logs heap snapshots (`heapUsed`, `rss`) before spawn and exit code/duration after exit. `activeCount` tracks concurrent subprocess count for memory profiling.

## Logging & File I/O

`setSubprocessLogDir(dir: string)` enables per-subprocess log files. Logs are queued and written serially via `logWriteQueue: Promise<void>` (chained promises prevent concurrent writes). Log format: metadata section (`task`, `pid`, `command`, `exit`, `signal`, `duration`, `timed_out`), then `--- stdout ---` and `--- stderr ---` sections. Task labels are sanitized for filenames (replace `/` with `--`, strip non-alphanumeric except `.`, `_`, `-`). Write failures are silently ignored.

## Configuration

`SubprocessProviderOptions` defines: `timeoutMs: number` (required; passed to `runSubprocess`), `debug?: boolean`, `logger?: Logger`, `tracer?: ITraceWriter | null`. Timeout enforcement is critical for preventing hung subprocesses.