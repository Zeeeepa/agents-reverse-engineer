<!-- Generated by agents-reverse-engineer v1.1.0 -->

# src/ai/providers

Concrete `AIProvider` implementation that spawns AI CLI subprocesses via backend-specific command construction, enforcing timeout/rate-limit/trace contracts from the `src/ai/` abstraction layer.

## Contents

- [**subprocess.ts**](./subprocess.ts): `SubprocessProvider` implements `AIProvider` by invoking `runSubprocess` with `AIBackend`-constructed commands, enforcing `timeoutMs` via signal escalation, detecting rate limits via `RATE_LIMIT_PATTERNS` stderr matching, emitting `subprocess:spawn`/`subprocess:exit` trace events, optionally logging stdout/stderr to `{taskLabel}_pid{childPid}.log` when `setSubprocessLogDir` configured.

## Architecture

`SubprocessProvider` acts as the runtime bridge between `src/ai/service.ts` (which calls `provider.call`) and `src/ai/subprocess.ts` (which handles process lifecycle). Constructor accepts an `AIBackend` (from `src/ai/backends/`) and `SubprocessProviderOptions` (timeout, debug, logger, tracer). `call` method flow: (1) invoke `backend.buildCommand` to construct CLI args, (2) optionally call `backend.composeStdinInput` to format prompt, (3) spawn via `runSubprocess`, (4) parse response via `backend.parseResponse`, (5) emit trace events, (6) write optional subprocess logs to disk via queued promise chain.

## Error Handling

Non-zero exit codes throw `AIServiceError` with type `'RATE_LIMIT'` (stderr matches `RATE_LIMIT_PATTERNS`), `'SUBPROCESS_ERROR'` (other non-zero exit), `'TIMEOUT'` (process killed), or `'PARSE_ERROR'` (response parsing fails). Rate-limit detection regex: `['rate limit', '429', 'too many requests', 'overloaded']` (case-insensitive). Log writes to `subprocessLogDir` serialized via `logWriteQueue` promise chain; write failures silently ignored (non-critical).

## Behavioral Contracts

**Rate-limit patterns**: `RATE_LIMIT_PATTERNS = ['rate limit', '429', 'too many requests', 'overloaded']` (case-insensitive stderr match).

**Subprocess log filename**: `${taskLabel.replace(/\//g, '--').replace(/[^a-zA-Z0-9._-]/g, '_')}_pid${childPid}.log`.

**Subprocess log structure**:
```
task: {taskLabel}
pid: {childPid}
command: {command.join(' ')}
exit: {exitCode}
signal: {signal}
duration: {durationMs}ms
timed_out: {timedOut}

--- stdout ---
{stdout}

--- stderr ---
{stderr}
```

**Trace events**:
- `subprocess:spawn`: `{ childPid, command, taskLabel }` (on process start)
- `subprocess:exit`: `{ childPid, command, taskLabel, exitCode, signal, durationMs, timedOut }` (on termination)

## Implementation Details

`activeCount` tracks concurrent subprocess count for debug logs. `formatBytes` converts byte counts to B/KB/MB for memory usage logging. `composeStdinInput` uses `backend.composeStdinInput` if defined, else passes raw `options.prompt`. Debug logs include `process.memoryUsage()` heap/RSS, active count, timeout duration. `setTracer` enables late binding of `ITraceWriter` after construction. `setSubprocessLogDir` activates disk logging, initializing `logWriteQueue` to `Promise.resolve()`.