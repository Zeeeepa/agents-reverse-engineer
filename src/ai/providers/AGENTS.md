<!-- Generated by agents-reverse-engineer -->

# src/ai/providers

Subprocess-based AIProvider implementation spawning CLI tools (`claude`, `gemini`, `opencode`) with timeout enforcement, rate-limit detection, trace emission, and optional fire-and-forget output logging.

## Contents

**[subprocess.ts](./subprocess.ts)** — `SubprocessProvider` implements `AIProvider` interface by wrapping `AIBackend` instances. `call(options: AICallOptions)` spawns CLI subprocesses via `runSubprocess()`, emits `subprocess:spawn`/`subprocess:exit` trace events, detects rate-limit errors via `RATE_LIMIT_PATTERNS` stderr matching, throws `AIServiceError` on timeout/exit-failure/parse-failure. `setSubprocessLogDir(dir)` enables serialized per-task log writes (`${taskLabel}_pid${childPid}.log`) via `logWriteQueue` promise chain. `activeCount` tracker monitors concurrent subprocess population for debug logging.

## Architecture

**Subprocess Lifecycle**: `call()` invokes `backend.buildArgs(options)` to construct CLI arguments, passes to `runSubprocess(backend.cliCommand, args, { timeoutMs, input, onSpawn })`. `onSpawn` callback emits trace event with `childPid`, `command`, `taskLabel`. Post-execution emits trace event with `exitCode`, `signal`, `durationMs`, `timedOut` flag. Success path calls `backend.parseResponse(stdout, durationMs, exitCode)` to build `AIResponse`.

**Error Classification**: `result.timedOut` → `AIServiceError('TIMEOUT')`. Non-zero `result.exitCode` triggers `isRateLimitStderr(stderr)` check: match → `AIServiceError('RATE_LIMIT')` with 200-char stderr excerpt, else `AIServiceError('SUBPROCESS_ERROR')` with 500-char excerpt. Parse exceptions wrapped in `AIServiceError('PARSE_ERROR')`.

**Debug Logging**: When `debug: true`, logs subprocess spawn with `taskLabel`, `activeCount`, `formatBytes(heapUsed)`, `formatBytes(rss)`, `timeout` via `logger.debug()`. Post-exit logs `childPid`, `exitCode`, `durationMs`, `activeCount`.

**Output Persistence**: `setSubprocessLogDir(dir)` enables `enqueueSubprocessLog(result, taskLabel)` after each subprocess exit. Sanitizes `taskLabel` (`/` → `--`, non-alphanumeric → `_`), serializes writes via `logWriteQueue` promise chain to `${sanitized}_pid${childPid}.log` with sections: task, pid, command, exit code, signal, duration, timedOut flag, stdout, stderr. Failures silently swallowed.

## Behavioral Contracts

### Rate-Limit Detection Patterns
```typescript
RATE_LIMIT_PATTERNS = ['rate limit', '429', 'too many requests', 'overloaded']
```
Lowercase substring matching via `isRateLimitStderr(stderr)`: `RATE_LIMIT_PATTERNS.some(p => stderr.toLowerCase().includes(p))`.

### Active Subprocess Tracking
```typescript
activeCount++  // Pre-spawn
runSubprocess(...)
activeCount--  // Post-spawn (finally block)
```

### Trace Event Schema
```typescript
// Spawn event
{ type: 'subprocess:spawn', childPid, command, taskLabel }

// Exit event
{ type: 'subprocess:exit', childPid, command, taskLabel, exitCode, signal, durationMs, timedOut }
```

### Log File Naming
```typescript
taskLabel.replace(/\//g, '--').replace(/[^a-zA-Z0-9_-]/g, '_') + `_pid${childPid}.log`
```

### Memory Formatting
```typescript
formatBytes(bytes: number): string
  < 1024 → `${bytes}B`
  < 1024*1024 → `${(bytes/1024).toFixed(1)}KB`
  else → `${(bytes/(1024*1024)).toFixed(1)}MB`
```

## Dependencies

Imports `runSubprocess()` from `../subprocess.js` (SIGTERM/SIGKILL timeout escalation), `AIServiceError` from `../types.js` (typed error codes), `nullLogger` from `../../core/logger.js` (no-op fallback). Requires `AIBackend` implementations (`../backends/claude.ts`, `../backends/gemini.ts`, `../backends/opencode.ts`) providing `cliCommand`, `name`, `buildArgs(options)`, `parseResponse(stdout, durationMs, exitCode)`.