<!-- Generated by agents-reverse-engineer -->

# src/update/

**Orchestrates incremental documentation updates by comparing SHA-256 content hashes from `.sum` YAML frontmatter against current file content, removing orphaned artifacts from deleted/renamed sources, and regenerating `AGENTS.md` for affected directories in post-order depth traversal.**

## Contents

### Core Orchestration

**[index.ts](./index.ts)** — Barrel export exposing `UpdateOrchestrator` class with `createUpdateOrchestrator()` factory, cleanup utilities (`cleanupOrphans`, `cleanupEmptyDirectoryDocs`, `getAffectedDirectories`), and TypeScript interfaces for update workflow (`UpdateOptions`, `UpdateResult`, `UpdateProgress`, `CleanupResult`).

**[orchestrator.ts](./orchestrator.ts)** — Implements `UpdateOrchestrator` class coordinating hash-based change detection via `preparePlan()` method: calls `readSumFile()` to extract `content_hash` from frontmatter, invokes `computeContentHash()` for current SHA-256, pushes mismatches to `filesToAnalyze: FileChange[]` with `status: 'modified'|'added'`, populates `filesToSkip[]` on hash equality, computes `affectedDirs` sorted by `path.sep.length` descending for deepest-first regeneration, emits trace events (`phase:start/end`, `plan:created`) via optional `ITraceWriter`.

**[orphan-cleaner.ts](./orphan-cleaner.ts)** — Exports `cleanupOrphans()` function processing `FileChange[]` with `status === 'deleted'|'renamed'` to remove stale `.sum` files via `deleteIfExists()`, `cleanupEmptyDirectoryDocs()` predicate filtering directories against `GENERATED_FILES` constant and deleting `AGENTS.md` when no source files remain, `getAffectedDirectories()` computing parent paths via recursive `path.dirname()` traversal until reaching `'.'` or absolute boundary.

**[types.ts](./types.ts)** — Declares interfaces: `CleanupResult` with `deletedSumFiles/deletedAgentsMd` arrays, `UpdateOptions` with `includeUncommitted/dryRun` flags, `UpdateResult` tracking `analyzedFiles/skippedFiles/cleanup/regeneratedDirs/baseCommit/currentCommit`, `UpdateProgress` callback signatures (`onFileStart/onFileDone/onCleanup/onDirRegenerate`).

## Algorithm Flow

**Phase 1: Plan Creation**
1. `UpdateOrchestrator.preparePlan()` calls `runDiscovery()` from `src/discovery/run.ts` to enumerate source files
2. For each discovered file: compute `getSumPath()`, call `readSumFile()` to extract `content_hash`, compare against `computeContentHash(filePath)`
3. Hash mismatch → push to `filesToAnalyze` with `status: 'modified'` or `'added'` (missing `.sum`)
4. Hash match → push to `filesToSkip`
5. Invoke `cleanupOrphans()` with `FileChange[]` from `src/change-detection/detector.ts` containing `status: 'deleted'|'renamed'`
6. Call `getAffectedDirectories()` on `filesToAnalyze` to compute parent paths needing `AGENTS.md` regeneration
7. Sort `affectedDirs` by depth descending via `split(path.sep).length` for post-order traversal
8. Return `UpdatePlan` with file/directory task counts, `isFirstRun` boolean (`filesToSkip.length === 0`)

**Phase 2: Execution** (via `src/cli/update.ts`)
1. Regenerate `.sum` files for `filesToAnalyze` using worker pool from `src/orchestration/pool.ts`
2. Regenerate `AGENTS.md` for `affectedDirs` sequentially (no parallel directory processing)
3. Report `UpdateResult` with analyzed/skipped counts, orphaned artifact paths, regenerated directory list

## Integration Points

**Consumed by:** `src/cli/update.ts` command handler constructs `UpdateOrchestrator` via factory, calls `checkPrerequisites()` to validate git repository, invokes `preparePlan()` to build task list, executes regeneration phases, reports results via `src/output/logger.ts`.

**Depends on:**
- `src/change-detection/index.ts` — `isGitRepo()`, `getCurrentCommit()`, `computeContentHash()`, `FileChange` type
- `src/generation/writers/sum.ts` — `readSumFile()` extracting YAML frontmatter, `getSumPath()` computing `.sum` artifact location
- `src/discovery/run.ts` — `discoverFiles()` for file enumeration with gitignore/binary/vendor filters
- `src/orchestration/trace.ts` — `ITraceWriter` interface for event emission during plan creation

## Change Detection Strategy

**Hash-based (current):** Compares SHA-256 digests from `.sum` frontmatter against current file content. No git dependency for change detection itself, though `checkPrerequisites()` still validates git repository presence for `getCurrentCommit()` legacy field population. Handles non-git workflows via pure filesystem content hashing.

**Rename handling:** Processes `FileChange.oldPath` for `status === 'renamed'` to delete orphaned `.sum` at previous location while new location triggers regeneration. Prevents duplicate artifacts when git detects moves via `-M` similarity threshold.

**Affected directory computation:** Recursively walks parent paths via `path.dirname()` without filesystem I/O, collects all ancestors in `Set<string>` to ensure nested structures regenerate parent `AGENTS.md` files referencing child summaries.

## API Compatibility

Preserves no-op methods from previous database-backed implementation: `recordFileAnalyzed()`, `removeFileState()`, `recordRun()`, `getLastRun()`, `isFirstRun()` (returns `false` stub), `close()`. Comments indicate "no-op in frontmatter mode" and "kept for API compatibility". Future refactoring may remove unused interface surface.