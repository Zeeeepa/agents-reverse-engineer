<!-- Generated by agents-reverse-engineer v0.8.2 -->

# src/update

Incremental update subsystem: frontmatter-based staleness detection, orphan cleanup (stale `.sum`/`.annex.sum` deletion, empty directory `AGENTS.md` removal), affected directory aggregation for selective regeneration.

## Contents

**[index.ts](./index.ts)** — Barrel export: `UpdateOrchestrator` (alias for `DocumentationOrchestrator`), `createUpdateOrchestrator`, `UpdatePlan` from `../orchestration/orchestrator.js`, `cleanupOrphans`, `cleanupEmptyDirectoryDocs`, `getAffectedDirectories` from `orphan-cleaner.ts`, type exports `UpdateOptions`, `UpdateResult`, `UpdateProgress`, `CleanupResult`.

**[orphan-cleaner.ts](./orphan-cleaner.ts)** — `cleanupOrphans()` deletes `.sum`/`.annex.sum` for deleted/renamed files via `deleteIfExists()`, invokes `cleanupEmptyDirectoryDocs()` on affected parent directories, returns `CleanupResult`. `cleanupEmptyDirectoryDocs()` checks `hasSourceFiles` (excludes `GENERATED_FILES`, dotfiles, `.sum` suffixes), deletes `AGENTS.md` when empty. `getAffectedDirectories()` collects parent directories from non-deleted `FileChange[]` via `path.dirname()` walk. Dry-run support via boolean flag (simulates deletion without `unlink()`).

**[types.ts](./types.ts)** — `UpdateOptions` (`includeUncommitted?: boolean`, `dryRun?: boolean`), `UpdateResult` (`analyzedFiles`, `skippedFiles`, `cleanup: CleanupResult`, `regeneratedDirs`, `baseCommit`, `currentCommit`, `dryRun: boolean`), `UpdateProgress` callback interface (`onFileStart`, `onFileDone`, `onCleanup`, `onDirRegenerate`), `CleanupResult` (`deletedSumFiles: string[]`, `deletedAgentsMd: string[]`).

## Architecture

### Orphan Cleanup Algorithm

1. **Sum Deletion**: Filters `FileChange[]` for `status === 'deleted'` or `status === 'renamed'` (uses `oldPath` for renames), constructs `.sum` path `${relativePath}.sum`, constructs `.annex.sum` via `path.join(parsed.dir, '${parsed.name}.annex.sum')`, calls `deleteIfExists()` on both, accumulates `deletedSumFiles`.

2. **Directory Cleanup**: Extracts `path.dirname()` from cleaned paths into `affectedDirs` Set (excludes `'.'`), calls `cleanupEmptyDirectoryDocs()` on each absolute directory path, accumulates `deletedAgentsMd` when deletion occurs.

3. **Empty Detection**: `cleanupEmptyDirectoryDocs()` reads directory via `readdir()`, tests `hasSourceFiles` by filtering `!entry.startsWith('.')` && `!entry.endsWith('.sum')` && `!GENERATED_FILES.has(entry)`, deletes `AGENTS.md` if no source files remain.

### Integration Points

**Orchestration**: Invoked by `src/orchestration/orchestrator.ts` `UpdateOrchestrator.preparePlan()` after phase-1 file regeneration. Receives `FileChange[]` from `src/change-detection/detector.ts` `detectChanges()`. Complements `getAffectedDirectories()` (returns directories needing regeneration for non-deleted files) with deletion-specific cleanup.

**Change Detection**: Consumes `FileChange` type from `../change-detection/types.js` containing `path`, `status` (`'added'|'modified'|'deleted'|'renamed'`), optional `oldPath` for renames.

## Behavioral Contracts

### Empty Directory Detection
```javascript
hasSourceFiles = entries.some(entry => 
  !entry.startsWith('.') && 
  !entry.endsWith('.sum') && 
  !GENERATED_FILES.has(entry)
)
// GENERATED_FILES = new Set(['AGENTS.md', 'CLAUDE.md'])
```

### Dry Run Semantics
```javascript
// deleteIfExists() with dryRun === true
stat(filePath)  // Check existence
// Skip unlink()
return exists   // Return true if exists (simulates deletion)
```

### Affected Directory Collection
```javascript
// getAffectedDirectories() accumulates parent paths
while (currentDir !== '.' && currentDir !== '') {
  affectedDirs.add(currentDir)
  currentDir = path.dirname(currentDir)
}
// Always includes '.' (root) when called from orchestrator
```