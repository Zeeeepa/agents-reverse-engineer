<!-- Generated by agents-reverse-engineer -->

# change-detection

Provides Git-based change detection and SHA-256 content hashing for the ARE incremental update workflow, powering `src/cli/update.ts` to identify files requiring `.sum` regeneration.

## Contents

### [detector.ts](./detector.ts)
Implements `isGitRepo()`, `getCurrentCommit()`, `getChangedFiles()`, `computeContentHash()`, and `computeContentHashFromString()` using simple-git and Node.js crypto. Parses `git diff --name-status -M` output to detect added/modified/deleted/renamed files between commits.

### [types.ts](./types.ts)
Exports `ChangeType`, `FileChange`, `ChangeDetectionResult`, and `ChangeDetectionOptions` interfaces. Defines discriminated union for change types and optional `includeUncommitted` flag controlling staged/working directory detection.

### [index.ts](./index.ts)
Barrel re-export of detector functions and types, serving as public API facade for git-based change tracking.

## Data Flow

1. `getChangedFiles(projectRoot, baseCommit, options)` calls `git diff --name-status -M` to retrieve commit-to-commit delta
2. Parses diff output using tab-split and status code mapping (`A`/`M`/`D`/`R*`)
3. When `includeUncommitted` is true, appends `git.status()` changes (staged/modified/untracked) with deduplication check
4. Returns `ChangeDetectionResult` containing `FileChange[]` array, currentCommit/baseCommit hashes, and includesUncommitted flag
5. `src/update/orchestrator.ts` consumes `FileChange.path` and `FileChange.oldPath` to determine which `.sum` files require regeneration

## Behavioral Contracts

### Diff Parsing Pattern
- **Line format**: `STATUS\tFILE` or `STATUS\tOLD\tNEW` (renames)
- **Status mapping**: `A` → added, `M` → modified, `D` → deleted, `R{similarity}` → renamed
- **Rename detection**: `-M` flag with 50% similarity threshold
- **Path resolution**: `parts[parts.length - 1]` always contains current/new path

### Content Hashing
- **Algorithm**: SHA-256 hex-encoded digest
- **Source**: `computeContentHash()` reads from disk, `computeContentHashFromString()` hashes in-memory content
- **Format**: `createHash('sha256').update(content).digest('hex')`

## Integration Points

- **Consumed by**: `src/update/orchestrator.ts` to determine incremental update scope
- **Stores baseline**: `.agents-reverse-engineer/update-state.json` tracks last processed commit via `ChangeDetectionResult.currentCommit`
- **Deduplication logic**: Checks `!changes.some(c => c.path === file)` before adding uncommitted changes when both committed and uncommitted sets overlap