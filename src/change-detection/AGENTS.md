<!-- Generated by agents-reverse-engineer -->

# src/change-detection/

Git-based change detection module for incremental documentation updates, using `simple-git` to compute file diffs between commits and SHA-256 hashing for content fingerprinting.

## Contents

### Core Implementation

- **[detector.ts](./detector.ts)** — Implements `isGitRepo()`, `getCurrentCommit()`, `getChangedFiles()` for parsing `git diff --name-status -M` output with rename detection, plus `computeContentHash()` and `computeContentHashFromString()` for SHA-256 content hashing
- **[types.ts](./types.ts)** — Defines `ChangeType` union (`'added' | 'modified' | 'deleted' | 'renamed'`), `FileChange` interface with `path`, `status`, and optional `oldPath` for renames, plus `ChangeDetectionResult` and `ChangeDetectionOptions` contracts
- **[index.ts](./index.ts)** — Barrel export re-exporting all functions and types from detector.ts and types.ts

## Git Diff Parsing

`getChangedFiles()` parses `git diff --name-status -M` with `-M` enabling 50% similarity threshold for rename detection. Output format: `STATUS\tFILE` for add/modify/delete, `STATUS\tOLD\tNEW` for renames. Maps status codes: `A` → `added`, `M` → `modified`, `D` → `deleted`, `R*` → `renamed`. When `options.includeUncommitted` is true, appends staged/working directory changes from `git.status()` with deduplication via `changes.some(c => c.path === file)` check.

## Integration Points

Consumed by `src/update/orchestrator.ts` to determine which `.sum` files require regeneration. `ChangeType` discriminator drives different strategies: `'deleted'` triggers orphan cleanup via `OrphanCleaner`, `'renamed'` maps `oldPath` → `path` for `.sum` file renaming, `'added'`/`'modified'` trigger `AIService` reanalysis. Also used by `src/cli/update.ts` to compute diff between `lastProcessedCommit` from state file and current `HEAD`.