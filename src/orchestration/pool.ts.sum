---
generated_at: 2026-02-09T21:29:44.882Z
content_hash: 42c09530c03faf24c901c3a010c351a0a9bdabf54d884aca3f1e01ecece26b8d
purpose: Iterator-based concurrency pool implementing shared-iterator worker pattern for zero-dependency concurrent task execu...
---
**Iterator-based concurrency pool implementing shared-iterator worker pattern for zero-dependency concurrent task execution with N-bounded parallelism, fail-fast abort semantics, and NDJSON trace emission.**

## Exported Interface

`runPool<T>(tasks, options, onComplete?)` executes array of async task factories through concurrency-limited pool. Returns `Promise<TaskResult<T>[]>` where results indexed by original task position. Parameters:
- `tasks: Array<() => Promise<T>>` — zero-argument async factory functions
- `options: PoolOptions` — pool configuration with required `concurrency: number`, optional `failFast?: boolean`, `tracer?: ITraceWriter`, `phaseLabel?: string`, `taskLabels?: string[]`
- `onComplete?: (result: TaskResult<T>) => void` — callback invoked after each task settles

`TaskResult<T>` discriminated by `success: boolean`, contains `index: number`, optional `value?: T` (when success true), optional `error?: Error` (when success false).

`PoolOptions` configures maximum `concurrency: number`, optional `failFast?: boolean` stops pulling new tasks on first error, optional `tracer?: ITraceWriter` for concurrency debugging (imported from `'./trace.js'`), optional `phaseLabel?: string` for trace events (example: `'phase-1-files'`), optional `taskLabels?: string[]` indexed by task position for trace event labels (example: file paths).

## Shared-Iterator Worker Pattern

All workers iterate over same `tasks.entries()` iterator. Each `worker()` consumes `[index, task]` pairs via `for...of` loop over shared iterator. JavaScript iterator protocol ensures each task picked up by exactly one worker (atomic `.next()` calls). When worker finishes task, immediately pulls next from iterator, keeping all worker slots busy without batch idle periods.

Effective concurrency capped via `Math.min(options.concurrency, tasks.length)` to prevent spawning more workers than tasks. Workers spawned via `Array.from({ length: effectiveConcurrency }, (_, workerId) => worker(iterator, workerId))` and awaited via `Promise.allSettled(workers)`.

## Abort Semantics

Shared `aborted` flag checked before pulling next task via `if (aborted) break` at loop start. Flag set when `options.failFast` true and task throws error via `aborted = true; break`. Workers in-flight during abort complete their current task before checking flag.

## Trace Event Emission

Emits trace events via `tracer?.emit()` optional chaining when `options.tracer` provided:
- `{ type: 'worker:start', workerId, phase }` at worker spawn
- `{ type: 'worker:end', workerId, phase, tasksExecuted }` at worker termination
- `{ type: 'task:pickup', workerId, taskIndex, taskLabel, activeTasks }` before task execution
- `{ type: 'task:done', workerId, taskIndex, taskLabel, durationMs, success, activeTasks, error? }` after task settles

Task labels resolved via `taskLabels?.[index] ?? 'task-${index}'`. Duration computed via `Date.now() - taskStart`. Global `activeTasks` counter incremented before execution, decremented after completion for snapshot visibility.

## Result Collection

Results array sparse-populated via `results[index] = result` to preserve task position. Returns `TaskResult<T>[]` where index correlates back to input task array position. Sparse array may contain holes when abort occurs before all tasks execute.

Error coercion via `err instanceof Error ? err : new Error(String(err))` normalizes non-Error throws.