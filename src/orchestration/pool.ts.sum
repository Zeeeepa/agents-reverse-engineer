---
generated_at: 2026-02-09T13:18:54.377Z
content_hash: 42c09530c03faf24c901c3a010c351a0a9bdabf54d884aca3f1e01ecece26b8d
purpose: pool.ts implements an iterator-based concurrency pool using the shared-iterator worker pattern to execute async tasks...
---
**pool.ts implements an iterator-based concurrency pool using the shared-iterator worker pattern to execute async tasks with exactly N concurrent workers, avoiding batch-style idling.**

## Exported Interface

- `runPool<T>(tasks: Array<() => Promise<T>>, options: PoolOptions, onComplete?: (result: TaskResult<T>) => void): Promise<TaskResult<T>[]>` - executes task factories through concurrency-limited worker pool, returns indexed results array
- `PoolOptions` - configuration interface with `concurrency: number`, `failFast?: boolean`, `tracer?: ITraceWriter`, `phaseLabel?: string`, `taskLabels?: string[]`
- `TaskResult<T>` - result wrapper with `index: number`, `success: boolean`, `value?: T`, `error?: Error`

## Concurrency Strategy

`runPool` uses `tasks.entries()` as shared iterator across all workers. Each worker pulls `[index, task]` pairs from the single iterator until exhausted, ensuring exactly one worker executes each task. When `worker()` completes a task, it immediately pulls the next entry from the iterator, keeping all worker slots busy without batch-style delays. The `effectiveConcurrency` is `Math.min(options.concurrency, tasks.length)` to avoid spawning idle workers.

## Abort and Fail-Fast

The `aborted` flag is set when `options.failFast` is true and any task throws. Workers check `if (aborted) break` before pulling the next task from the iterator. All workers are launched via `Promise.allSettled(workers)` so non-aborted workers can complete in-flight tasks even after abort is triggered.

## Tracing Integration

When `options.tracer` is provided, `worker()` emits:
- `worker:start` with `workerId` and `phase` at worker spawn
- `task:pickup` with `workerId`, `taskIndex`, `taskLabel` (from `options.taskLabels`), and `activeTasks` count when a task is pulled
- `task:done` with `workerId`, `taskIndex`, `taskLabel`, `durationMs`, `success`, optional `error`, and `activeTasks` when task settles
- `worker:end` with `workerId`, `phase`, and `tasksExecuted` when worker loop exits

The `activeTasks` counter increments before task execution and decrements after settling, providing real-time concurrency snapshots in trace events.

## Result Indexing

`runPool` returns `TaskResult<T>[]` where each result is stored at `results[index]` matching the original task's position in the input array. This allows callers to correlate results with inputs even when tasks complete out-of-order. The `onComplete` callback receives each `TaskResult<T>` immediately after the task settles, enabling progress reporting without waiting for all tasks to finish.

## Dependencies

Imports `ITraceWriter` from `./trace.js` for optional tracing. Zero external dependencies beyond TypeScript types.