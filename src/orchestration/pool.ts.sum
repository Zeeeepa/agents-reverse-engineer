---
generated_at: 2026-02-09T17:45:40.978Z
content_hash: 42c09530c03faf24c901c3a010c351a0a9bdabf54d884aca3f1e01ecece26b8d
purpose: pool.ts implements iterator-based concurrency limiting via shared-iterator worker pattern for parallel task execution...
---
**pool.ts implements iterator-based concurrency limiting via shared-iterator worker pattern for parallel task execution with configurable worker count, fail-fast abort, and optional trace emission.**

## Exported Functions

**runPool<T>(tasks, options, onComplete?): Promise<TaskResult<T>[]>**

Executes array of async task factories through concurrency-limited pool using shared iterator pattern where N workers pull from single `tasks.entries()` iterator. Each worker invokes tasks sequentially until iterator exhaustion or abort flag set. Returns array of `TaskResult<T>` indexed by original task position (may be sparse if aborted via fail-fast).

Parameters:
- `tasks: Array<() => Promise<T>>` — zero-argument async task factories
- `options: PoolOptions` — pool configuration (concurrency, failFast, tracer, phaseLabel, taskLabels)
- `onComplete?: (result: TaskResult<T>) => void` — optional callback invoked after each task settles

Worker lifecycle: emits `worker:start` with workerId and phase, iterates over shared iterator checking `aborted` flag before each pickup, emits `task:pickup` with `activeTasks` snapshot, awaits task execution, catches errors converting non-Error values via `String(err)`, emits `task:done` with `durationMs` and `success` boolean, invokes `onComplete` callback with result, sets `aborted=true` on error if `failFast` enabled, emits `worker:end` with `tasksExecuted` count.

Effective concurrency computed via `Math.min(options.concurrency, tasks.length)` to avoid spawning idle workers. All workers awaited via `Promise.allSettled()` ensuring completion even if individual workers reject.

## Types

**PoolOptions**
- `concurrency: number` — maximum concurrent workers
- `failFast?: boolean` — abort on first error (sets shared `aborted` flag preventing new task pickups)
- `tracer?: ITraceWriter` — trace writer for emit calls (no-op when undefined)
- `phaseLabel?: string` — phase identifier for trace events (defaults to `'unknown'`)
- `taskLabels?: string[]` — per-task labels indexed by task position (used in `task:pickup`/`task:done` events, falls back to `'task-${index}'`)

**TaskResult<T>**
- `index: number` — zero-based task position in original array
- `success: boolean` — settlement status
- `value?: T` — resolved value when `success=true`
- `error?: Error` — rejection error when `success=false`

## Concurrency Strategy

Shared-iterator pattern prevents "batch anti-pattern" where `Promise.all()` on fixed-size chunks idles workers waiting for slowest task in batch. Single `tasks.entries()` iterator consumed by all workers ensures each task picked exactly once, with workers immediately pulling next task upon completion maintaining full worker utilization until iterator exhaustion.

## Trace Events

Emits via `tracer?.emit()` optional chaining (no-op when tracer undefined):
- `worker:start` — `{ type, workerId, phase }`
- `task:pickup` — `{ type, workerId, taskIndex, taskLabel, activeTasks }`
- `task:done` — `{ type, workerId, taskIndex, taskLabel, durationMs, success, error?, activeTasks }`
- `worker:end` — `{ type, workerId, phase, tasksExecuted }`

`activeTasks` counter incremented at pickup, decremented at settlement, providing snapshot of concurrent task count at trace event emission time. Duration computed via `Date.now() - taskStart` without high-resolution timer.

## Abort Mechanism

Shared mutable `aborted` boolean flag checked at loop start (`for (const [index, task] of iterator) { if (aborted) break; }`). Set to `true` in catch block when `options.failFast` enabled, causing all workers to stop pulling new tasks. Workers already executing tasks run to completion before checking flag. Results array may be sparse with undefined indices for tasks never started due to abort.