---
generated_at: 2026-02-09T16:10:58.441Z
content_hash: 42c09530c03faf24c901c3a010c351a0a9bdabf54d884aca3f1e01ecece26b8d
purpose: Iterator-based concurrency pool implementing the shared-iterator worker pattern to execute N async tasks concurrently...
---
**Iterator-based concurrency pool implementing the shared-iterator worker pattern to execute N async tasks concurrently without idling workers between batches.**

## Exported Functions

`runPool<T>(tasks: Array<() => Promise<T>>, options: PoolOptions, onComplete?: (result: TaskResult<T>) => void): Promise<TaskResult<T>[]>` executes an array of async task factories through a concurrency-limited pool where all workers share a single `entries()` iterator. Each worker pulls the next task immediately after completing the previous one, ensuring all N worker slots stay busy until the iterator exhausts. Returns an array of `TaskResult<T>` indexed by original task position (may be sparse if `failFast` aborts early).

## Core Types

`PoolOptions` configures pool behavior with required `concurrency: number` (maximum concurrent workers), optional `failFast?: boolean` (stop pulling new tasks on first error), optional `tracer?: ITraceWriter` (emit trace events for debugging), optional `phaseLabel?: string` (phase identifier for trace events like `'phase-1-files'`), and optional `taskLabels?: string[]` (human-readable labels for each task by index, used in trace events).

`TaskResult<T>` represents a single task execution outcome with `index: number` (zero-based position in original array), `success: boolean` (completion status), optional `value?: T` (resolved value when `success: true`), and optional `error?: Error` (error when `success: false`).

## Worker Pattern Implementation

`runPool()` creates a shared `iterator` via `tasks.entries()` which yields `[index, taskFn]` tuples. Spawns `effectiveConcurrency = Math.min(options.concurrency, tasks.length)` workers, each invoking the internal `worker(iterator, workerId)` async function. Each worker iterates over the shared iterator via `for (const [index, task] of iterator)`, executing `await task()`, storing results in `results[index]`, invoking `onComplete?.(result)` callback, and checking `aborted` flag before pulling next task. Uses `Promise.allSettled(workers)` to wait for all workers to finish.

## Abort Mechanism

The shared mutable `aborted` boolean flag stops task pickup when `options.failFast` is true and any worker encounters an error. Workers check `if (aborted) break` before pulling the next task from the iterator, but do not interrupt already-running tasks.

## Trace Event Emission

Emits `worker:start` with `workerId`, `phase` when worker begins. Emits `task:pickup` with `workerId`, `taskIndex`, `taskLabel`, `activeTasks` when worker pulls a task. Emits `task:done` with `workerId`, `taskIndex`, `taskLabel`, `durationMs`, `success`, optional `error`, `activeTasks` when task settles. Emits `worker:end` with `workerId`, `phase`, `tasksExecuted` when worker exhausts iterator or aborts. The `activeTasks` counter increments before task execution and decrements after task settles, providing snapshot of concurrent task count.

## Error Handling

Catches task execution errors via try-catch, converts non-Error exceptions to Error via `err instanceof Error ? err : new Error(String(err))`, stores `TaskResult<T>` with `success: false` and `error` field. When `failFast: false` (default), worker continues pulling tasks after error. When `failFast: true`, worker sets `aborted = true` and breaks from iterator loop.

## Dependency on External Modules

Imports `ITraceWriter` from `'./trace.js'` (module-relative path with `.js` extension for ES module resolution). No runtime dependencies on external npm packages (zero-dependency concurrency limiter).

## Anti-Pattern Mitigation

Avoids batch-based concurrency where `Promise.all()` on N-sized chunks idles workers while waiting for the slowest task in each batch. The shared iterator ensures new tasks start immediately as workers become available, maximizing throughput.