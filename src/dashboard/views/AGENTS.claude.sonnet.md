<!-- Generated by agents-reverse-engineer v1.1.0 -->

# src/dashboard/views

Terminal-based presentation layer rendering telemetry data as formatted tables, charts, and timelines for cost/performance analysis via the `are dashboard` command.

## Contents

- [`entries.ts`](./entries.ts): `renderEntriesTable(log: RunLog)` — displays per-file call stats (tokens, latency, retries, errors) with outlier highlighting (P90+ latency yellow, retries >0 yellow, errors red, success green), summary footer (call count, error count, avg/P90 latency, token totals via `formatTokens`, cost breakdown via `computeCost`/`formatCost`), top-5 slowest calls sorted by descending `latencyMs`. `extractFileName` parses `filesRead[0].path` or regex captures `/File: (.+?)(?:\n|$)/` from prompt. `percentile` computes P90 via sorted array indexing `Math.ceil(p * sorted.length) - 1`.
- [`summary.ts`](./summary.ts): `renderSummaryTable(logs: RunLog[])` — renders tabular overview with columns Run ID (shortened via `shortRunId`, cyan), Backend, Model, Cmd, Files (`uniqueFilesRead`), Calls (`totalCalls`), In/Out Tok, Cache R/W, Duration, Errors (red if >0), Cost (yellow). Auto-sizes columns via `Math.max(header.length, ...row.values.map(v => v.length))`. Footer sums costs via `parseFloat(r.cost.replace('$', ''))` reduction.
- [`timeline.ts`](./timeline.ts): `renderTimeline(trace: ParsedTrace)` — renders ASCII Gantt charts (60-char width) showing phase-by-phase execution, per-worker task spans using glyphs `\u2593` (success medium shade) and `\u2591` (failure light shade), concurrency efficiency stats (speedup = `totalTaskMs / phase.durationMs`, utilization = `totalWorkerMs / (phase.durationMs * workers.length) * 100`). `renderPhase` displays up to 10 workers per phase. `colorPercent` applies green (≥80%), yellow (≥50%), red (<50%).
- [`trends.ts`](./trends.ts): `renderTrends(logs: RunLog[])` — aggregates telemetry by ISO date prefix (first 10 chars of `startTime`) via `aggregateByDate`, renders five sections: daily cost table (`renderDailyTable`), cache savings analysis (hypothetical input cost minus actual `cacheReadCost`), cost-per-file breakdown (`totalCost / uniqueFilesRead`), error rate bar chart (`renderErrorRate`: red U+2588 bars width = `(totalErrors / totalCalls) * 50`, green U+2713 if 0%), ASCII sparkline (`renderSparkline`: min-max normalized to U+2581–U+2588 block characters).

## Dependencies

All views import `RunLog` from `../../ai/types.js`, formatting utilities from `../cost-calculator.js` (`formatCost`, `formatTokens`, `formatDuration`, `computeCost`, `computeRunCost`, `CostBreakdown`), `shortRunId` from `../log-reader.js`, `picocolors` for terminal styling (`pc.bold`, `cyan`, `dim`, `red`, `green`, `yellow`). Timeline imports `ParsedTrace`, `PhaseTimeline`, `WorkerTimeline` from `../trace-reader.js`, `shortTraceId` for trace ID formatting.

## Behavioral Contracts

**Timeline Constants** (from `timeline.ts`):
- `BAR_WIDTH = 60` — fixed Gantt chart width
- Phase bar position: `Math.round((phase.startMs / totalMs) * BAR_WIDTH)`
- Task span length: `Math.max(1, Math.round((task.durationMs / totalMs) * BAR_WIDTH))`
- Success glyph: `\u2593` (medium shade)
- Failure glyph: `\u2591` (light shade)
- Worker display limit: 10 (overflow: `... and ${phase.workers.length - 10} more workers`)

**Trends Constants** (from `trends.ts`):
- Sparkline characters: U+2581 (lower one eighth block) to U+2588 (full block)
- Error rate bar width: `(errorRate / 2)` rounded down
- Bar character: U+2588 (full block)
- Success checkmark: U+2713

**Outlier Detection** (from `entries.ts`):
- P90 latency threshold: `percentile(entries.map(e => e.latencyMs), 0.9)`
- Retry highlight: `entry.retries > 0`
- Error highlight: `entry.error !== undefined`
- Success highlight: `entry.error === undefined && entry.retries === 0`

**File Name Extraction** (from `entries.ts`):
- Primary: `entry.filesRead[0].path`
- Fallback regex: `/File: (.+?)(?:\n|$)/` (group 1)
- Final fallback: `'(unknown)'`

**Cost Calculation** (from `summary.ts`, `trends.ts`):
- Per-run cost: `computeRunCost(log)` returns `CostBreakdown`
- Per-file cost: `totalCost / uniqueFilesRead`
- Cache savings: `(hypotheticalInputCost - actualCacheReadCost)`
- Aggregate cost: `logs.reduce((sum, log) => sum + parseFloat(computeRunCost(log).total.replace('$', '')), 0)`