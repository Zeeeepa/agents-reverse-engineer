<!-- Generated by agents-reverse-engineer -->

# src/quality/inconsistency

**Detects three classes of code-documentation drift: code-vs-doc (exports missing from .sum files), code-vs-code (duplicate symbol exports within directory scope), and phantom-paths (broken file references in AGENTS.md), aggregating findings into structured InconsistencyReport objects with plain-text CLI formatting.**

## Contents

### Detection Modules

**[code-vs-doc.ts](./code-vs-doc.ts)** — `extractExports()` extracts identifiers from TypeScript/JavaScript source via regex `/^[ \t]*export\s+(?:default\s+)?(?:function|class|const|let|var|type|interface|enum)\s+(\w+)/gm`, `checkCodeVsDoc()` compares extracted symbols against SumFileContent.summary substring presence, returns CodeDocInconsistency with `missingFromDoc[]` when exports absent from documentation.

**[code-vs-code.ts](./code-vs-code.ts)** — `checkCodeVsCode()` aggregates exports via `Map<string, string[]>` across scoped file group, returns CodeCodeInconsistency array flagging symbols exported from multiple files with `pattern: 'duplicate-export'` sentinel, relies on caller to enforce per-directory scoping.

**[reporter.ts](./reporter.ts)** — `buildInconsistencyReport()` aggregates Inconsistency discriminated union into InconsistencyReport with summary counts across type/severity dimensions, `formatReportForCli()` renders plain-text output without picocolors dependency for testability.

## File Relationships

code-vs-code.ts imports `extractExports()` from code-vs-doc.ts for shared regex-based export extraction. Both detection modules return type-specific inconsistency objects (CodeDocInconsistency, CodeCodeInconsistency) consumed by reporter.ts via Inconsistency discriminated union. Reporter aggregates findings from both modules into unified InconsistencyReport structure with metadata (timestamp, projectRoot, filesChecked, durationMs) and typed summary counts.

## Behavioral Contracts

### Export Extraction Regex
```regex
/^[ \t]*export\s+(?:default\s+)?(?:function|class|const|let|var|type|interface|enum)\s+(\w+)/gm
```
Captures identifiers from `export function`, `export const`, `export default class`, `export type`, `export interface`, `export enum`. Misses destructured exports (`export const { foo, bar } = obj`), namespace exports (`export * as ns`), re-exports (`export { foo } from './other'`), dynamic exports (`module.exports`), multi-line declarations.

### Inconsistency Type Discriminants
- `code-vs-doc`: requires `filePath`, `sumPath`, `details.missingFromDoc[]`
- `code-vs-code`: requires `files[]`, `pattern: 'duplicate-export'`
- `phantom-path`: requires `agentsMdPath`, `details.referencedPath`

### Severity Levels
Mapped to CLI tags: `'error'` → `'[ERROR]'`, `'warning'` → `'[WARN]'`, `'info'` → `'[INFO]'`

## Detection Limitations

**code-vs-doc**: Substring matching (`sumText.includes(e)`) yields false negatives when identifier appears in prose unrelated to API surface. No AST analysis or semantic validation.

**code-vs-code**: Name-only comparison without AST analysis cannot distinguish intentional duplication (facade pattern, barrel exports, interface/implementation pairs) from unintended collisions. Requires caller-enforced per-directory scoping to prevent false positives across module boundaries.

**Shared**: Regex-based extraction misses complex export patterns (destructured, namespace, dynamic). Both modules operate as pure heuristics without AI service calls.