---
generated_at: 2026-02-09T17:45:34.094Z
content_hash: 815c6784f88dbd27ad0b859beb5c7fa30845665400df4d51a3ed29f557812499
purpose: generateIntegrationFiles orchestrates AI assistant integration file creation with environment-specific template selec...
---
**generateIntegrationFiles orchestrates AI assistant integration file creation with environment-specific template selection, directory creation, skip-if-exists logic, and bundled hook deployment.**

## Exported Functions

**generateIntegrationFiles(projectRoot: string, options?: GenerateOptions): Promise<IntegrationResult[]>** — main orchestrator that detects or uses specified AI assistant environments, retrieves templates via `getTemplatesForEnvironment()`, writes files with `ensureDir()` + `writeFileSync()`, deploys bundled hooks for Claude via `readBundledHook()`, returns array of `IntegrationResult` with `filesCreated[]` and `filesSkipped[]` paths.

**GenerateOptions** — configuration interface with `dryRun?: boolean` (preview mode without writes), `force?: boolean` (overwrite existing files), `environment?: EnvironmentType` (bypass auto-detection).

## Integration Points

Imports `detectEnvironments()` from `./detect.js` for auto-discovery of `.claude/`, `.opencode/`, `.gemini/`, `.aider/` directories. Imports template getters `getClaudeTemplates()`, `getOpenCodeTemplates()`, `getGeminiTemplates()` from `./templates.js`. Uses `IntegrationResult` and `EnvironmentType` from `./types.js`.

## Hook Deployment

**getBundledHookPath(hookName: string): string** — resolves bundled hook location via `import.meta.url` + `fileURLToPath()`, navigates from `dist/integration/` up two levels to project root, then to `hooks/dist/${hookName}`.

**readBundledHook(hookName: string): string** — reads bundled hook via `readFileSync()` with `utf-8` encoding, throws `Error` with message `"Bundled hook not found: ${hookPath}"` if `existsSync()` returns false.

For `env.type === 'claude'`, appends `.claude/hooks/are-session-end.js` to result by reading bundled `are-session-end.js` via `readBundledHook()`, writing with `ensureDir()` unless exists and `!force`.

## File Creation Workflow

**ensureDir(filePath: string): void** — extracts parent directory via `path.dirname()`, creates with `mkdirSync({ recursive: true })` if `!existsSync()`.

For each template, constructs `fullPath` via `path.join(projectRoot, template.path)`, checks `existsSync(fullPath) && !force` → `filesSkipped.push()`, otherwise `ensureDir()` + `writeFileSync(fullPath, template.content, 'utf-8')` + `filesCreated.push()` unless `dryRun`.

## Environment Routing

**getTemplatesForEnvironment(type: EnvironmentType)** — switch statement dispatching to `getClaudeTemplates()`, `getOpenCodeTemplates()`, `getGeminiTemplates()` for respective types, returns empty array `[]` for `'aider'` (no command files yet) and default case.

When `options.environment` provided, bypasses `detectEnvironments()` and constructs single-element array `[{ type: specificEnv, configDir: configDirMap[specificEnv] }]` using literal map `{ claude: '.claude', opencode: '.opencode', aider: '.aider', gemini: '.gemini' }`.

## Return Value Structure

Returns `Promise<IntegrationResult[]>` with one element per environment, each containing `environment: EnvironmentType`, `filesCreated: string[]` (paths relative to projectRoot), `filesSkipped: string[]` (existing files not overwritten).