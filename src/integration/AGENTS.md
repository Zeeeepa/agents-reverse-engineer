<!-- Generated by agents-reverse-engineer -->

# src/integration/

Integration layer for installing ARE command files and hooks into AI coding assistant environments (Claude Code, OpenCode, Gemini CLI, Aider).

## Contents

### Environment Detection

**[detect.ts](./detect.ts)** — `detectEnvironments(projectRoot)` scans for AI assistant configuration directories (`.claude/`, `.opencode/`, `.aider/`, `.gemini/`) and returns `DetectedEnvironment[]` array. `hasEnvironment(projectRoot, type)` checks for specific environment presence. Claude Code detection triggers on `.claude/` directory OR `CLAUDE.md` file existence. Aider detection triggers on `.aider.conf.yml` file OR `.aider/` directory.

**[types.ts](./types.ts)** — Type definitions: `EnvironmentType` union (`'claude' | 'opencode' | 'aider' | 'gemini'`), `DetectedEnvironment` interface (`type`, `configDir`, `detected`), `IntegrationTemplate` interface (`filename`, `path`, `content`), `IntegrationResult` interface (`environment`, `filesCreated`, `filesSkipped`).

### Template Generation

**[templates.ts](./templates.ts)** — Platform-specific command file generation. Exports `getClaudeTemplates()`, `getOpenCodeTemplates()`, `getGeminiTemplates()` returning `IntegrationTemplate[]` arrays for seven commands (init, discover, generate, update, specify, rebuild, clean, help). Claude templates target `.claude/skills/are-{command}/SKILL.md` with `name:` frontmatter. OpenCode templates target `.opencode/commands/are-{command}.md` with `agent: build` frontmatter. Gemini templates target `.gemini/commands/are-{command}.toml` in TOML format. `buildTemplate(platform, commandName, command)` performs placeholder replacement for `COMMAND_PREFIX` and `VERSION_FILE_PATH`.

**[generate.ts](./generate.ts)** — `generateIntegrationFiles(projectRoot, options?)` orchestrates file creation by detecting environments via `detectEnvironments()`, retrieving templates via `getTemplatesForEnvironment()`, and writing command files with skip-if-exists or force-overwrite logic. `GenerateOptions` interface defines `dryRun`, `force`, `environment` fields. Claude environments additionally receive `.claude/hooks/are-session-end.js` hook via `readBundledHook()`. `ensureDir(filePath)` creates parent directories recursively before writes.

## Architecture

### File Generation Flow

1. `generateIntegrationFiles()` calls `detectEnvironments(projectRoot)` or constructs single-environment array from `options.environment`
2. For each environment, calls `getTemplatesForEnvironment(env.type)` to retrieve command templates
3. For each template, checks file existence at `projectRoot/template.path`
4. If file exists and `!options.force`, adds path to `filesSkipped` array
5. If file missing or `options.force` is true, calls `ensureDir()` + `writeFileSync()` (unless `options.dryRun`), adds path to `filesCreated` array
6. For Claude environments, repeats existence check + write for `.claude/hooks/are-session-end.js` using `readBundledHook('are-session-end.js')` as content
7. Returns `IntegrationResult[]` array with `environment`, `filesCreated`, `filesSkipped` per environment

### Platform Configuration

`PLATFORM_CONFIGS` object maps `Platform` type (`'claude' | 'opencode' | 'gemini'`) to `PlatformConfig` interface with fields:
- `commandPrefix` — command prefix in documentation (all platforms use `/are-`)
- `pathPrefix` — base directory path (`.claude/skills/`, `.opencode/commands/`, `.gemini/commands/`)
- `filenameSeparator` — separator for filenames (`.` for Claude, `-` for OpenCode/Gemini)
- `usesName` — whether platform includes `name:` frontmatter field (Claude only)
- `extraFrontmatter` — optional additional frontmatter (OpenCode uses `agent: build`)
- `versionFilePath` — runtime version file path (`.claude/ARE-VERSION`, `.opencode/ARE-VERSION`, `.gemini/ARE-VERSION`)

Claude structures command files as `.claude/skills/are-{command}/SKILL.md` (directory-based). OpenCode and Gemini use flat structure `.{platform}/commands/are-{command}.{ext}`.

### Command Definitions

Seven commands defined in `COMMANDS` constant, each with `description`, `argumentHint`, `content` fields:

- **init** — creates `.agents-reverse-engineer/config.yaml`, no arguments
- **discover** — scans codebase for files, writes `.discovered` artifact, enforces strict "run ONLY this exact command" rule
- **generate** — full documentation generation, creates `.sum` + `AGENTS.md` + root docs, uses background execution with progress polling
- **update** — incremental update for changed files, uses `--uncommitted` flag and progress polling
- **specify** — generates `specs/SPEC.md` from `AGENTS.md` files via AI synthesis, uses background execution
- **rebuild** — reconstructs project from `specs/` files into `rebuild/` directory, documents exit codes (0=success, 1=partial, 2=total failure)
- **clean** — deletes `.sum`, `AGENTS.md`, plan files, enforces strict command-only execution
- **help** — displays full reference documentation including `.sum` YAML schema, config structure, workflows

Commands using background execution (generate, update, discover, specify, rebuild) follow identical monitoring pattern: run with `run_in_background: true`, poll `.agents-reverse-engineer/progress.log` with Read tool using `offset` parameter, check TaskOutput with `block: false` until completion, summarize results.

## Behavioral Contracts

### Detection Patterns

Claude Code detection: `existsSync(path.join(projectRoot, '.claude'))` OR `existsSync(path.join(projectRoot, 'CLAUDE.md'))`

OpenCode detection: `existsSync(path.join(projectRoot, '.opencode'))`

Aider detection: `existsSync(path.join(projectRoot, '.aider.conf.yml'))` OR `existsSync(path.join(projectRoot, '.aider'))`

Gemini detection: `existsSync(path.join(projectRoot, '.gemini'))`

### File Path Construction

Claude command file: `${pathPrefix}are-${commandName}/SKILL.md` → `.claude/skills/are-generate/SKILL.md`

OpenCode command file: `${pathPrefix}are-${commandName}.md` → `.opencode/commands/are-generate.md`

Gemini command file: `${pathPrefix}are-${commandName}.toml` → `.gemini/commands/are-generate.toml`

Claude hook file: `.claude/hooks/are-session-end.js` (fixed path)

Bundled hook source: `${projectRoot}/hooks/dist/${hookName}` where `projectRoot` is computed as `path.resolve(__dirname, '../../..')` from `dist/integration/generate.js`

### Template Placeholder Substitution

All command templates contain two placeholders replaced at generation time:
- `COMMAND_PREFIX` → platform's `commandPrefix` value (e.g., `/are-`)
- `VERSION_FILE_PATH` → platform's `versionFilePath` value (e.g., `.claude/ARE-VERSION`)

Replacement performed via `content.replace(/COMMAND_PREFIX/g, config.commandPrefix).replace(/VERSION_FILE_PATH/g, config.versionFilePath)` in `buildTemplate()` and `buildGeminiToml()`.

## Dependencies

**Internal**: Uses `../config/schema.js` types indirectly via skill execution context. Command templates reference `npx agents-reverse-engineer@latest` CLI entry point from `src/cli/index.ts`.

**External**: `node:fs` (`existsSync`, `readFileSync`, `writeFileSync`, `mkdirSync`), `node:path` (`path.join`, `path.dirname`, `path.resolve`).

**Cross-module**: Templates invoke ARE CLI commands which trigger orchestration flow in `src/orchestration/orchestrator.ts` (generate/update) or `src/specify/index.ts` (specify) or `src/rebuild/index.ts` (rebuild). Hook installation reads bundled JavaScript from `hooks/dist/` (built by `scripts/build-hooks.js`).