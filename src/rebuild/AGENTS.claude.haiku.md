<!-- Generated by agents-reverse-engineer v0.9.10 -->

# src/rebuild

The rebuild module reconstructs source files from AI-friendly specification documents by orchestrating parallel AI calls grouped by dependency order, checkpointing progress to enable resumption, parsing multi-file responses, and accumulating built context across phases.

## Contents

### Core Orchestration
- [orchestrator.ts](./orchestrator.ts) — `executeRebuild()` entry point; groups rebuild units by order, processes groups sequentially with concurrent units within each group via `runPool`, accumulates exported symbols as context (`builtContext`) for downstream groups, handles checkpoint resumption via `CheckpointManager.load()`.
- [checkpoint.ts](./checkpoint.ts) — `CheckpointManager` persists per-module status and spec file content hashes to `.rebuild-checkpoint`; `load()` performs three-stage drift detection (file exists, schema valid, hashes match); `markDone()`/`markFailed()` update state; silent write failures allow rebuild to continue.

### Specification & Parsing
- [spec-reader.ts](./spec-reader.ts) — `readSpecFiles()` reads `.md` files from `specs/`; `partitionSpec()` extracts `RebuildUnit[]` from `## Build Plan` sections with `### Phase N:` subsections or falls back to `## ` top-level headings; injects contextual subsections (Architecture, API Surface, Behavioral Contracts, File Manifest) when `Defines:`/`Consumes:` metadata present.
- [output-parser.ts](./output-parser.ts) — `parseModuleOutput()` parses AI responses into `Map<filePath, content>` using `===FILE: path===` / `===END_FILE===` delimiters (primary) or markdown fenced-block format (fallback); state machine with regex patterns for column-0 delimiter detection.
- [prompts.ts](./prompts.ts) — `REBUILD_SYSTEM_PROMPT` instructs AI to generate compilable source using delimiter format; `buildRebuildPrompt()` assembles system + user prompt combining full spec, phase content, and previously-built context (`builtContext`); enforces strict naming, no tests/stubs/features.

### Types & Exports
- [types.ts](./types.ts) — `RebuildCheckpointSchema` validates checkpoint structure; `RebuildUnit` interface (name, specContent, order); `RebuildPlan` (specFiles, units, outputDir); `RebuildResult` (unitName, success, filesWritten, token counts).
- [index.ts](./index.ts) — Barrel export of types (`RebuildCheckpoint`, `RebuildUnit`, `RebuildPlan`, `RebuildResult`), schemas (`RebuildCheckpointSchema`), and functions (`readSpecFiles`, `partitionSpec`, `parseModuleOutput`, `buildRebuildPrompt`, `executeRebuild`, `CheckpointManager`, `REBUILD_SYSTEM_PROMPT`).

## Architecture & Data Flow

```
readSpecFiles() → specFiles[]
                      ↓
partitionSpec() → RebuildUnit[] (with injected context)
                      ↓
CheckpointManager.load() → { manager, isResume }
                      ↓
Group units by order field (ascending)
                      ↓
For each group (sequential):
  - Filter pending units (skip isDone())
  - buildRebuildPrompt(unit, fullSpec, builtContext)
  - aiService.call() → responseText
  - parseModuleOutput() → Map<filePath, content>
  - Write files to outputDir
  - checkpoint.markDone(name, filesWritten)
  - Extract file contents → accumulate to builtContext
                      ↓
checkpoint.flush() → .rebuild-checkpoint file
```

## Behavioral Contracts

**File delimiter format** (from prompts.ts, column 0, no markdown):
```
===FILE: relative/path.ext===
[file content]
===END_FILE===
```

**Strict naming compliance**: exported names from spec must match exactly (no synonyms).

**Import requirements**: when prior phase exports appear in "Already Built" context, code must import/use them rather than redefine; signatures must match exactly.

**Code quality**: production-ready only (no tests, comments, stubs, placeholders); must compile; must follow spec architecture; forbidden: feature invention, internal explanations.

**Checkpoint schema**: version-stamped `.rebuild-checkpoint` file in output directory; `specHashes` (Map of relativePath → contentHash) enables drift detection; `modules` (Map of unitName → {status, completedAt?, error?, filesWritten?}).

**Resume logic**: checkpoint valid only if JSON parses, schema passes, and ALL spec file content hashes match current files (file count + exact content). Any mismatch triggers fresh checkpoint.

**Built context truncation**: when `builtContext` exceeds 100,000 chars, splits on section markers (`// === [filePath] ===`), keeps recent half-groups in full, truncates older sections to 20-line heads (imports/declarations) with ellipsis.

## Integration Points

- **AI Service** (`../ai/index.js`): `AIService.call({ prompt, systemPrompt, taskLabel })` returns `AIResponse` with token counts.
- **Orchestration** (`../orchestration/index.js`): `runPool()` dispatches concurrent tasks with concurrency limit; `ProgressReporter` tracks token counts; `ITraceWriter` emits phase events.
- **Change Detection** (`../change-detection/index.js`): `computeContentHashFromString()` computes spec file hashes for drift detection.
- **Version** (`../version.js`): `getVersion()` stamps checkpoint creation timestamp.

## Configuration Surface

`RebuildExecutionOptions`:
- `outputDir` (string, absolute path) — destination for generated files
- `concurrency` (number) — max concurrent AI calls per order group
- `failFast?` (boolean) — stop on first error
- `force?` (boolean) — wipe output directory before rebuild
- `debug?` (boolean) — verbose logging
- `tracer?` (ITraceWriter) — emit phase events
- `progressLog?` (ProgressLog) — track progress callbacks

## Reproduction-Critical Constants

- `BUILT_CONTEXT_LIMIT` (100,000 chars): max length before truncation
- `TRUNCATED_HEAD_LINES` (20 lines): lines retained when truncating old sections
- Checkpoint file: `.rebuild-checkpoint` in output directory