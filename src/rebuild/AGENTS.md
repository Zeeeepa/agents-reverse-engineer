<!-- Generated by agents-reverse-engineer v0.8.2 -->

# rebuild

AI-driven project reconstruction from specification documents: reads `specs/*.md` Build Plan phases, partitions into ordered `RebuildUnit[]` executed via sequential phase groups with concurrent worker pools, persists checkpoint state for resume-after-failure, accumulates exported type context between phases, and parses multi-file LLM responses via delimiter extraction.

## Contents

**[checkpoint.ts](./checkpoint.ts)** — `CheckpointManager` persists `.rebuild-checkpoint` JSON (RebuildCheckpointSchema) with per-module status (`'pending'|'done'|'failed'`), spec content hashes for drift detection, promise-chain serialized writes. Static factories: `load()` validates checkpoint + compares `specHashes` against current content (returns `{manager, isResume: false}` on drift/corruption/missing), `createFresh()` initializes all modules pending. Instance methods: `markDone(unitName, filesWritten)`, `markFailed(unitName, error)`, `getPendingUnits()`, `flush()` awaits queued writes.

**[index.ts](./index.ts)** — Barrel export: types `RebuildCheckpoint`, `RebuildUnit`, `RebuildPlan`, `RebuildResult`; schema `RebuildCheckpointSchema`; functions `readSpecFiles()`, `partitionSpec()`, `parseModuleOutput()`, `buildRebuildPrompt()`, `executeRebuild()`; class `CheckpointManager`; constant `REBUILD_SYSTEM_PROMPT`.

**[orchestrator.ts](./orchestrator.ts)** — `executeRebuild(aiService, projectRoot, options)` reads specs via `readSpecFiles()`, partitions via `partitionSpec()`, groups `RebuildUnit[]` by `order` field, processes groups sequentially with concurrent `runPool()` per group. Per unit: calls `buildRebuildPrompt(unit, fullSpec, builtContext)` → `aiService.call()` → `parseModuleOutput()` → writes files → `checkpoint.markDone()`. Accumulates `builtContext` from written source files (skips `.md`/`.json`/`.yml`), truncates at `BUILT_CONTEXT_LIMIT` (100,000 chars) preserving recent sections full + older sections as 20-line headers. Returns `{modulesProcessed, modulesFailed, modulesSkipped}`. Emits `phase:start`/`phase:end` trace events. Supports `failFast`, `force` (wipes outputDir), `debug` options.

**[output-parser.ts](./output-parser.ts)** — `parseModuleOutput(responseText)` returns `Map<filePath, content>` via delimiter parser (`===FILE: path===` / `===END_FILE===` state machine requiring column-0 delimiters), falling back to markdown fenced block extractor (`/```\w*:([^\n]+)\n([\s\S]*?)```/g`). Handles unclosed blocks by flushing accumulated lines. Empty Map signals parsing failure.

**[prompts.ts](./prompts.ts)** — `REBUILD_SYSTEM_PROMPT` (850-char literal) mandates delimiter format, exact identifier matching from spec, production-ready code, imports from "Already Built" context, prohibits column-0 delimiter text in generated code. `buildRebuildPrompt(unit, fullSpec, builtContext)` returns `{system, user}` pair concatenating Full Specification, Current Phase (unit.specContent), optional Already Built context with import instructions, Output Format examples.

**[spec-reader.ts](./spec-reader.ts)** — `readSpecFiles(projectRoot)` reads `specs/*.md` sorted alphabetically, throws if empty. `partitionSpec(specFiles)` concatenates content, attempts `extractFromBuildPlan()` (locates `## 9. Build Plan` or `## Build Plan`, extracts phases via `/^### Phase (\d+):\s*(.+)$/gm`, injects Architecture section + targeted Public API Surface/Data Structures/Behavioral Contracts subsections if `hasDefinesConsumes` flag detects `/^\*\*Defines:\*\*|^Defines:/m`, else injects full Public API Surface), falls back to `extractFromTopLevelHeadings()` on failure, filters empty units, returns sorted by `unit.order` ascending. Helper `findRelevantSubsections()` matches subsections via keyword/file path extraction from `Defines:`/`Consumes:` lines.

**[types.ts](./types.ts)** — `RebuildCheckpointSchema` validates JSON with `version`, `createdAt`, `updatedAt`, `outputDir`, `specHashes` (record<string>), `modules` (record mapping name → `{status, completedAt?, error?, filesWritten?}`). `RebuildCheckpoint` inferred type. `RebuildUnit` interface: `name`, `specContent`, `order`. `RebuildPlan` interface: `specFiles`, `units`, `outputDir`. `RebuildResult` interface: `unitName`, `success`, `filesWritten`, `tokensIn`, `tokensOut`, `cacheReadTokens`, `cacheCreationTokens`, `durationMs`, `model`, `error?`.

## Data Flow

1. **Spec Ingestion**: `readSpecFiles()` loads `specs/*.md` → `partitionSpec()` extracts Build Plan phases via regex → produces ordered `RebuildUnit[]`
2. **Checkpoint Loading**: `CheckpointManager.load()` reads `.rebuild-checkpoint`, validates schema, compares spec hashes for drift → returns `{manager, isResume}` + filters pending units
3. **Phase Execution**: `executeRebuild()` groups units by `order` → sequential group loop → concurrent `runPool()` per group → each task: `buildRebuildPrompt()` injects context → `AIService.call()` → `parseModuleOutput()` extracts files → writes to disk → `checkpoint.markDone()`
4. **Context Accumulation**: After each group, reads written source files → appends to `builtContext` with `// === ${filePath} ===\n${content}` → truncates if exceeds 100KB by keeping recent files full + older files as 20-line headers
5. **State Persistence**: Promise-chain serialization via `checkpoint.writeQueue.then(() => writeFile())` prevents concurrent corruption → final `checkpoint.flush()` awaits queue

## Behavioral Contracts

### Delimiter Format
```
===FILE: relative/path.ext===
[file content]
===END_FILE===
```
Delimiters MUST appear at column 0 on own line. Generated code containing literal `===FILE:` text (e.g., parser logic) must indent or use string literals to avoid false detection.

### Build Plan Phase Extraction
```regex
/^### Phase (\d+):\s*(.+)$/gm
```
Captures group 1 (phase number as `order`), group 2 (phase title as part of `name`).

### Targeted Context Injection
```regex
/^\*\*Defines:\*\*|^Defines:/m
```
If match found (`hasDefinesConsumes = true`), inject Architecture + filtered Public API Surface/Data Structures/Behavioral Contracts subsections. Else inject Architecture + full Public API Surface.

### Keyword Extraction
```regex
/(?:\*\*Defines:\*\*|^Defines:)\s*(.+)/m
/(?:\*\*Consumes:\*\*|^Consumes:)\s*(.+)/m
/\b(?:src\/[\w\-./]+|[\w-]+\.(?:ts|js|py|rs|go))\b/g
```
First two extract symbol lists (split on `[,;]`), third extracts file path references. Combined keywords fuzzy-match subsection headings for relevance filtering.

### Context Truncation
```javascript
BUILT_CONTEXT_LIMIT = 100_000  // characters
TRUNCATED_HEAD_LINES = 20      // lines preserved from older files
// Strategy: floor(sections.length / 2) recent sections full, older → 20-line header + "// ... (truncated)"
```

### Checkpoint Module Status
```typescript
'pending' | 'done' | 'failed'
```
Enum values for `RebuildCheckpoint.modules[unitName].status` field. `getPendingUnits()` returns modules with `'pending'` or `'failed'`.

### Spec Drift Detection
```javascript
Object.keys(checkpoint.specHashes).length !== currentHashCount
|| Object.entries(checkpoint.specHashes).some(([path, hash]) => hash !== currentHashes[path])
// If true → discard checkpoint, return isResume: false
```

### Fenced Block Fallback
```regex
/```\w*:([^\n]+)\n([\s\S]*?)```/g
```
Matches markdown code fences with file path annotation after language tag. Group 1 captures path (trimmed), group 2 captures content.

## File Relationships

**checkpoint.ts** ← **orchestrator.ts** (`CheckpointManager.load()` validates state, `markDone()`/`markFailed()` serialized writes)  
**spec-reader.ts** ← **orchestrator.ts** (`readSpecFiles()` ingests specs, `partitionSpec()` produces ordered units)  
**prompts.ts** ← **orchestrator.ts** (`buildRebuildPrompt()` combines context for AI call)  
**output-parser.ts** ← **orchestrator.ts** (`parseModuleOutput()` extracts files from LLM response)  
**types.ts** → all modules (provides `RebuildCheckpoint`, `RebuildUnit`, `RebuildPlan`, `RebuildResult`, `RebuildCheckpointSchema`)  
**index.ts** → public API surface (barrel export for `src/cli/rebuild.ts`)

**orchestrator.ts** imports: `../ai/index.js` (AIService), `../orchestration/index.js` (runPool, ProgressReporter), `../change-detection/index.js` (via checkpoint → computeContentHashFromString)  
**checkpoint.ts** imports: `../change-detection/index.js` (computeContentHashFromString), `../version.js` (getVersion)

## Reproduction-Critical Constants

Full rebuild system prompt text: [index.annex.sum](./index.annex.sum)