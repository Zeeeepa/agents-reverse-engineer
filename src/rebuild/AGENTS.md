<!-- Generated by agents-reverse-engineer -->

# src/rebuild/

AI-driven project reconstruction pipeline consuming `.md` spec files from `specs/` directory, partitioning into ordered `RebuildUnit[]` via Build Plan phase extraction, executing sequential order groups with concurrent pool workers per group, accumulating built context between phases, and persisting resume state via checkpoint JSON.

## Contents

**[checkpoint.ts](./checkpoint.ts)** — `CheckpointManager` class persisting rebuild session state to `.rebuild-checkpoint` JSON in output directory. Static factories: `load(outputDir, specFiles, unitNames)` (validates `RebuildCheckpointSchema`, detects spec drift via SHA-256 hash comparison, returns `{manager, isResume: false}` on drift/corruption/missing), `createFresh(outputDir, specFiles, unitNames)` (initializes all modules `'pending'`). Instance methods: `markDone(unitName, filesWritten)`, `markFailed(unitName, error)`, `getPendingUnits()`, `isDone(unitName)`, `flush()` (awaits queued writes), `initialize()`, `getData()`. Promise-chain serialization via `writeQueue` field prevents concurrent write corruption from pool workers.

**[orchestrator.ts](./orchestrator.ts)** — `executeRebuild(aiService, projectRoot, options): Promise<RebuildResult>` main pipeline: reads specs via `readSpecFiles()`, partitions via `partitionSpec()`, loads checkpoint via `CheckpointManager.load()`, groups `RebuildUnit[]` by `order` field, processes groups sequentially with concurrent `runPool()` per group. Within each task: `buildRebuildPrompt(unit, fullSpec, builtContext)` → `aiService.call()` → `parseModuleOutput()` → writes files via `writeFile()` → `checkpoint.markDone()`. Between groups: reads written source files (skips `.md`/`.json`/`.yml`), appends to `builtContext` as `// === ${filePath} ===\n${content}`, truncates at 100KB via `BUILT_CONTEXT_LIMIT` (keeps last 50% sections full, older sections as 20-line `TRUNCATED_HEAD_LINES` headers). Exports `RebuildExecutionOptions` interface (`outputDir`, `concurrency`, `failFast?`, `force?`, `debug?`, `tracer?`, `progressLog?`).

**[spec-reader.ts](./spec-reader.ts)** — `readSpecFiles(projectRoot): Promise<Array<{relativePath, content}>>` reads sorted `specs/*.md` files, throws "No spec files found in specs/. Run 'are specify' first." if empty. `partitionSpec(specFiles): RebuildUnit[]` concatenates content, extracts via `extractFromBuildPlan()` (primary: locates `## 9. Build Plan` or `## Build Plan`, parses `### Phase N:` subsections, injects context prefix: Architecture section always + targeted `findRelevantSubsections()` querying Public API Surface/Data Structures/Behavioral Contracts via `Defines:`/`Consumes:` keyword matching if Change 2 format detected, otherwise full Public API Surface), falls back to `extractFromTopLevelHeadings()` (sequential `## ` splits with 1-indexed `order`), filters empty units, sorts by `order` ascending.

**[prompts.ts](./prompts.ts)** — `buildRebuildPrompt(unit, fullSpec, builtContext): {system, user}` constructs prompt pair: user message concatenates "## Full Specification" (fullSpec), "## Current Phase" (unit.specContent), optional "## Already Built" (builtContext with import instructions), "## Output Format" (delimiter examples); returns `{system: REBUILD_SYSTEM_PROMPT, user: sections.join('\n')}`. Exports `REBUILD_SYSTEM_PROMPT` (850-char literal mandating `===FILE: path===` / `===END_FILE===` delimiters, exact identifier matching from spec, production-ready code, no column-0 delimiter text in generated code).

**[output-parser.ts](./output-parser.ts)** — `parseModuleOutput(responseText): Map<filePath, content>` parses AI multi-file responses via `parseDelimiterFormat()` (line-by-line state machine: `START_RE = /^===FILE:\s*(.+?)===$/`, `END_RE = /^===END_FILE===$/` requiring column-0 delimiters, handles unclosed blocks), falls back to `parseFencedBlockFormat()` (markdown fences with file path annotation: `/```\w*:([^\n]+)\n([\s\S]*?)```/g`). Returns trimmed paths, untrimmed content. Empty Map signals parsing failure.

**[types.ts](./types.ts)** — Type definitions: `RebuildCheckpointSchema` (Zod schema validating `.rebuild-checkpoint` JSON with `version`, `createdAt`, `updatedAt`, `outputDir`, `specHashes: Record<string, string>`, `modules: Record<string, {status: 'pending'|'done'|'failed', completedAt?, error?, filesWritten?}>`), `RebuildCheckpoint` (inferred type), `RebuildUnit` (interface: `name`, `specContent`, `order`), `RebuildPlan` (interface: `specFiles`, `units`, `outputDir`), `RebuildResult` (interface: `unitName`, `success`, `filesWritten`, `tokensIn`, `tokensOut`, `cacheReadTokens`, `cacheCreationTokens`, `durationMs`, `model`, `error?`).

**[index.ts](./index.ts)** — Barrel export re-exporting: types (`RebuildCheckpoint`, `RebuildUnit`, `RebuildPlan`, `RebuildResult`), schema (`RebuildCheckpointSchema`), functions (`readSpecFiles`, `partitionSpec`, `parseModuleOutput`, `buildRebuildPrompt`, `executeRebuild`), class (`CheckpointManager`), constant (`REBUILD_SYSTEM_PROMPT`).

## Architecture

### Two-Phase Workflow

**Spec Preparation**: `readSpecFiles()` discovers `specs/*.md`, `partitionSpec()` extracts Build Plan phases via `/^### Phase (\d+):\s*(.+)$/gm` regex, assigns `order` field (phase number), injects context prefix (Architecture + targeted subsections or full Public API Surface fallback), sorts by `order` ascending. Fallback: splits on top-level `## ` headings with sequential order.

**Execution**: `executeRebuild()` groups `RebuildUnit[]` by `order` into `Map<number, RebuildUnit[]>`, iterates groups sequentially. Per group: spawns `runPool()` with `concurrency` workers, each task calls `buildRebuildPrompt()` → `AIService.call()` → `parseModuleOutput()` → writes files → `checkpoint.markDone()`. Between groups: accumulates `builtContext` from written source files (excludes `.md`/`.json`/`.yml`), truncates at 100KB by keeping last 50% sections full + older sections as 20-line headers.

### Checkpoint-Based Resumption

`CheckpointManager.load()` reads `.rebuild-checkpoint`, validates `RebuildCheckpointSchema`, compares stored `specHashes` against current spec file content hashes. Returns `isResume: true` if valid and no drift, `isResume: false` if drift/corruption/missing (creates fresh checkpoint). `orchestrator.ts` filters `checkpoint.isDone(unit.name)` into `pendingUnits`, skips completed modules, logs resume count. `markDone(unitName, filesWritten)` and `markFailed(unitName, error)` queue writes via promise-chain serialization (`writeQueue: Promise<void>` field).

### Context Accumulation Strategy

After each order group completes, `orchestrator.ts` reads written files matching `\.(ts|js|py|rs|go|java|cpp|c|h)$`, appends to `builtContext` as `// === ${filePath} ===\n${content}\n`. Truncates when exceeds `BUILT_CONTEXT_LIMIT = 100_000` chars: computes `recentCount = Math.floor(sections.length / 2)`, keeps recent sections full, older sections reduced to first `TRUNCATED_HEAD_LINES = 20` lines + `// ... (truncated)` suffix. Prompt injects "## Already Built" with "Import from them as needed" directive.

### Concurrency Model

Iterator-based `runPool<RebuildUnit>(tasks, {concurrency, failFast, tracer, phaseLabel}, onComplete)` spawns N workers sharing single iterator. Order groups execute sequentially (respects phase dependencies), tasks within group execute concurrently. `onComplete` callback updates `modulesProcessed`/`modulesFailed` counters + calls `ProgressReporter.onFileDone()` or `.onFileError()` in serialized manner.

## Behavioral Contracts

### Delimiter Format
```
===FILE: relative/path.ext===
[file content]
===END_FILE===
```
Regex: `START_RE = /^===FILE:\s*(.+?)===$/`, `END_RE = /^===END_FILE===$/`. Delimiters MUST appear at column 0 (no leading whitespace). Generated code containing literal `===FILE:` text must be indented or inside string—never at column 0.

### Build Plan Phase Extraction
```regex
/^### Phase (\d+):\s*(.+)$/gm
```
Captures group 1 (phase number for `order` field), group 2 (phase title for `name` suffix).

### Build Plan Section Locator
```regex
/^(## (?:\d+\.\s*)?Build Plan)\s*$/m
```
Matches numbered (`## 9. Build Plan`) or unnumbered (`## Build Plan`) section headings.

### Change 2 Format Detection
```regex
/^\*\*Defines:\*\*|^Defines:/m
```
Detects structured Defines/Consumes lists enabling targeted context injection vs full section fallback.

### Keyword Extraction
```regex
/(?:\*\*Defines:\*\*|^Defines:)\s*(.+)/m
/(?:\*\*Consumes:\*\*|^Consumes:)\s*(.+)/m
```
Extracts symbol lists from Defines/Consumes lines, splits on `[,;]`, lowercases for fuzzy matching against subsection headings.

### File Path Detection
```regex
/\b(?:src\/[\w\-./]+|[\w-]+\.(?:ts|js|py|rs|go))\b/g
```
Extracts file references from phase content for targeted context injection.

### Source File Filter
```regex
/\.(ts|js|py|rs|go|java|cpp|c|h)$/
```
Selects files for `builtContext` accumulation, excludes `.md`/`.json`/`.yml`.

### Context Accumulation Format
```javascript
builtContext += `\n// === ${filePath} ===\n${content}\n`
```
File delimiter pattern prepended to each accumulated file content.

### Truncation Strategy
```javascript
recentCount = Math.floor(sections.length / 2)
truncatedHead = section.split('\n').slice(0, 20).join('\n') + '\n// ... (truncated)\n'
```
Preserves last 50% sections full, older sections reduced to 20-line imports/types header.

### Checkpoint Schema Version
```javascript
version: string  // from getVersion() in src/version.ts
```
Stored in checkpoint JSON for forward compatibility detection.

### Module Status Enum
```typescript
'pending' | 'done' | 'failed'
```
Tri-state execution status in `RebuildCheckpoint.modules` map.

### Spec Hash Algorithm
SHA-256 hex digest via `computeContentHashFromString()` from `src/change-detection/index.js`. Detects spec drift when hash count differs or any hash mismatches between checkpoint and current files.

### Error Propagation Thresholds
- Empty `parseModuleOutput()` Map: throws `Error('AI produced no files for unit "${unit.name}". Response may have used unexpected format.')`
- Zero valid units after filtering: throws from `partitionSpec()`
- Missing `specs/` directory: throws "No spec files found in specs/. Run 'are specify' first." from `readSpecFiles()`

## Annex References

Full type schemas, import map, and prompt templates: [index.annex.sum](./index.annex.sum)