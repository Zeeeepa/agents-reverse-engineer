<!-- Generated by agents-reverse-engineer -->

# src/rebuild

**The `rebuild/` subsystem implements AI-driven project reconstruction from specification documents, orchestrating phased code generation with checkpoint-based resumption, targeted context injection, and delimiter-based file extraction.**

## Contents

### Core Orchestration

- **[orchestrator.ts](./orchestrator.ts)** — `executeRebuild` drives the multi-phase pipeline: reads specs via `readSpecFiles`, partitions into `RebuildUnit` arrays by `order` field, loads `CheckpointManager` for resumption, groups units by order value, runs `runPool` for concurrent AI calls within each group, accumulates `builtContext` from completed files, and checkpoints progress after each unit.

- **[checkpoint.ts](./checkpoint.ts)** — `CheckpointManager` persists per-module completion status to `.rebuild-checkpoint` JSON using promise-chain write serialization. `load` factory detects spec drift by comparing `computeContentHashFromString` hashes. `markDone` and `markFailed` update module state. `getPendingUnits` filters incomplete work for resume sessions.

- **[spec-reader.ts](./spec-reader.ts)** — `readSpecFiles` ingests markdown from `.agents-reverse-engineer/specs/`, `partitionSpec` extracts `RebuildUnit` arrays from Build Plan phases or top-level headings, `extractFromBuildPlan` implements targeted context injection by matching phase Defines:/Consumes: keywords against Architecture, Public API Surface, Data Structures, Behavioral Contracts, and File Manifest subsections.

### AI Communication

- **[prompts.ts](./prompts.ts)** — `REBUILD_SYSTEM_PROMPT` enforces delimiter-based file emission and production code quality constraints. `buildRebuildPrompt` assembles user prompts from full spec, current phase content, and `builtContext` (exported signatures from prior order groups).

- **[output-parser.ts](./output-parser.ts)** — `parseModuleOutput` extracts `Map<string, string>` file mappings from AI responses via `parseDelimiterFormat` (primary) using column-0 anchored `===FILE:===` / `===END_FILE===` markers, falling back to `parseFencedBlockFormat` for markdown fenced blocks with `:path` annotations.

### Data Structures

- **[types.ts](./types.ts)** — `RebuildCheckpointSchema` validates persisted state with module status enum (`'pending'` | `'done'` | `'failed'`) and spec hash records for drift detection. `RebuildUnit` carries `name`, `specContent`, `order` for sequencing. `RebuildResult` captures per-unit outcomes with token counts, `filesWritten`, and `durationMs`.

- **[index.ts](./index.ts)** — Barrel export exposing `executeRebuild`, `CheckpointManager`, `readSpecFiles`, `partitionSpec`, `parseModuleOutput`, `buildRebuildPrompt`, `REBUILD_SYSTEM_PROMPT`, and all types for CLI integration via `src/cli/rebuild.ts`.

## Architecture

### Order-Based Phased Execution

`executeRebuild` sorts `RebuildUnit` instances by `order` field ascending, processing each order group fully before advancing. Units with `order: 1` complete before `order: 2` units execute, ensuring low-order modules contribute exported signatures to `builtContext` for higher-order dependencies. Within each order group, `runPool` executes AI calls concurrently up to `concurrency` limit.

### Checkpoint Resumption

`CheckpointManager.load` reads `.rebuild-checkpoint` JSON and compares stored `specHashes` against current spec file content hashes via `computeContentHashFromString`. Hash mismatch triggers spec drift detection, discarding stale checkpoint and creating fresh state. When checkpoint valid, `getPendingUnits` filters modules with `status: 'pending' | 'failed'`, skipping completed work. `markDone` and `markFailed` updates queued via promise-chain serialization prevent corruption from concurrent pool workers.

### Context Accumulation Strategy

After each order group completes, `executeRebuild` reads generated files (excluding `.md`, `.json`, `.yml` extensions) and appends content to `builtContext` string with `// === ${filePath} ===` delimiters. When accumulated context exceeds `BUILT_CONTEXT_LIMIT` (100,000 chars), older groups truncated to `TRUNCATED_HEAD_LINES` (20 lines) with `// ... (truncated)` suffix. Subsequent order groups receive `builtContext` via `buildRebuildPrompt`, enabling import of prior phase exports.

### Targeted Context Injection

`extractFromBuildPlan` detects Change 2 spec format via `/^\*\*Defines:\*\*|^Defines:/m` pattern. For each phase, `findRelevantSubsections` extracts keywords from `Defines:` and `Consumes:` lines, matches against Public API Surface subsection headings using case-insensitive keyword-in-heading and word-overlap heuristics, and injects only matching subsections as `## Interfaces for This Phase`. Similarly filters Data Structures, Behavioral Contracts subsections. `extractManifestEntriesForPhase` filters File Manifest lines containing phase's Defines: symbols, injecting as `## Files to Generate in This Phase`. Legacy specs without Defines:/Consumes: receive full section content.

## Behavioral Contracts

### Delimiter Protocol (prompts.ts)

AI responses must emit files using exact column-0 anchored delimiters:
```
===FILE: relative/path.ext===
[file content]
===END_FILE===
```

### Delimiter Parsing Patterns (output-parser.ts)

- Start delimiter regex: `/^===FILE:\s*(.+?)===$/` with `^` anchor prevents matching delimiter text inside code strings or comments
- End delimiter regex: `/^===END_FILE===$/` with `^` anchor
- Fallback fenced block pattern: `/```\w*:([^\n]+)\n([\s\S]*?)```/g` captures language identifier, path, and content

### Spec Drift Detection (checkpoint.ts)

Checkpoint invalidation triggers when:
- `checkpoint.specHashes` count ≠ current `specFiles.length`
- Any `computeContentHashFromString(spec.content)` ≠ stored `specHashes[spec.relativePath]`
- JSON parse failure or `RebuildCheckpointSchema.safeParse()` returns `success: false`

## File Relationships

- `orchestrator.ts` invokes `readSpecFiles` → `partitionSpec` → `CheckpointManager.load` → `buildRebuildPrompt` → `AIService.call` → `parseModuleOutput` → `checkpoint.markDone`
- `spec-reader.ts` calls `extractSection`, `extractSubsections`, `findRelevantSubsections`, `extractManifestEntriesForPhase` in Build Plan extraction
- `checkpoint.ts` imports `computeContentHashFromString` from `../change-detection/` for drift detection, `getVersion` from `../version.ts` for checkpoint versioning
- `orchestrator.ts` threads `ITraceWriter` from `options.tracer` to `runPool` for phase event emission, `ProgressLog` to `ProgressReporter` for file lifecycle callbacks