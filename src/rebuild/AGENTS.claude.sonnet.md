<!-- Generated by agents-reverse-engineer v1.0.1 -->

# src/rebuild

Reconstructs projects from `specs/*.md` via AI-driven incremental build using checkpoint-based resumption, dependency-ordered phases, and context injection from prior groups.

## Contents

- [`checkpoint.ts`](./checkpoint.ts): `CheckpointManager` persists rebuild state to `.rebuild-checkpoint`, implements drift detection via `specHashes` comparison, exposes `load`, `createFresh`, `markDone`, `markFailed`, `getPendingUnits`, serializes writes via `writeQueue` promise chain.
- [`index.ts`](./index.ts): Barrel export of `RebuildCheckpoint`, `RebuildUnit`, `RebuildPlan`, `RebuildResult`, `RebuildCheckpointSchema`, `readSpecFiles`, `partitionSpec`, `parseModuleOutput`, `CheckpointManager`, `REBUILD_SYSTEM_PROMPT`, `buildRebuildPrompt`, `executeRebuild`, `RebuildExecutionOptions`.
- [`orchestrator.ts`](./orchestrator.ts): `executeRebuild` coordinates spec reading, unit partitioning, checkpoint loading, order-based group sequencing, `runPool` concurrency, `builtContext` accumulation, file writing, progress tracking.
- [`output-parser.ts`](./output-parser.ts): `parseModuleOutput` parses AI responses using `===FILE: path===` delimiter format or fenced block fallback, returns `Map<string, string>`.
- [`prompts.ts`](./prompts.ts): `REBUILD_SYSTEM_PROMPT` defines delimiter format contract, `buildRebuildPrompt` constructs system+user prompt with Full Specification, Current Phase, Already Built context.
- [`spec-reader.ts`](./spec-reader.ts): `readSpecFiles` loads `.md` from `specs/`, `partitionSpec` extracts `RebuildUnit[]` from `## Build Plan` phases or top-level headings, injects `Architecture`, `Public API Surface`, `Data Structures`, `Behavioral Contracts`, `File Manifest` subsections matched via `Defines:/Consumes:` symbols.
- [`types.ts`](./types.ts): `RebuildCheckpointSchema` (Zod), `RebuildCheckpoint`, `RebuildUnit`, `RebuildPlan`, `RebuildResult` define checkpoint persistence, unit structure, execution results.

## Architecture

**Pipeline Flow:** `executeRebuild` → `readSpecFiles` → `partitionSpec` → `CheckpointManager.load` → group units by `order` → per-group `runPool` → `aiService.call` with `buildRebuildPrompt` → `parseModuleOutput` → write files → `checkpoint.markDone` → accumulate `builtContext` → next group.

**Resumption:** `CheckpointManager.load` validates `.rebuild-checkpoint` via `RebuildCheckpointSchema`, computes `specHashes` drift, filters completed units via `checkpoint.isDone`, resumes from pending/failed units.

**Context Injection:** `builtContext` accumulates export signatures from prior order groups, passed to `buildRebuildPrompt` as "Already Built" modules, truncated to `BUILT_CONTEXT_LIMIT` (100,000 chars) preserving recent groups fully, older groups to first `TRUNCATED_HEAD_LINES` (20).

**Phase Partitioning:** `extractFromBuildPlan` parses `## Build Plan` → `### Phase N:` subsections, injects `Architecture` section plus targeted `Public API Surface`/`Data Structures`/`Behavioral Contracts`/`File Manifest` subsections matched via `Defines:/Consumes:` symbols using `findRelevantSubsections` fuzzy matching (keyword substring or word overlap >3 chars). Falls back to `extractFromTopLevelHeadings` (splits on `## ` headings) if Build Plan missing.

## Behavioral Contracts

**Checkpoint Drift Detection:**
- `load()` compares `specHashes[relativePath]` against `computeContentHashFromString(content)`, creates fresh checkpoint if hash count differs or any hash mismatches.

**Delimiter Format (AI Output):**
```
===FILE: relative/path.ext===
[content]
===END_FILE===
```
Patterns: `START_RE = /^===FILE:\s*(.+?)===$/`, `END_RE = /^===END_FILE===$/` (anchored to line start), fenced block fallback: `/```\w*:([^\n]+)\n([\s\S]*?)```/g`.

**Spec Partitioning Regexes:**
- Build Plan heading: `/^(## (?:\d+\.\s*)?Build Plan)\s*$/m`
- Phase heading: `/^### Phase (\d+):\s*(.+)$/gm`
- Defines/Consumes detection: `/^\*\*Defines:\*\*|^Defines:/m`
- Defines extraction: `/(?:\*\*Defines:\*\*|^Defines:)\s*(.+)/m`
- Consumes extraction: `/(?:\*\*Consumes:\*\*|^Consumes:)\s*(.+)/m`
- File path extraction: `/\b(?:src\/[\w\-./]+|[\w-]+\.(?:ts|js|py|rs|go))\b/g`
- Section name pattern: `/^## (?:\\d+\\.\\s*)?${sectionName}\\s*$/m`

**Error Messages:**
- No specs: `"No spec files found in specs/. Run \"are specify\" first."`
- Partition failure: `"Could not extract rebuild units from spec files. Expected either a \"## Build Plan\" section with \"### Phase N:\" subsections, or top-level \"## \" headings. Check your spec file format."`
- Zero files from AI: `"AI produced no files for unit \"${unit.name}\". Response may have used unexpected format."`

**Context Markers:**
- File separator: `\n// === ${filePath} ===\n`
- Truncation marker: `// ... (truncated)\n`

**Checkpoint Schema Fields:**
- `version`, `createdAt`, `updatedAt`, `outputDir`, `specHashes: Record<string, string>`, `modules: Record<string, {status: 'pending'|'done'|'failed', completedAt?, filesWritten?: string[], error?: string}>`

**Limits:**
- `BUILT_CONTEXT_LIMIT = 100000` chars
- `TRUNCATED_HEAD_LINES = 20` lines per truncated section
- Fuzzy match word threshold: 3 characters

## File Relationships

`orchestrator.ts` depends on `readSpecFiles`/`partitionSpec` from `spec-reader.ts`, `CheckpointManager` from `checkpoint.ts`, `buildRebuildPrompt` from `prompts.ts`, `parseModuleOutput` from `output-parser.ts`, `runPool`/`ProgressReporter` from `../orchestration/index.js`, `AIService` from `../ai/index.js`.

`checkpoint.ts` imports `computeContentHashFromString` from `../change-detection/index.js`, `getVersion` from `../version.js`.

`spec-reader.ts` extracts units from specs, calls `extractFromBuildPlan` or `extractFromTopLevelHeadings`, uses `findRelevantSubsections` for context injection.

`prompts.ts` templates consumed by `orchestrator.ts` via `buildRebuildPrompt(unit, fullSpec, builtContext)`.

`output-parser.ts` consumed by `orchestrator.ts` to parse `AIResponse.text` into file map.

`types.ts` provides shared interfaces for all modules.