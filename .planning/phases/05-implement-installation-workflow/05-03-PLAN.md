---
phase: 05-implement-installation-workflow
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/installer/operations.ts
autonomous: true

must_haves:
  truths:
    - "Command files are copied to correct runtime directories"
    - "Hook files are created for Claude Code installations"
    - "Existing files are skipped unless --force is specified"
    - "User is informed which files were skipped"
    - "Hooks are registered in settings.json for global installs"
    - "VERSION file is written to track installed version"
  artifacts:
    - path: "src/installer/operations.ts"
      provides: "File copy, verification, and hook registration"
      exports: ["installFiles", "verifyInstallation", "registerHooks", "writeVersionFile"]
  key_links:
    - from: "src/installer/operations.ts"
      to: "src/integration/templates.ts"
      via: "template content import"
      pattern: "import.*from.*integration/templates"
    - from: "src/installer/operations.ts"
      to: "src/installer/paths.ts"
      via: "path resolution"
      pattern: "import.*from.*paths"
---

<objective>
Create the file operations module that handles copying command/hook files to runtime directories.

Purpose: Performs the actual installation work - copying templates to the right locations, handling existing files, registering hooks in settings.json, and writing VERSION tracking.

Output: Single file providing all file operation functions for the installer.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-implement-installation-workflow/05-CONTEXT.md
@.planning/phases/05-implement-installation-workflow/05-RESEARCH.md
@src/integration/templates.ts
@src/integration/generate.ts
@src/installer/types.ts
@src/installer/paths.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create file operations module</name>
  <files>src/installer/operations.ts</files>
  <action>
Create src/installer/operations.ts with:

1. Imports:
   - `import { existsSync, mkdirSync, writeFileSync, readFileSync } from 'node:fs'`
   - `import * as path from 'node:path'`
   - `import type { Runtime, Location, InstallerResult } from './types.js'`
   - `import { getRuntimePaths, resolveInstallPath, getAllRuntimes } from './paths.js'`
   - `import { getClaudeTemplates, getOpenCodeTemplates, getGeminiTemplates, getHookTemplate } from '../integration/templates.js'`

2. Helper `ensureDir(filePath: string): void`:
   - Get directory with path.dirname()
   - Create recursively if not exists

3. Interface `InstallOptions`:
   - force: boolean
   - dryRun: boolean (for preview without writing)

4. `getTemplatesForRuntime(runtime: Exclude<Runtime, 'all'>)`:
   - Switch on runtime to return appropriate templates
   - claude -> getClaudeTemplates()
   - opencode -> getOpenCodeTemplates()
   - gemini -> getGeminiTemplates()

5. `installFiles(runtime: Runtime, location: Location, options: InstallOptions): InstallerResult[]`:
   - If runtime is 'all', iterate getAllRuntimes() and call installFilesForRuntime for each
   - Otherwise call installFilesForRuntime once
   - Return array of results

6. `installFilesForRuntime(runtime: Exclude<Runtime, 'all'>, location: Location, options: InstallOptions): InstallerResult`:
   - Resolve base install path using resolveInstallPath()
   - Get templates for this runtime
   - For each template:
     - Compute full path: path.join(basePath, relative path from template)
     - If exists and !force, add to filesSkipped
     - Else if !dryRun, ensureDir and writeFileSync, add to filesCreated
     - Else (dryRun), add to filesCreated for preview
   - For Claude runtime, also handle hook file:
     - Hook path: path.join(basePath, 'hooks', 'are-session-end.js')
     - Same skip/create logic
   - Return InstallerResult with environment, filesCreated, filesSkipped

7. `verifyInstallation(files: string[]): { success: boolean, missing: string[] }`:
   - Filter files to those that don't exist
   - Return success: true if missing.length === 0

8. VERSION file writing (next task will complete this)
  </action>
  <verify>
Run: `npx tsc --noEmit src/installer/operations.ts`
No TypeScript errors. Imports from integration/templates work.
  </verify>
  <done>File operations module handles template copying with skip-existing and force logic.</done>
</task>

<task type="auto">
  <name>Task 2: Add hook registration and VERSION tracking</name>
  <files>src/installer/operations.ts</files>
  <action>
Add to src/installer/operations.ts:

1. `registerHooks(basePath: string, dryRun: boolean): boolean`:
   - Only for Claude installations (check if path contains .claude)
   - Settings path: path.join(basePath, 'settings.json')
   - If settings.json exists, read and parse as JSON
   - If not exists, create new settings object: {}
   - Add/update hooks.SessionEnd array:
     ```typescript
     const hook = {
       hooks: [{
         type: 'command' as const,
         command: 'node hooks/are-session-end.js'
       }]
     };
     ```
   - Check if hook already exists (by command string match)
   - If not exists, push to SessionEnd array
   - If !dryRun, write settings.json with JSON.stringify(settings, null, 2)
   - Return true if hook was added, false if already existed

2. `writeVersionFile(basePath: string, dryRun: boolean): void`:
   - Read version from package.json (import or read file)
   - Write to path.join(basePath, 'VERSION')
   - Format: Just the version string, e.g., "0.1.2"
   - Skip if dryRun

3. `getPackageVersion(): string`:
   - Read package.json from project root (relative to this file)
   - Parse and return version field
   - Fallback to 'unknown' if can't read

4. Update `installFilesForRuntime` to:
   - Call registerHooks() for Claude global installs
   - Call writeVersionFile() after successful file installation
   - Add hookRegistered: boolean to result tracking
  </action>
  <verify>
Run: `npx tsc --noEmit src/installer/operations.ts`
No TypeScript errors.
Manually verify: settings.json hook structure matches Claude Code format.
  </verify>
  <done>Hook registration adds SessionEnd hook to settings.json, VERSION file tracks installed version.</done>
</task>

<task type="auto">
  <name>Task 3: Add result formatting helpers</name>
  <files>src/installer/operations.ts</files>
  <action>
Add to src/installer/operations.ts:

1. `formatInstallResult(result: InstallerResult): string[]`:
   - Return array of formatted lines for display
   - Line for each created file: "  Created: {path}"
   - Line for each skipped file: "  Skipped: {path} (already exists)"
   - Summary line: "  {N} files installed, {M} skipped"

2. Export all public functions:
   - installFiles
   - verifyInstallation
   - registerHooks
   - writeVersionFile
   - formatInstallResult
   - getPackageVersion

3. Update InstallerResult type in types.ts if needed:
   - Add optional hookRegistered?: boolean
   - Add optional versionWritten?: boolean
  </action>
  <verify>
Run: `npx tsc --noEmit src/installer/operations.ts src/installer/types.ts`
All exports are properly typed.
  </verify>
  <done>Operations module provides complete file handling with formatted output helpers.</done>
</task>

</tasks>

<verification>
1. All files compile: `npx tsc --noEmit`
2. Templates are imported correctly from integration module
3. File paths are cross-platform (uses path.join)
4. settings.json merge doesn't overwrite existing hooks
5. VERSION file contains correct version from package.json
</verification>

<success_criteria>
- [ ] src/installer/operations.ts exports installFiles, verifyInstallation, registerHooks, writeVersionFile
- [ ] installFiles handles all three runtimes plus 'all' option
- [ ] Existing files are skipped unless force=true
- [ ] Claude global installs register hook in settings.json
- [ ] VERSION file is written with package version
- [ ] Hook registration merges with existing hooks, doesn't overwrite
</success_criteria>

<output>
After completion, create `.planning/phases/05-implement-installation-workflow/05-03-SUMMARY.md`
</output>
