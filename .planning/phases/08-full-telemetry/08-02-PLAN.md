---
phase: 08-full-telemetry
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/ai/types.ts
  - src/ai/service.ts
  - src/ai/telemetry/logger.ts
  - src/orchestration/types.ts
  - src/orchestration/runner.ts
  - src/config/schema.ts
autonomous: true

must_haves:
  truths:
    - "TelemetryEntry has thinking, filesRead, and costSource fields"
    - "RunLog.summary has totalCostUsd, costAvailable, totalFilesRead, and uniqueFilesRead fields"
    - "RunSummary has totalCostUsd, costAvailable, totalFilesRead, and uniqueFilesRead fields"
    - "AIService.call() populates thinking as 'not supported', filesRead as empty, and costSource using estimateCost"
    - "TelemetryLogger.getSummary() computes totalFilesRead, uniqueFilesRead, and costAvailable"
    - "CommandRunner passes file path and size as context to each AI call for filesRead tracking"
    - "Config schema accepts telemetry.costThresholdUsd and ai.pricing overrides"
  artifacts:
    - path: "src/ai/types.ts"
      provides: "Extended TelemetryEntry with thinking, filesRead, costSource; extended RunLog.summary"
      contains: "thinking: string"
    - path: "src/ai/service.ts"
      provides: "AIService populating new telemetry fields using pricing module"
      contains: "estimateCost"
    - path: "src/ai/telemetry/logger.ts"
      provides: "TelemetryLogger computing cost/files summary fields"
      contains: "uniqueFilesRead"
    - path: "src/config/schema.ts"
      provides: "Config with costThresholdUsd and pricing overrides"
      contains: "costThresholdUsd"
    - path: "src/orchestration/types.ts"
      provides: "RunSummary with cost and files-read fields"
      contains: "totalCostUsd"
    - path: "src/orchestration/runner.ts"
      provides: "CommandRunner tracking file sizes for telemetry"
      contains: "sizeBytes"
  key_links:
    - from: "src/ai/service.ts"
      to: "src/ai/pricing.ts"
      via: "estimateCost import and call in AIService.call()"
      pattern: "import.*estimateCost.*from.*pricing"
    - from: "src/ai/service.ts"
      to: "src/ai/types.ts"
      via: "TelemetryEntry with new fields"
      pattern: "thinking.*filesRead.*costSource"
    - from: "src/orchestration/runner.ts"
      to: "node:fs/promises stat"
      via: "File size lookup for filesRead tracking"
      pattern: "stat\\(.*absolutePath"
---

<objective>
Extend types, wire pricing into the AI service, and update the logger/runner/config to populate the new telemetry fields.

Purpose: This is the core wiring plan -- after this, every AI call produces telemetry entries with thinking, filesRead, and cost data, and the config supports pricing overrides and cost thresholds.
Output: Six modified source files with extended types and populated telemetry fields.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-full-telemetry/08-RESEARCH.md
@.planning/phases/08-full-telemetry/08-01-SUMMARY.md

Source files to modify:
@src/ai/types.ts
@src/ai/service.ts
@src/ai/telemetry/logger.ts
@src/orchestration/types.ts
@src/orchestration/runner.ts
@src/config/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend types and config schema</name>
  <files>src/ai/types.ts, src/orchestration/types.ts, src/config/schema.ts</files>
  <action>
    **In `src/ai/types.ts`:**

    1. Import `CostSource` type from `./pricing.js` (re-export for convenience).

    2. Add `FileRead` interface above `TelemetryEntry`:
       ```typescript
       export interface FileRead {
         /** File path relative to project root */
         path: string;
         /** File size in bytes at time of read */
         sizeBytes: number;
       }
       ```

    3. Add three new fields to `TelemetryEntry` (after `retryCount`):
       ```typescript
       /** AI thinking/reasoning content. "not supported" when backend doesn't provide it */
       thinking: string;
       /** Files sent as context for this call */
       filesRead: FileRead[];
       /** How the cost was determined */
       costSource: CostSource;
       ```

    4. Add four new fields to `RunLog.summary` (after `errorCount`):
       ```typescript
       /** Whether cost data is available for all/most entries */
       costAvailable: boolean;
       /** Total file reads across all calls (including duplicates) */
       totalFilesRead: number;
       /** Unique files read (deduped by path) */
       uniqueFilesRead: number;
       ```
       Note: `totalCostUsd` already exists in the summary. Keep it.

    **In `src/orchestration/types.ts`:**

    5. Add four new fields to `RunSummary` (after `retryCount`):
       ```typescript
       /** Total estimated cost in USD */
       totalCostUsd: number;
       /** Whether cost data was available */
       costAvailable: boolean;
       /** Total file reads across all calls */
       totalFilesRead: number;
       /** Unique files read (deduped by path) */
       uniqueFilesRead: number;
       ```

    **In `src/config/schema.ts`:**

    6. Extend the telemetry sub-schema inside `AISchema`:
       ```typescript
       telemetry: z.object({
         keepRuns: z.number().min(0).default(10),
         /** Optional cost threshold in USD. Warn when exceeded. */
         costThresholdUsd: z.number().min(0).optional(),
       }).default({}),
       ```

    7. Add `pricing` field to `AISchema` (after telemetry):
       ```typescript
       /** Custom model pricing overrides (model ID -> rates) */
       pricing: z.record(z.object({
         inputCostPerMTok: z.number(),
         outputCostPerMTok: z.number(),
       })).optional(),
       ```

    Ensure `.default({})` on telemetry and `.default({})` on the parent AISchema remain so existing configs stay valid.
  </action>
  <verify>
    `npx tsc --noEmit` -- expect type errors in service.ts, logger.ts, runner.ts (they don't populate new fields yet). The type definitions themselves should be valid.
  </verify>
  <done>
    TelemetryEntry has thinking, filesRead, costSource. RunLog.summary has costAvailable, totalFilesRead, uniqueFilesRead. RunSummary has totalCostUsd, costAvailable, totalFilesRead, uniqueFilesRead. Config accepts costThresholdUsd and pricing overrides.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire pricing into AIService and extend TelemetryLogger</name>
  <files>src/ai/service.ts, src/ai/telemetry/logger.ts</files>
  <action>
    **In `src/ai/service.ts`:**

    1. Import `estimateCost` from `./pricing.js` and import `FileRead` from `./types.js`.

    2. Extend `AIServiceOptions` to include pricing config:
       ```typescript
       export interface AIServiceOptions {
         timeoutMs: number;
         maxRetries: number;
         telemetry: {
           keepRuns: number;
           costThresholdUsd?: number;
         };
         /** Custom pricing overrides from config */
         pricingOverrides?: Record<string, import('./pricing.js').ModelPricing>;
       }
       ```

    3. In the `call()` method, after getting a successful response, compute cost using `estimateCost`:
       ```typescript
       const costResult = estimateCost(
         response.model,
         response.inputTokens,
         response.outputTokens,
         response.costUsd > 0 ? response.costUsd : undefined,
         this.options.pricingOverrides,
       );
       ```

    4. Update the successful entry in `logger.addEntry()` to include new fields:
       - `thinking: 'not supported'` (marker value per CONTEXT.md -- current architecture doesn't capture thinking)
       - `filesRead: []` (will be populated by callers who know which files were sent; keep empty at service level for now)
       - `costSource: costResult.source`
       - `costUsd: costResult.costUsd` (replace the existing `costUsd: response.costUsd` with the pricing-resolved value)

    5. Update the error entry in the catch block to include:
       - `thinking: 'not supported'`
       - `filesRead: []`
       - `costSource: 'unavailable' as const`

    6. Add a public method `addFilesReadToLastEntry(filesRead: FileRead[]): void` that lets the CommandRunner attach file info after the call completes. This method sets `filesRead` on the last entry in the logger:
       ```typescript
       addFilesReadToLastEntry(filesRead: FileRead[]): void {
         this.logger.setFilesReadOnLastEntry(filesRead);
       }
       ```

    **In `src/ai/telemetry/logger.ts`:**

    7. Import `FileRead` from `../types.js`.

    8. Add `setFilesReadOnLastEntry(filesRead: FileRead[]): void` method that updates the last entry's filesRead array.

    9. Update `getSummary()` to compute the new summary fields:
       - `costAvailable`: true if at least one entry has `costSource !== 'unavailable'`
       - `totalFilesRead`: sum of all entries' `filesRead.length`
       - `uniqueFilesRead`: count of unique file paths across all entries (use a `Set<string>`)
       Note: `totalCostUsd` is already summed from entries. Keep it.
  </action>
  <verify>
    `npx tsc --noEmit` -- type errors should be reduced. Service and logger should compile. Runner may still have errors (Task 3).
  </verify>
  <done>
    AIService.call() computes cost via estimateCost, sets thinking to "not supported", and initializes filesRead as empty. TelemetryLogger computes costAvailable, totalFilesRead, uniqueFilesRead in getSummary(). addFilesReadToLastEntry allows callers to attach file metadata.
  </done>
</task>

<task type="auto">
  <name>Task 3: Track file sizes in CommandRunner and populate filesRead</name>
  <files>src/orchestration/runner.ts</files>
  <action>
    1. Import `stat` from `node:fs/promises` (add to existing import).

    2. In `executeGenerate()`, after each successful AI call in the file task lambda:
       - Get file size: `const fileStat = await stat(task.absolutePath);`
       - Call `this.aiService.addFilesReadToLastEntry([{ path: task.path, sizeBytes: fileStat.size }]);`
       Note: The file was already read (sourceContent) earlier in the lambda. We're recording that it was sent as context.

    3. In `executeUpdate()`, same pattern:
       - Get file size after the AI call
       - Call `this.aiService.addFilesReadToLastEntry([{ path: file.path, sizeBytes: fileStat.size }]);`

    4. Update the RunSummary construction in both `executeGenerate()` and `executeUpdate()` to include the new fields from `aiSummary`:
       ```typescript
       const summary: RunSummary = {
         filesProcessed,
         filesFailed,
         filesSkipped: 0,
         totalCalls: aiSummary.totalCalls,
         totalInputTokens: aiSummary.totalInputTokens,
         totalOutputTokens: aiSummary.totalOutputTokens,
         totalDurationMs,
         errorCount: aiSummary.errorCount,
         retryCount: 0,
         totalCostUsd: aiSummary.totalCostUsd,
         costAvailable: aiSummary.costAvailable,
         totalFilesRead: aiSummary.totalFilesRead,
         uniqueFilesRead: aiSummary.uniqueFilesRead,
       };
       ```

    5. For root document tasks in `executeGenerate()` Phase 3, the root task prompt is built from aggregated content, not a single file. Set filesRead to empty for root tasks (no individual source file to track).
  </action>
  <verify>
    `npx tsc --noEmit` passes with zero errors. All types are consistent across the chain.
  </verify>
  <done>
    CommandRunner tracks file sizes and attaches them to telemetry entries. RunSummary includes totalCostUsd, costAvailable, totalFilesRead, uniqueFilesRead. `npx tsc --noEmit` passes cleanly.
  </done>
</task>

</tasks>

<verification>
```bash
npx tsc --noEmit
npx vitest run src/ai/pricing.test.ts
```
Both pass. The type system enforces that all new fields are populated at every call site.
</verification>

<success_criteria>
- `npx tsc --noEmit` passes with zero errors
- TelemetryEntry includes thinking, filesRead, costSource in logged JSON
- RunLog.summary includes costAvailable, totalFilesRead, uniqueFilesRead
- RunSummary includes totalCostUsd, costAvailable, totalFilesRead, uniqueFilesRead
- Config schema accepts ai.telemetry.costThresholdUsd and ai.pricing overrides
- Existing tests (if any) still pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-full-telemetry/08-02-SUMMARY.md`
</output>
