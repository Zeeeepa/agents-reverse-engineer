---
phase: 08-full-telemetry
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/ai/pricing.ts
  - src/ai/pricing.test.ts
autonomous: true

must_haves:
  truths:
    - "estimateCost returns CLI-reported cost when available and non-zero"
    - "estimateCost falls back to pricing table when CLI cost is unavailable"
    - "estimateCost returns unavailable source when model is not in pricing table"
    - "lookupPricing matches model IDs with date suffixes via prefix matching"
    - "lookupPricing prefers longer prefix keys over shorter ones to avoid ambiguity"
    - "formatCost returns $X.XXXX with 4-decimal precision for available costs"
    - "formatCost returns N/A when cost is unavailable"
    - "Config pricing overrides take precedence over hardcoded defaults"
  artifacts:
    - path: "src/ai/pricing.ts"
      provides: "Cost estimation engine with pricing table, prefix matching, and format helpers"
      exports: ["ModelPricing", "CostSource", "CostEstimate", "DEFAULT_MODEL_PRICING", "lookupPricing", "estimateCost", "formatCost", "formatTokens"]
    - path: "src/ai/pricing.test.ts"
      provides: "Test suite covering all pricing engine behaviors"
      min_lines: 60
  key_links:
    - from: "src/ai/pricing.ts"
      to: "DEFAULT_MODEL_PRICING"
      via: "lookupPricing uses prefix matching against pricing table keys"
      pattern: "model\\.startsWith\\(key\\)"
---

<objective>
Build a cost estimation engine with hardcoded pricing for major AI models and prefix-based model ID matching.

Purpose: Provides the pricing logic that Phase 8 wiring will use to estimate per-call and per-run costs. This is pure business logic with defined inputs/outputs -- ideal for TDD.
Output: `src/ai/pricing.ts` with full test coverage via `src/ai/pricing.test.ts`
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-full-telemetry/08-RESEARCH.md

Key reference: The research document contains the exact pricing table, interface definitions, and code examples for the pricing engine. Follow the patterns there precisely.

Existing codebase conventions:
- ESM with NodeNext resolution (import with .js extensions)
- JSDoc on all exports
- 4-decimal precision for all cost values (Number(cost.toFixed(4)))
- Test runner: vitest (configured in package.json, no test files exist yet)
</context>

<feature>
  <name>Cost estimation engine</name>
  <files>src/ai/pricing.ts, src/ai/pricing.test.ts</files>
  <behavior>
    The pricing module exports these functions and types:

    **Types:**
    - `ModelPricing { inputCostPerMTok: number; outputCostPerMTok: number; }`
    - `CostSource = 'cli-reported' | 'estimated' | 'unavailable'`
    - `CostEstimate { costUsd: number; source: CostSource; }`

    **Constants:**
    - `DEFAULT_MODEL_PRICING: Record<string, ModelPricing>` -- 15 models across Claude, GPT, Gemini (see RESEARCH.md for exact values)

    **Functions:**
    - `lookupPricing(model, overrides?) -> ModelPricing | undefined`
      - Exact match: `lookupPricing('claude-opus-4-5')` -> returns pricing
      - Prefix match: `lookupPricing('claude-opus-4-5-20251101')` -> returns pricing for 'claude-opus-4-5'
      - Longest prefix wins: `lookupPricing('claude-opus-4-5-20251101')` matches 'claude-opus-4-5' not 'claude-opus-4'
      - Unknown model: `lookupPricing('custom-model')` -> undefined
      - Config overrides: `lookupPricing('my-model', { 'my-model': { inputCostPerMTok: 1, outputCostPerMTok: 5 } })` -> returns override pricing

    - `estimateCost(model, inputTokens, outputTokens, cliReportedCost?, overrides?) -> CostEstimate`
      - CLI cost available: `estimateCost('claude-sonnet-4', 1000, 100, 0.0180)` -> `{ costUsd: 0.018, source: 'cli-reported' }`
      - CLI cost zero/undefined: `estimateCost('claude-sonnet-4', 1000000, 100000, 0)` -> `{ costUsd: 4.5, source: 'estimated' }` (3 * 1 + 15 * 0.1)
      - Unknown model no CLI cost: `estimateCost('unknown', 1000, 100)` -> `{ costUsd: 0, source: 'unavailable' }`
      - 4-decimal precision: costs always rounded via `Number(cost.toFixed(4))`

    - `formatCost(costUsd, available) -> string`
      - Available: `formatCost(0.1234, true)` -> `"$0.1234"`
      - Unavailable: `formatCost(0, false)` -> `"N/A"`

    - `formatTokens(count) -> string`
      - Millions: `formatTokens(1_500_000)` -> `"1.5M"`
      - Thousands: `formatTokens(42_000)` -> `"42K"`
      - Small: `formatTokens(500)` -> `"500"`
  </behavior>
  <implementation>
    Follow the code examples in RESEARCH.md precisely. Key implementation details:
    - Sort pricing keys longest-first for prefix matching to avoid ambiguity
    - Merge overrides into defaults BEFORE lookup (spread: `{ ...DEFAULT_MODEL_PRICING, ...overrides }`)
    - CLI-reported cost takes precedence when > 0
    - All costs use `Number(cost.toFixed(4))` for 4-decimal precision
    - Include all 15 models from RESEARCH.md DEFAULT_MODEL_PRICING table
  </implementation>
</feature>

<verification>
```bash
npx vitest run src/ai/pricing.test.ts
```
All tests pass. No type errors (`npx tsc --noEmit`).
</verification>

<success_criteria>
- src/ai/pricing.ts exports ModelPricing, CostSource, CostEstimate, DEFAULT_MODEL_PRICING, lookupPricing, estimateCost, formatCost, formatTokens
- src/ai/pricing.test.ts covers all behavior cases listed above
- `npx vitest run src/ai/pricing.test.ts` passes
- `npx tsc --noEmit` passes
</success_criteria>

<output>
After completion, create `.planning/phases/08-full-telemetry/08-01-SUMMARY.md`
</output>
