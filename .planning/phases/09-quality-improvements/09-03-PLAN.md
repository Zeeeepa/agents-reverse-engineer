---
phase: 09-quality-improvements
plan: 03
type: execute
wave: 2
depends_on: ["09-01", "09-02"]
files_modified:
  - src/quality/inconsistency/code-vs-code.ts
  - src/quality/inconsistency/reporter.ts
  - src/quality/index.ts
  - src/orchestration/runner.ts
  - src/orchestration/types.ts
  - src/cli/generate.ts
  - src/cli/update.ts
autonomous: true

must_haves:
  truths:
    - "checkCodeVsCode detects duplicate exports (same symbol exported from multiple files in same directory)"
    - "checkCodeVsCode scopes checks to per-directory file groups to avoid false positives"
    - "buildInconsistencyReport aggregates all issues with counts by type and severity"
    - "formatReportForCli produces human-readable output with severity icons and file locations"
    - "During generate, old .sum content is cached before Phase 1 so code-vs-doc can detect stale documentation contradicting current code"
    - "During generate, freshly generated .sum files are also checked to detect LLM omissions"
    - "After a generate or update run, if inconsistencies were detected, the report prints to stderr"
    - "RunSummary includes inconsistency counts so callers can inspect results"
    - "Inconsistency detection runs as a post-analysis pass -- does not modify the generation pipeline"
    - "The quality barrel index exports all public types and functions from inconsistency and density submodules"
  artifacts:
    - path: "src/quality/inconsistency/code-vs-code.ts"
      provides: "Cross-file inconsistency detection scoped to per-directory groups"
      exports: ["checkCodeVsCode"]
    - path: "src/quality/inconsistency/reporter.ts"
      provides: "Structured report builder and CLI formatter for inconsistency results"
      exports: ["buildInconsistencyReport", "formatReportForCli"]
    - path: "src/quality/index.ts"
      provides: "Barrel exports for the quality module"
      exports: ["checkCodeVsDoc", "extractExports", "checkCodeVsCode", "buildInconsistencyReport", "formatReportForCli", "validateFindability"]
    - path: "src/orchestration/runner.ts"
      provides: "CommandRunner with post-analysis inconsistency detection phase"
    - path: "src/orchestration/types.ts"
      provides: "RunSummary extended with inconsistency counts"
  key_links:
    - from: "src/quality/inconsistency/code-vs-code.ts"
      to: "src/quality/types.ts"
      via: "imports CodeCodeInconsistency type from Plan 01"
      pattern: "import.*CodeCodeInconsistency.*from.*types"
    - from: "src/quality/inconsistency/reporter.ts"
      to: "src/quality/types.ts"
      via: "imports InconsistencyReport and Inconsistency types"
      pattern: "import.*InconsistencyReport.*from.*types"
    - from: "src/orchestration/runner.ts"
      to: "src/quality/index.ts"
      via: "imports inconsistency detection functions for post-analysis pass"
      pattern: "import.*from.*quality"
    - from: "src/cli/generate.ts"
      to: "src/orchestration/runner.ts"
      via: "uses RunSummary which now includes inconsistency data"
      pattern: "runner\\.executeGenerate"
---

<objective>
Implement cross-file inconsistency detection, the structured report builder, and wire inconsistency detection into the generate/update command pipeline as a post-analysis pass.

Purpose: Completes the inconsistency detection feature (INCON-02, INCON-03) and integrates all quality checks into the existing command pipeline. After this plan, running `are generate` or `are update` will automatically check for inconsistencies and print a report if any are found.
Output: `src/quality/inconsistency/code-vs-code.ts`, `src/quality/inconsistency/reporter.ts`, `src/quality/index.ts`, updated `src/orchestration/runner.ts`, updated `src/orchestration/types.ts`, updated `src/cli/generate.ts`, updated `src/cli/update.ts`
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/09-quality-improvements/09-RESEARCH.md
@.planning/phases/09-quality-improvements/09-01-SUMMARY.md
@.planning/phases/09-quality-improvements/09-02-SUMMARY.md

Key references from RESEARCH.md:
- Example 2: checkCodeVsCode with duplicate export detection
- Example 3: InconsistencyReport and formatReportForCli
- Pattern 1: Inconsistency detection as post-analysis pass (runs AFTER file analysis completes)
- Pitfall 1: Stale .sum comparison during generate -- cache old .sum content BEFORE overwriting
- Pitfall 2: Cross-file false positives -- scope to per-directory
- Pitfall 5: Don't run AI-based detection on every file -- heuristic only

Existing files to modify:
@src/orchestration/runner.ts
@src/orchestration/types.ts
@src/cli/generate.ts
@src/cli/update.ts

Plan 01 outputs (will exist by Wave 2):
- src/quality/types.ts -- all shared types
- src/quality/inconsistency/code-vs-doc.ts -- extractExports, checkCodeVsDoc

Plan 02 outputs (will exist by Wave 2):
- src/quality/density/validator.ts -- validateFindability
</context>

<tasks>

<task type="auto">
  <name>Task 1: Code-vs-code detection and report builder (INCON-02, INCON-03)</name>
  <files>src/quality/inconsistency/code-vs-code.ts, src/quality/inconsistency/reporter.ts, src/quality/index.ts</files>
  <action>
    **Create `src/quality/inconsistency/code-vs-code.ts`:**

    Export `checkCodeVsCode(files: Array<{ path: string; content: string }>): CodeCodeInconsistency[]`.

    Implementation:
    1. Import `extractExports` from `./code-vs-doc.js` (Plan 01 output) and `CodeCodeInconsistency` from `../types.js`
    2. For each file, call `extractExports` to get export names
    3. Build a `Map<string, string[]>` of export name -> file paths
    4. For each export name that appears in more than one file, create a `CodeCodeInconsistency`:
       - `type: 'code-vs-code'`
       - `severity: 'warning'`
       - `files`: array of file paths that export this symbol
       - `description`: `Symbol "${name}" exported from ${count} files`
       - `pattern`: `'duplicate-export'`
    5. Return all detected inconsistencies

    This is a heuristic-only check (no AI calls). Scoped to the files passed in -- the caller groups by directory.

    **Create `src/quality/inconsistency/reporter.ts`:**

    Export two functions:

    1. `buildInconsistencyReport(issues: Inconsistency[], metadata: { projectRoot: string; filesChecked: number; durationMs: number }): InconsistencyReport`
       - Aggregates issues into the report structure from `types.ts`
       - Computes summary counts: total, codeVsDoc, codeVsCode, errors, warnings, info
       - Sets `metadata.timestamp` to `new Date().toISOString()`

    2. `formatReportForCli(report: InconsistencyReport): string`
       - Header: `=== Inconsistency Report ===`
       - Stats: `Checked {N} files in {M}ms`
       - Count: `Found {N} issue(s)`
       - Per issue: `[ERROR|WARN|INFO] {description}` followed by `  File: {path}` for code-vs-doc or `  Files: {paths}` for code-vs-code
       - Use plain text (no picocolors) -- keep the reporter pure so it can be tested easily. Color can be added by the CLI layer if needed.

    Import types from `../types.js`.

    **Create `src/quality/index.ts` (barrel):**

    Re-export from all submodules:
    - From `./types.js`: all types (`CodeDocInconsistency`, `CodeCodeInconsistency`, `Inconsistency`, `InconsistencyReport`, `InconsistencySeverity`)
    - From `./inconsistency/code-vs-doc.js`: `extractExports`, `checkCodeVsDoc`
    - From `./inconsistency/code-vs-code.js`: `checkCodeVsCode`
    - From `./inconsistency/reporter.js`: `buildInconsistencyReport`, `formatReportForCli`
    - From `./density/validator.js`: `validateFindability`, `FindabilityResult`
  </action>
  <verify>
    ```bash
    npx tsc --noEmit
    ```
    Confirm all exports resolve from `src/quality/index.ts`.
  </verify>
  <done>
    `checkCodeVsCode` detects duplicate exports across file groups. `buildInconsistencyReport` aggregates issues. `formatReportForCli` produces human-readable output. `src/quality/index.ts` barrel exports everything. `npx tsc --noEmit` passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire inconsistency detection into generate/update pipeline</name>
  <files>src/orchestration/types.ts, src/orchestration/runner.ts, src/cli/generate.ts, src/cli/update.ts</files>
  <action>
    **Extend `RunSummary` in `src/orchestration/types.ts`:**

    Add three optional fields:
    ```typescript
    /** Number of code-vs-doc inconsistencies detected */
    inconsistenciesCodeVsDoc?: number;
    /** Number of code-vs-code inconsistencies detected */
    inconsistenciesCodeVsCode?: number;
    /** Full inconsistency report (undefined if no checks ran) */
    inconsistencyReport?: InconsistencyReport;
    ```
    Import `InconsistencyReport` from `../quality/index.js`.

    **Cache old .sum content BEFORE Phase 1 in `CommandRunner.executeGenerate`:**

    Before Phase 1 (file analysis) begins, read all existing `.sum` files for the files about to be processed and store them in a `Map<string, SumFileContent>` keyed by source file path. This captures the OLD documentation before Phase 1 overwrites the `.sum` files. Use `readSumFile` from writers/sum for each `${filePath}.sum` that exists on disk. Wrap each read in try/catch -- if a `.sum` file doesn't exist or fails to parse, skip it (no old content to compare). Store this map in a local variable `oldSumCache`.

    **Add post-analysis inconsistency pass in `CommandRunner.executeGenerate`:**

    After Phase 1 (file analysis) completes and before Phase 2 (directory docs), add an inconsistency detection pass:

    1. Import `readFile` (already imported), `readSumFile` and `SumFileContent` from writers/sum, `checkCodeVsDoc`, `checkCodeVsCode`, `buildInconsistencyReport`, `formatReportForCli` from quality barrel.
    2. Collect all successfully processed file paths from Phase 1 pool results.
    3. Group files by directory (using `path.dirname`).
    4. For each directory group:
       a. Read each source file content.
       b. **Old-doc check (detects stale documentation):** If `oldSumCache` has an entry for this file, run `checkCodeVsDoc(sourceContent, oldSumContent, filePath)`. This detects existing documentation that contradicts current code (e.g., exports that were removed or renamed since the last run).
       c. **New-doc check (detects LLM omissions):** Read the freshly generated `.sum` file from disk and run `checkCodeVsDoc(sourceContent, newSumContent, filePath)`. This catches cases where the LLM missed exports during the current run.
       d. Collect all file objects `{ path, content }` and run `checkCodeVsCode(files)` on the directory group
    5. If any issues found, call `buildInconsistencyReport` and `formatReportForCli`, then print the report to stderr via `console.error`. Label old-doc issues with a note in the description (e.g., append " (stale documentation)") to distinguish them from new-doc issues.
    6. Attach counts to the RunSummary.

    Keep this pass lightweight -- it only reads files already in memory or just written to disk. No AI calls. The `oldSumCache` read is I/O but runs once before pool processing and is bounded by the number of files being processed.

    **For `CommandRunner.executeUpdate`:** Same inconsistency pass but only for the files that were re-analyzed (not all project files). Add after the pool results are collected.

    **In `src/cli/generate.ts` and `src/cli/update.ts`:** No changes needed -- the inconsistency report is handled inside `CommandRunner`. The commands already use `RunSummary` from the runner, which will now include inconsistency data.

    **Important implementation notes:**
    - The inconsistency pass must NOT throw -- wrap in try/catch. If it fails, log a warning and continue.
    - Use `console.error` for the report (stderr) to not interfere with JSON output.
    - Only print the report if `report.summary.total > 0`.
    - Do NOT modify the existing Phase 1, Phase 2, or Phase 3 logic in the runner. The inconsistency pass is a new step inserted between Phase 1 and Phase 2.
  </action>
  <verify>
    ```bash
    npx tsc --noEmit
    ```
    Confirm RunSummary has the new inconsistency fields.
    Confirm the inconsistency pass exists between Phase 1 and Phase 2 in `executeGenerate`.
    Confirm the inconsistency pass exists after pool results in `executeUpdate`.
  </verify>
  <done>
    RunSummary includes inconsistency counts. `executeGenerate` caches old .sum content before Phase 1 and runs dual code-vs-doc checks (old-doc for stale documentation, new-doc for LLM omissions). `executeUpdate` runs a post-analysis inconsistency detection pass. Report prints to stderr when issues found. Pass is non-throwing (try/catch wrapped). `npx tsc --noEmit` passes.
  </done>
</task>

</tasks>

<verification>
```bash
# Type check
npx tsc --noEmit

# Confirm quality barrel has all exports
grep "export" src/quality/index.ts | wc -l
# Expected: at least 8 lines of exports

# Confirm RunSummary has inconsistency fields
grep "inconsistenc" src/orchestration/types.ts
# Expected: multiple matches for the new fields

# Confirm runner imports from quality
grep "quality" src/orchestration/runner.ts
# Expected: at least 1 import from quality barrel

# Run all tests
npx vitest run
```
</verification>

<success_criteria>
- src/quality/inconsistency/code-vs-code.ts exports checkCodeVsCode
- src/quality/inconsistency/reporter.ts exports buildInconsistencyReport and formatReportForCli
- src/quality/index.ts barrel exports all quality module public API
- RunSummary in types.ts includes inconsistencyReport, inconsistenciesCodeVsDoc, inconsistenciesCodeVsCode fields
- CommandRunner.executeGenerate caches old .sum content before Phase 1
- CommandRunner.executeGenerate runs dual code-vs-doc checks (old-doc + new-doc) between Phase 1 and Phase 2
- CommandRunner.executeUpdate runs inconsistency pass after file analysis
- Inconsistency report prints to stderr only when issues exist
- `npx tsc --noEmit` passes
- `npx vitest run` passes (including Plan 01 tests)
</success_criteria>

<output>
After completion, create `.planning/phases/09-quality-improvements/09-03-SUMMARY.md`
</output>
