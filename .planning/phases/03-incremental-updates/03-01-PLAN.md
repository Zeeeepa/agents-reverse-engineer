---
phase: 03-incremental-updates
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/state/types.ts
  - src/state/migrations.ts
  - src/state/database.ts
  - src/state/index.ts
autonomous: true

must_haves:
  truths:
    - "State database opens and closes without error"
    - "Schema migrations run on first open"
    - "File records can be inserted, queried, and updated"
    - "Run records store commit hash and completion timestamp"
  artifacts:
    - path: "src/state/types.ts"
      provides: "State types (FileRecord, RunRecord)"
      exports: ["FileRecord", "RunRecord", "StateDatabase"]
    - path: "src/state/database.ts"
      provides: "SQLite wrapper with WAL mode and migrations"
      exports: ["StateDatabase", "openDatabase"]
    - path: "src/state/migrations.ts"
      provides: "Schema migrations with user_version pragma"
      exports: ["CURRENT_SCHEMA_VERSION", "migrateSchema"]
    - path: "src/state/index.ts"
      provides: "Public exports"
      exports: ["StateDatabase", "openDatabase", "FileRecord", "RunRecord"]
  key_links:
    - from: "src/state/database.ts"
      to: "better-sqlite3"
      via: "import Database from 'better-sqlite3'"
      pattern: "import.*better-sqlite3"
    - from: "src/state/database.ts"
      to: "src/state/migrations.ts"
      via: "migrateSchema call"
      pattern: "migrateSchema\\("
---

<objective>
Create SQLite state management layer for tracking file generation state.

Purpose: Enable incremental updates by persisting file hashes, generation timestamps, and run metadata. SQLite provides fast lookups and ACID guarantees for large repos.

Output: State module with types, database wrapper, and schema migrations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-incremental-updates/03-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install better-sqlite3 and create state types</name>
  <files>
    package.json
    src/state/types.ts
  </files>
  <action>
    Install better-sqlite3 and its TypeScript types:
    ```bash
    npm install better-sqlite3
    npm install -D @types/better-sqlite3
    ```

    Create src/state/types.ts with interfaces for state persistence:

    ```typescript
    /**
     * State types for tracking file generation
     */
    import type Database from 'better-sqlite3';

    /**
     * Record of a file's generation state
     */
    export interface FileRecord {
      /** Relative path from project root */
      path: string;
      /** SHA-256 hash of file content */
      content_hash: string;
      /** ISO timestamp when .sum was generated (null if not yet generated) */
      sum_generated_at: string | null;
      /** Commit hash when file was last analyzed */
      last_analyzed_commit: string | null;
    }

    /**
     * Record of a generation/update run
     */
    export interface RunRecord {
      /** Auto-incremented ID */
      id: number;
      /** Git commit hash at run time */
      commit_hash: string;
      /** ISO timestamp when run completed */
      completed_at: string;
      /** Number of files analyzed in this run */
      files_analyzed: number;
      /** Number of files skipped (unchanged) */
      files_skipped: number;
    }

    /**
     * Interface for state database operations
     */
    export interface StateDatabase {
      /** Get file record by path */
      getFile(path: string): FileRecord | undefined;
      /** Insert or update file record */
      upsertFile(record: FileRecord): void;
      /** Delete file record */
      deleteFile(path: string): void;
      /** Get all file records */
      getAllFiles(): FileRecord[];
      /** Get the most recent run record */
      getLastRun(): RunRecord | undefined;
      /** Insert a new run record */
      insertRun(run: Omit<RunRecord, 'id'>): number;
      /** Close the database connection */
      close(): void;
      /** Get the underlying database for transactions */
      getDb(): Database.Database;
    }
    ```

    Use the project's ESM patterns (no .js extension in imports within the module).
  </action>
  <verify>
    npm install completes without error.
    `cat src/state/types.ts` shows FileRecord, RunRecord, and StateDatabase interfaces.
  </verify>
  <done>
    better-sqlite3 installed; types.ts exports FileRecord, RunRecord, StateDatabase.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create schema migrations with user_version pragma</name>
  <files>src/state/migrations.ts</files>
  <action>
    Create src/state/migrations.ts following the pattern from RESEARCH.md:

    ```typescript
    /**
     * Schema migrations using SQLite user_version pragma
     */
    import type Database from 'better-sqlite3';

    /** Current schema version */
    export const CURRENT_SCHEMA_VERSION = 1;

    /**
     * Apply schema migrations from `fromVersion` to `toVersion`.
     * Uses transaction for atomicity.
     */
    export function migrateSchema(
      db: Database.Database,
      fromVersion: number,
      toVersion: number
    ): void {
      const migrate = db.transaction(() => {
        if (fromVersion < 1) {
          // Initial schema
          db.exec(`
            CREATE TABLE files (
              path TEXT PRIMARY KEY,
              content_hash TEXT NOT NULL,
              sum_generated_at TEXT,
              last_analyzed_commit TEXT
            )
          `);

          db.exec(`
            CREATE TABLE runs (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              commit_hash TEXT NOT NULL,
              completed_at TEXT NOT NULL,
              files_analyzed INTEGER NOT NULL,
              files_skipped INTEGER NOT NULL
            )
          `);

          // Index for faster queries by commit
          db.exec(`
            CREATE INDEX idx_runs_commit ON runs(commit_hash)
          `);
        }

        // Future migrations would go here:
        // if (fromVersion < 2) { ... }

        db.pragma(`user_version = ${toVersion}`);
      });

      migrate();
    }
    ```

    Use db.transaction() wrapper for atomic migration. Schema includes:
    - files table: path (PK), content_hash, sum_generated_at, last_analyzed_commit
    - runs table: id (auto), commit_hash, completed_at, files_analyzed, files_skipped
    - Index on runs.commit_hash for fast lookups
  </action>
  <verify>
    `cat src/state/migrations.ts` shows CURRENT_SCHEMA_VERSION export and migrateSchema function.
  </verify>
  <done>
    migrations.ts exports CURRENT_SCHEMA_VERSION (1) and migrateSchema function.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create SQLite database wrapper with prepared statements</name>
  <files>
    src/state/database.ts
    src/state/index.ts
  </files>
  <action>
    Create src/state/database.ts implementing StateDatabase interface:

    ```typescript
    /**
     * SQLite state database with prepared statements
     */
    import Database from 'better-sqlite3';
    import type { FileRecord, RunRecord, StateDatabase } from './types.js';
    import { CURRENT_SCHEMA_VERSION, migrateSchema } from './migrations.js';

    /**
     * Opens the state database, applying migrations if needed.
     * Uses WAL mode for performance.
     *
     * @param dbPath - Path to the SQLite database file
     */
    export function openDatabase(dbPath: string): StateDatabase {
      const db = new Database(dbPath);

      // Enable WAL mode for better concurrent read performance
      db.pragma('journal_mode = WAL');

      // Check and apply migrations
      const version = db.pragma('user_version', { simple: true }) as number;
      if (version < CURRENT_SCHEMA_VERSION) {
        migrateSchema(db, version, CURRENT_SCHEMA_VERSION);
      }

      // Prepared statements for performance
      const getFileStmt = db.prepare<[string], FileRecord>(
        'SELECT path, content_hash, sum_generated_at, last_analyzed_commit FROM files WHERE path = ?'
      );

      const upsertFileStmt = db.prepare<[string, string, string | null, string | null]>(`
        INSERT INTO files (path, content_hash, sum_generated_at, last_analyzed_commit)
        VALUES (?, ?, ?, ?)
        ON CONFLICT(path) DO UPDATE SET
          content_hash = excluded.content_hash,
          sum_generated_at = excluded.sum_generated_at,
          last_analyzed_commit = excluded.last_analyzed_commit
      `);

      const deleteFileStmt = db.prepare<[string]>(
        'DELETE FROM files WHERE path = ?'
      );

      const getAllFilesStmt = db.prepare<[], FileRecord>(
        'SELECT path, content_hash, sum_generated_at, last_analyzed_commit FROM files'
      );

      const getLastRunStmt = db.prepare<[], RunRecord>(
        'SELECT id, commit_hash, completed_at, files_analyzed, files_skipped FROM runs ORDER BY id DESC LIMIT 1'
      );

      const insertRunStmt = db.prepare<[string, string, number, number]>(`
        INSERT INTO runs (commit_hash, completed_at, files_analyzed, files_skipped)
        VALUES (?, ?, ?, ?)
      `);

      return {
        getFile(path: string): FileRecord | undefined {
          return getFileStmt.get(path);
        },

        upsertFile(record: FileRecord): void {
          upsertFileStmt.run(
            record.path,
            record.content_hash,
            record.sum_generated_at,
            record.last_analyzed_commit
          );
        },

        deleteFile(path: string): void {
          deleteFileStmt.run(path);
        },

        getAllFiles(): FileRecord[] {
          return getAllFilesStmt.all();
        },

        getLastRun(): RunRecord | undefined {
          return getLastRunStmt.get();
        },

        insertRun(run: Omit<RunRecord, 'id'>): number {
          const result = insertRunStmt.run(
            run.commit_hash,
            run.completed_at,
            run.files_analyzed,
            run.files_skipped
          );
          return Number(result.lastInsertRowid);
        },

        close(): void {
          db.close();
        },

        getDb(): Database.Database {
          return db;
        },
      };
    }
    ```

    Create src/state/index.ts with public exports:

    ```typescript
    /**
     * State management module
     *
     * Provides SQLite-based state persistence for tracking file generation.
     */
    export { openDatabase } from './database.js';
    export type { FileRecord, RunRecord, StateDatabase } from './types.js';
    ```

    Key implementation details:
    - WAL mode enabled via pragma for concurrent read performance
    - Prepared statements created once at open time
    - UPSERT pattern for file records (INSERT ... ON CONFLICT)
    - All queries use parameterized statements (no SQL injection)
  </action>
  <verify>
    TypeScript compiles: `npm run build`
    Files exist: `ls src/state/`
  </verify>
  <done>
    database.ts implements StateDatabase with WAL mode and prepared statements.
    index.ts exports openDatabase, FileRecord, RunRecord, StateDatabase.
    TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes without TypeScript errors
2. `ls src/state/` shows types.ts, migrations.ts, database.ts, index.ts
3. better-sqlite3 and @types/better-sqlite3 in package.json
4. State module exports are importable: check via TypeScript compilation
</verification>

<success_criteria>
- State module created with SQLite wrapper
- Schema migrations using user_version pragma
- Prepared statements for all database operations
- WAL mode enabled for performance
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-incremental-updates/03-01-SUMMARY.md`
</output>
