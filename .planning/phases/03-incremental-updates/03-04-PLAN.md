---
phase: 03-incremental-updates
plan: 04
type: execute
wave: 3
depends_on: ["03-01", "03-02", "03-03"]
files_modified:
  - src/update/orchestrator.ts
  - src/update/index.ts
autonomous: true

must_haves:
  truths:
    - "Update detects files changed since last run"
    - "Only changed files are queued for analysis"
    - "Orphaned .sum files are cleaned up"
    - "Affected AGENTS.md files are regenerated"
    - "Run state is persisted after successful update"
  artifacts:
    - path: "src/update/orchestrator.ts"
      provides: "Update orchestration workflow"
      exports: ["UpdateOrchestrator", "createUpdateOrchestrator"]
    - path: "src/update/index.ts"
      provides: "Public exports for update module"
      exports: ["UpdateOrchestrator", "createUpdateOrchestrator", "UpdateOptions", "UpdateResult", "UpdateProgress"]
  key_links:
    - from: "src/update/orchestrator.ts"
      to: "src/state/database.ts"
      via: "openDatabase call"
      pattern: "openDatabase\\("
    - from: "src/update/orchestrator.ts"
      to: "src/change-detection/detector.ts"
      via: "getChangedFiles call"
      pattern: "getChangedFiles\\("
    - from: "src/update/orchestrator.ts"
      to: "src/update/orphan-cleaner.ts"
      via: "cleanupOrphans call"
      pattern: "cleanupOrphans\\("
---

<objective>
Create update orchestrator that coordinates the incremental update workflow.

Purpose: Ties together state management, change detection, orphan cleanup, and AGENTS.md regeneration into a cohesive update workflow. Handles the full lifecycle from detecting changes to persisting new state.

Output: Update orchestrator module that coordinates all update operations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-incremental-updates/03-RESEARCH.md
@.planning/phases/03-incremental-updates/03-01-SUMMARY.md
@.planning/phases/03-incremental-updates/03-02-SUMMARY.md
@.planning/phases/03-incremental-updates/03-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create update orchestrator</name>
  <files>src/update/orchestrator.ts</files>
  <action>
    Create src/update/orchestrator.ts implementing the update workflow:

    ```typescript
    /**
     * Update orchestrator
     *
     * Coordinates incremental documentation updates:
     * 1. Check git repository status
     * 2. Get last run from state database
     * 3. Detect changed files since last run
     * 4. Clean up orphaned .sum files
     * 5. Prepare analysis tasks for changed files
     * 6. Track affected directories for AGENTS.md regeneration
     * 7. Persist new state after successful completion
     */
    import * as path from 'node:path';
    import { mkdir } from 'node:fs/promises';
    import type { Config } from '../config/schema.js';
    import type { StateDatabase, FileRecord, RunRecord } from '../state/index.js';
    import { openDatabase } from '../state/index.js';
    import {
      isGitRepo,
      getCurrentCommit,
      getChangedFiles,
      computeContentHash,
      type FileChange,
    } from '../change-detection/index.js';
    import { cleanupOrphans, getAffectedDirectories } from './orphan-cleaner.js';
    import type {
      UpdateOptions,
      UpdateResult,
      UpdateProgress,
      CleanupResult,
    } from './types.js';

    /** State directory name (relative to project root) */
    const STATE_DIR = '.agents-reverse';
    /** State database filename */
    const STATE_DB = 'state.db';

    /**
     * Result of update preparation (before analysis).
     */
    export interface UpdatePlan {
      /** Files to analyze (added or modified) */
      filesToAnalyze: FileChange[];
      /** Files to skip (unchanged based on content hash) */
      filesToSkip: string[];
      /** Cleanup result (files to delete) */
      cleanup: CleanupResult;
      /** Directories that need AGENTS.md regeneration */
      affectedDirs: string[];
      /** Base commit (from last run or initial) */
      baseCommit: string;
      /** Current commit */
      currentCommit: string;
      /** Whether this is first run (no prior state) */
      isFirstRun: boolean;
    }

    /**
     * Orchestrates incremental documentation updates.
     */
    export class UpdateOrchestrator {
      private config: Config;
      private projectRoot: string;
      private db: StateDatabase | null = null;

      constructor(config: Config, projectRoot: string) {
        this.config = config;
        this.projectRoot = projectRoot;
      }

      /**
       * Get path to state database.
       */
      private getDbPath(): string {
        return path.join(this.projectRoot, STATE_DIR, STATE_DB);
      }

      /**
       * Ensure state directory exists and open database.
       */
      async openState(): Promise<StateDatabase> {
        if (this.db) return this.db;

        // Ensure state directory exists
        const stateDir = path.join(this.projectRoot, STATE_DIR);
        await mkdir(stateDir, { recursive: true });

        this.db = openDatabase(this.getDbPath());
        return this.db;
      }

      /**
       * Close database connection.
       */
      close(): void {
        if (this.db) {
          this.db.close();
          this.db = null;
        }
      }

      /**
       * Check prerequisites for update.
       *
       * @throws Error if not in a git repository
       */
      async checkPrerequisites(): Promise<void> {
        const isRepo = await isGitRepo(this.projectRoot);
        if (!isRepo) {
          throw new Error(
            `Not a git repository: ${this.projectRoot}\n` +
            'The update command requires a git repository for change detection.'
          );
        }
      }

      /**
       * Prepare update plan without executing analysis.
       *
       * @param options - Update options
       * @returns Update plan with files to analyze and cleanup actions
       */
      async preparePlan(options: UpdateOptions = {}): Promise<UpdatePlan> {
        await this.checkPrerequisites();
        const db = await this.openState();

        // Get current commit
        const currentCommit = await getCurrentCommit(this.projectRoot);

        // Get last run to determine base commit
        const lastRun = db.getLastRun();
        const isFirstRun = !lastRun;
        const baseCommit = lastRun?.commit_hash ?? currentCommit;

        // If first run or same commit, no committed changes
        let changes: FileChange[] = [];
        if (!isFirstRun && baseCommit !== currentCommit) {
          const result = await getChangedFiles(
            this.projectRoot,
            baseCommit,
            { includeUncommitted: options.includeUncommitted }
          );
          changes = result.changes;
        } else if (options.includeUncommitted) {
          // Even if no committed changes, check uncommitted
          const result = await getChangedFiles(
            this.projectRoot,
            currentCommit, // Use current as base (no committed diff)
            { includeUncommitted: true }
          );
          changes = result.changes;
        }

        // Separate files by status for different handling
        const filesToAnalyze = changes.filter(
          c => c.status === 'added' || c.status === 'modified' || c.status === 'renamed'
        );
        const deletedOrRenamed = changes.filter(
          c => c.status === 'deleted' || c.status === 'renamed'
        );

        // Filter out files that haven't actually changed (content hash match)
        const actuallyChanged: FileChange[] = [];
        const filesToSkip: string[] = [];

        for (const change of filesToAnalyze) {
          if (change.status === 'added') {
            // New files are always analyzed
            actuallyChanged.push(change);
          } else {
            // For modified/renamed, check content hash
            const filePath = path.join(this.projectRoot, change.path);
            try {
              const currentHash = await computeContentHash(filePath);
              const stored = db.getFile(change.path);

              if (!stored || stored.content_hash !== currentHash) {
                actuallyChanged.push(change);
              } else {
                filesToSkip.push(change.path);
              }
            } catch {
              // File can't be read - skip it
              filesToSkip.push(change.path);
            }
          }
        }

        // Cleanup orphans (deleted and renamed old paths)
        const cleanup = await cleanupOrphans(
          this.projectRoot,
          deletedOrRenamed,
          options.dryRun ?? false
        );

        // Get directories affected by changes (for AGENTS.md regeneration)
        const affectedDirs = Array.from(getAffectedDirectories(actuallyChanged));

        return {
          filesToAnalyze: actuallyChanged,
          filesToSkip,
          cleanup,
          affectedDirs,
          baseCommit,
          currentCommit,
          isFirstRun,
        };
      }

      /**
       * Update state for a successfully analyzed file.
       *
       * @param relativePath - Relative path to the file
       * @param contentHash - SHA-256 hash of file content
       * @param currentCommit - Current git commit hash
       */
      async recordFileAnalyzed(
        relativePath: string,
        contentHash: string,
        currentCommit: string
      ): Promise<void> {
        const db = await this.openState();
        db.upsertFile({
          path: relativePath,
          content_hash: contentHash,
          sum_generated_at: new Date().toISOString(),
          last_analyzed_commit: currentCommit,
        });
      }

      /**
       * Remove file from state (for deleted files).
       */
      async removeFileState(relativePath: string): Promise<void> {
        const db = await this.openState();
        db.deleteFile(relativePath);
      }

      /**
       * Record a completed update run.
       *
       * @param commitHash - Git commit hash at completion
       * @param filesAnalyzed - Number of files analyzed
       * @param filesSkipped - Number of files skipped
       * @returns Run ID
       */
      async recordRun(
        commitHash: string,
        filesAnalyzed: number,
        filesSkipped: number
      ): Promise<number> {
        const db = await this.openState();
        return db.insertRun({
          commit_hash: commitHash,
          completed_at: new Date().toISOString(),
          files_analyzed: filesAnalyzed,
          files_skipped: filesSkipped,
        });
      }

      /**
       * Get last run information.
       */
      async getLastRun(): Promise<RunRecord | undefined> {
        const db = await this.openState();
        return db.getLastRun();
      }

      /**
       * Check if this is the first run (no prior state).
       */
      async isFirstRun(): Promise<boolean> {
        const db = await this.openState();
        return !db.getLastRun();
      }
    }

    /**
     * Create an update orchestrator.
     */
    export function createUpdateOrchestrator(
      config: Config,
      projectRoot: string
    ): UpdateOrchestrator {
      return new UpdateOrchestrator(config, projectRoot);
    }
    ```

    Key implementation details:
    - State stored in `.agents-reverse/state.db`
    - Uses last run's commit hash as baseline
    - First run: no changes detected (user should use `generate` first)
    - Content hash verification for actual changes (not just git status)
    - Separates files by status for appropriate handling
    - Cleanup runs before analysis
    - Affected directories tracked for AGENTS.md regeneration
    - Dry run support throughout
    - Transaction-safe state updates via SQLite
  </action>
  <verify>
    TypeScript compiles: `npm run build`
    `cat src/update/orchestrator.ts` shows UpdateOrchestrator class.
  </verify>
  <done>
    orchestrator.ts exports UpdateOrchestrator, createUpdateOrchestrator, UpdatePlan.
    Coordinates full update workflow.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create update module index</name>
  <files>src/update/index.ts</files>
  <action>
    Create src/update/index.ts with public exports:

    ```typescript
    /**
     * Update module
     *
     * Provides incremental documentation update functionality.
     * Coordinates state management, change detection, and orphan cleanup.
     */
    export {
      UpdateOrchestrator,
      createUpdateOrchestrator,
      type UpdatePlan,
    } from './orchestrator.js';

    export {
      cleanupOrphans,
      cleanupEmptyDirectoryDocs,
      getAffectedDirectories,
    } from './orphan-cleaner.js';

    export type {
      UpdateOptions,
      UpdateResult,
      UpdateProgress,
      CleanupResult,
    } from './types.js';
    ```

    Export all public types and functions for use by CLI command.
  </action>
  <verify>
    `npm run build` completes without errors.
    `ls src/update/` shows types.ts, orphan-cleaner.ts, orchestrator.ts, index.ts.
  </verify>
  <done>
    index.ts exports all public functions and types.
    Update module ready for CLI integration.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes without TypeScript errors
2. `ls src/update/` shows all four files
3. Update module imports from state and change-detection modules work
4. Orchestrator covers all requirements: change detection, orphan cleanup, state persistence
</verification>

<success_criteria>
- Update orchestrator created with full workflow
- State database integration working
- Change detection integration working
- Orphan cleanup integration working
- Affected directory tracking for AGENTS.md regeneration
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-incremental-updates/03-04-SUMMARY.md`
</output>
