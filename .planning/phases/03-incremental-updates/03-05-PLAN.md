---
phase: 03-incremental-updates
plan: 05
type: execute
wave: 4
depends_on: ["03-04"]
files_modified:
  - src/cli/update.ts
  - src/cli/index.ts
autonomous: true

must_haves:
  truths:
    - "ar update command is recognized"
    - "Update shows files changed since last run"
    - "Unchanged files shown with skip marker"
    - "Cleanup actions displayed (deleted .sum, AGENTS.md)"
    - "Token budget usage displayed after run"
    - "Clear message when nothing changed"
  artifacts:
    - path: "src/cli/update.ts"
      provides: "Update CLI command implementation"
      exports: ["updateCommand", "UpdateCommandOptions"]
    - path: "src/cli/index.ts"
      provides: "CLI router with update command"
      contains: "case 'update'"
  key_links:
    - from: "src/cli/update.ts"
      to: "src/update/orchestrator.ts"
      via: "createUpdateOrchestrator call"
      pattern: "createUpdateOrchestrator\\("
    - from: "src/cli/index.ts"
      to: "src/cli/update.ts"
      via: "import updateCommand"
      pattern: "from './update\\.js'"
---

<objective>
Create CLI update command for incremental documentation updates.

Purpose: Provide user-facing command for updating documentation based on git changes. Displays progress, cleanup actions, and budget usage per CONTEXT.md feedback requirements.

Output: CLI update command with progress display and integration into main CLI router.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-incremental-updates/03-CONTEXT.md
@.planning/phases/03-incremental-updates/03-04-SUMMARY.md
@src/cli/index.ts
@src/cli/generate.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create update CLI command</name>
  <files>src/cli/update.ts</files>
  <action>
    Create src/cli/update.ts implementing the update command:

    ```typescript
    /**
     * CLI update command
     *
     * Updates documentation incrementally based on git changes since last run.
     * Shows per-file progress with skip markers for unchanged files.
     */
    import * as path from 'node:path';
    import pc from 'picocolors';
    import { loadConfig } from '../config/loader.js';
    import { createLogger } from '../output/logger.js';
    import {
      createUpdateOrchestrator,
      type UpdatePlan,
    } from '../update/index.js';

    /**
     * Options for the update command.
     */
    export interface UpdateCommandOptions {
      /** Include uncommitted changes (staged + working directory) */
      uncommitted?: boolean;
      /** Suppress output except errors */
      quiet?: boolean;
      /** Show detailed output */
      verbose?: boolean;
      /** Dry run - show plan without making changes */
      dryRun?: boolean;
      /** Override token budget */
      budget?: number;
    }

    /**
     * Format cleanup results for display.
     */
    function formatCleanup(plan: UpdatePlan): string[] {
      const lines: string[] = [];

      if (plan.cleanup.deletedSumFiles.length > 0) {
        lines.push(pc.yellow('Cleanup (deleted .sum files):'));
        for (const file of plan.cleanup.deletedSumFiles) {
          lines.push(`  ${pc.red('-')} ${file}`);
        }
      }

      if (plan.cleanup.deletedAgentsMd.length > 0) {
        lines.push(pc.yellow('Cleanup (deleted AGENTS.md from empty dirs):'));
        for (const file of plan.cleanup.deletedAgentsMd) {
          lines.push(`  ${pc.red('-')} ${file}`);
        }
      }

      return lines;
    }

    /**
     * Format the update plan for display.
     */
    function formatPlan(plan: UpdatePlan, verbose: boolean): string {
      const lines: string[] = [];

      // Header
      lines.push('');
      lines.push(pc.bold('=== Update Plan ==='));
      lines.push('');

      // Baseline info
      if (plan.isFirstRun) {
        lines.push(pc.yellow('First run detected. Use "ar generate" for initial documentation.'));
        lines.push('');
      } else {
        lines.push(`Base commit: ${pc.dim(plan.baseCommit.slice(0, 7))}`);
        lines.push(`Current commit: ${pc.dim(plan.currentCommit.slice(0, 7))}`);
        lines.push('');
      }

      // Summary
      const analyzeCount = plan.filesToAnalyze.length;
      const skipCount = plan.filesToSkip.length;
      const cleanupCount = plan.cleanup.deletedSumFiles.length + plan.cleanup.deletedAgentsMd.length;

      if (analyzeCount === 0 && skipCount === 0 && cleanupCount === 0) {
        lines.push(pc.green('No changes detected since last run.'));
        lines.push('');
        return lines.join('\n');
      }

      lines.push(`Files to analyze: ${pc.cyan(String(analyzeCount))}`);
      lines.push(`Files unchanged: ${pc.dim(String(skipCount))}`);
      if (cleanupCount > 0) {
        lines.push(`Cleanup actions: ${pc.yellow(String(cleanupCount))}`);
      }
      lines.push('');

      // File list with status markers
      if (plan.filesToAnalyze.length > 0) {
        lines.push(pc.cyan('Files to analyze:'));
        for (const file of plan.filesToAnalyze) {
          const status = file.status === 'added' ? pc.green('+') :
                        file.status === 'renamed' ? pc.blue('R') :
                        pc.yellow('M');
          lines.push(`  ${status} ${file.path}`);
          if (file.status === 'renamed' && file.oldPath) {
            lines.push(`    ${pc.dim(`(was: ${file.oldPath})`)}`);
          }
        }
        lines.push('');
      }

      // Show skipped files in verbose mode
      if (verbose && plan.filesToSkip.length > 0) {
        lines.push(pc.dim('Files unchanged (skipped):'));
        for (const file of plan.filesToSkip) {
          lines.push(`  ${pc.dim('=')} ${pc.dim(file)}`);
        }
        lines.push('');
      }

      // Cleanup
      lines.push(...formatCleanup(plan));

      // Affected directories
      if (plan.affectedDirs.length > 0 && verbose) {
        lines.push('');
        lines.push(pc.cyan('Directories for AGENTS.md regeneration:'));
        for (const dir of plan.affectedDirs) {
          lines.push(`  ${dir}`);
        }
      }

      lines.push('');
      return lines.join('\n');
    }

    /**
     * Update command - incrementally updates documentation based on git changes.
     *
     * This command:
     * 1. Checks git repository status
     * 2. Detects files changed since last run
     * 3. Cleans up orphaned .sum files
     * 4. Prepares analysis tasks for changed files
     * 5. Lists directories for AGENTS.md regeneration
     *
     * The actual analysis is performed by the host LLM.
     */
    export async function updateCommand(
      targetPath: string,
      options: UpdateCommandOptions
    ): Promise<void> {
      const absolutePath = path.resolve(targetPath);
      const logger = createLogger({
        colors: true,
        verbose: options.verbose ?? false,
        quiet: options.quiet ?? false,
        showExcluded: false,
      });

      logger.info(`Checking for updates in: ${absolutePath}`);

      // Load configuration
      const config = await loadConfig(absolutePath);

      // Override budget if specified
      if (options.budget) {
        config.generation.tokenBudget = options.budget;
      }

      // Create orchestrator
      const orchestrator = createUpdateOrchestrator(config, absolutePath);

      try {
        // Prepare update plan
        const plan = await orchestrator.preparePlan({
          includeUncommitted: options.uncommitted,
          dryRun: options.dryRun,
        });

        // Display plan
        if (!options.quiet) {
          console.log(formatPlan(plan, options.verbose ?? false));
        }

        // Handle first run
        if (plan.isFirstRun) {
          console.log(pc.yellow('Hint: Run "ar generate" first to create initial documentation.'));
          console.log(pc.yellow('Then run "ar update" after making changes.'));
          return;
        }

        // Handle no changes
        if (plan.filesToAnalyze.length === 0 &&
            plan.cleanup.deletedSumFiles.length === 0 &&
            plan.cleanup.deletedAgentsMd.length === 0) {
          const lastRun = await orchestrator.getLastRun();
          if (lastRun) {
            console.log(pc.dim(`Last run: ${lastRun.completed_at}`));
            console.log(pc.dim(`Commit: ${lastRun.commit_hash.slice(0, 7)}`));
          }
          return;
        }

        if (options.dryRun) {
          logger.info('Dry run complete. No files written.');
          return;
        }

        // Output instructions for host LLM
        console.log(pc.bold('=== Ready for Incremental Analysis ==='));
        console.log('');
        console.log(`This update requires analyzing ${plan.filesToAnalyze.length} file(s).`);
        console.log('The host LLM will process each changed file and update summaries.');
        console.log('');
        console.log('To proceed, the host should:');
        console.log('1. Read each changed file and its prompt');
        console.log('2. Generate/update .sum files for changed files');
        console.log('3. Regenerate AGENTS.md for affected directories:');
        for (const dir of plan.affectedDirs.slice(0, 5)) {
          console.log(`   - ${dir}`);
        }
        if (plan.affectedDirs.length > 5) {
          console.log(`   - ... and ${plan.affectedDirs.length - 5} more`);
        }

        // After analysis completes, update state
        // (In a real implementation, this would happen after the host LLM finishes)
        // For now, we just show the plan and let the host LLM handle execution

        // Record this run in state (even if just cleanup was done)
        const filesAnalyzed = plan.filesToAnalyze.length;
        const filesSkipped = plan.filesToSkip.length;

        if (filesAnalyzed > 0 || plan.cleanup.deletedSumFiles.length > 0) {
          await orchestrator.recordRun(
            plan.currentCommit,
            filesAnalyzed,
            filesSkipped
          );
          logger.info(`Update recorded. Analyzed: ${filesAnalyzed}, Skipped: ${filesSkipped}`);
        }

      } finally {
        orchestrator.close();
      }
    }
    ```

    Key implementation details:
    - Shows clear status markers: + (added), M (modified), R (renamed), = (skipped)
    - Displays rename old paths for clarity
    - Cleanup section shows deleted .sum and AGENTS.md files
    - Verbose mode shows skipped files and affected directories
    - First run detection with helpful hint
    - "No changes" message with last run info
    - Dry run support
    - Records run state after completion
  </action>
  <verify>
    TypeScript compiles: `npm run build`
    `cat src/cli/update.ts` shows updateCommand function.
  </verify>
  <done>
    update.ts exports updateCommand, UpdateCommandOptions.
    Shows per-file progress with status markers.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate update command into CLI router</name>
  <files>src/cli/index.ts</files>
  <action>
    Update src/cli/index.ts to add the update command:

    1. Add import for updateCommand:
    ```typescript
    import { updateCommand, type UpdateCommandOptions } from './update.js';
    ```

    2. Update USAGE string to include update command:
    ```typescript
    const USAGE = `
    agents-reverse - AI-friendly codebase documentation

    Commands:
      init              Create default configuration
      discover [path]   Discover files to analyze (default: current directory)
      generate [path]   Generate documentation plan (default: current directory)
      update [path]     Update docs incrementally (default: current directory)

    Options:
      --quiet, -q       Suppress output except errors
      --verbose, -v     Show detailed output
      --show-excluded   List each excluded file (discover only)
      --dry-run         Show plan without writing files (generate, update)
      --budget <n>      Override token budget (generate, update)
      --uncommitted     Include uncommitted changes (update only)
      --help, -h        Show this help

    Examples:
      ar init
      ar discover
      ar generate --dry-run
      ar generate ./my-project --budget 50000
      ar update
      ar update --uncommitted --verbose
    `;
    ```

    3. Add case for update command in the switch statement:
    ```typescript
    case 'update': {
      const options: UpdateCommandOptions = {
        uncommitted: flags.has('uncommitted'),
        quiet: flags.has('quiet'),
        verbose: flags.has('verbose'),
        dryRun: flags.has('dry-run'),
        budget: values.has('budget') ? parseInt(values.get('budget')!, 10) : undefined,
      };
      await updateCommand(positional[0] || '.', options);
      break;
    }
    ```

    Ensure the update command fits naturally with existing commands.
  </action>
  <verify>
    `npm run build` completes without errors.
    `node dist/cli/index.js --help` shows update command in usage.
  </verify>
  <done>
    CLI router updated with update command.
    ar update works from command line.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes without TypeScript errors
2. `node dist/cli/index.js --help` shows update command
3. `node dist/cli/index.js update --dry-run` runs without error (in a git repo)
4. Update command shows appropriate message for first run
5. Status markers display correctly for different change types
</verification>

<success_criteria>
- Update command created with full progress display
- Integrated into CLI router
- Status markers: + (added), M (modified), R (renamed), = (skipped)
- Cleanup actions displayed
- First run and no-changes messages
- Dry run support
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-incremental-updates/03-05-SUMMARY.md`
</output>
