---
phase: 03-incremental-updates
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/change-detection/types.ts
  - src/change-detection/detector.ts
  - src/change-detection/index.ts
autonomous: true

must_haves:
  truths:
    - "Git repository status can be checked"
    - "Files changed since a commit hash are detected"
    - "Renamed files are detected with old and new paths"
    - "Deleted files are listed separately"
    - "Content hash computed for any file"
  artifacts:
    - path: "src/change-detection/types.ts"
      provides: "Change detection types (ChangeType, FileChange)"
      exports: ["ChangeType", "FileChange", "ChangeDetectionResult"]
    - path: "src/change-detection/detector.ts"
      provides: "Git diff and content hash functions"
      exports: ["isGitRepo", "getCurrentCommit", "getChangedFiles", "computeContentHash"]
    - path: "src/change-detection/index.ts"
      provides: "Public exports"
      exports: ["isGitRepo", "getCurrentCommit", "getChangedFiles", "computeContentHash", "FileChange", "ChangeType"]
  key_links:
    - from: "src/change-detection/detector.ts"
      to: "simple-git"
      via: "simpleGit() calls"
      pattern: "simpleGit\\("
    - from: "src/change-detection/detector.ts"
      to: "node:crypto"
      via: "createHash for SHA-256"
      pattern: "createHash\\("
---

<objective>
Create git change detection module for identifying modified, added, deleted, and renamed files.

Purpose: Enable incremental updates by detecting which files changed since the last run. Uses simple-git (already a dependency) for git operations and Node.js crypto for content hashing.

Output: Change detection module with types, git operations, and content hashing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-incremental-updates/03-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create change detection types</name>
  <files>src/change-detection/types.ts</files>
  <action>
    Create src/change-detection/types.ts with types for change detection:

    ```typescript
    /**
     * Types for git change detection
     */

    /**
     * Type of change detected for a file
     */
    export type ChangeType = 'added' | 'modified' | 'deleted' | 'renamed';

    /**
     * A file change detected from git diff
     */
    export interface FileChange {
      /** Relative path to the file (new path for renames) */
      path: string;
      /** Type of change */
      status: ChangeType;
      /** Original path for renamed files */
      oldPath?: string;
    }

    /**
     * Result of change detection
     */
    export interface ChangeDetectionResult {
      /** Current commit hash */
      currentCommit: string;
      /** Commit hash we're comparing from */
      baseCommit: string;
      /** List of changed files */
      changes: FileChange[];
      /** Whether uncommitted changes were included */
      includesUncommitted: boolean;
    }

    /**
     * Options for change detection
     */
    export interface ChangeDetectionOptions {
      /** Include uncommitted (staged and working directory) changes */
      includeUncommitted?: boolean;
    }
    ```

    Types cover:
    - ChangeType: added, modified, deleted, renamed
    - FileChange: path, status, optional oldPath for renames
    - ChangeDetectionResult: commits, changes, flags
    - ChangeDetectionOptions: includeUncommitted flag
  </action>
  <verify>
    `cat src/change-detection/types.ts` shows all types.
  </verify>
  <done>
    types.ts exports ChangeType, FileChange, ChangeDetectionResult, ChangeDetectionOptions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create git operations and content hashing</name>
  <files>src/change-detection/detector.ts</files>
  <action>
    Create src/change-detection/detector.ts implementing change detection:

    ```typescript
    /**
     * Git change detection and content hashing
     *
     * Uses simple-git for git operations and Node.js crypto for hashing.
     */
    import { simpleGit } from 'simple-git';
    import { createHash } from 'node:crypto';
    import { readFile } from 'node:fs/promises';
    import type { FileChange, ChangeDetectionResult, ChangeDetectionOptions } from './types.js';

    /**
     * Check if a path is inside a git repository.
     */
    export async function isGitRepo(projectRoot: string): Promise<boolean> {
      const git = simpleGit(projectRoot);
      return git.checkIsRepo();
    }

    /**
     * Get the current HEAD commit hash.
     */
    export async function getCurrentCommit(projectRoot: string): Promise<string> {
      const git = simpleGit(projectRoot);
      const hash = await git.revparse(['HEAD']);
      return hash.trim();
    }

    /**
     * Detect files changed since a base commit.
     *
     * Uses git diff with --name-status and -M for rename detection.
     * Optionally includes uncommitted changes (staged + working directory).
     */
    export async function getChangedFiles(
      projectRoot: string,
      baseCommit: string,
      options: ChangeDetectionOptions = {}
    ): Promise<ChangeDetectionResult> {
      const git = simpleGit(projectRoot);
      const currentCommit = await getCurrentCommit(projectRoot);
      const changes: FileChange[] = [];

      // Get committed changes from baseCommit to HEAD
      const diff = await git.diff([
        '--name-status',
        '-M', // Detect renames (50% similarity threshold)
        baseCommit,
        'HEAD',
      ]);

      // Parse diff output
      // Format: STATUS\tFILE (or STATUS\tOLD\tNEW for renames)
      const lines = diff.trim().split('\n').filter(line => line.length > 0);

      for (const line of lines) {
        const parts = line.split('\t');
        if (parts.length < 2) continue;

        const status = parts[0];
        const filePath = parts[parts.length - 1]; // Last part is always the (new) path

        if (status === 'A') {
          changes.push({ path: filePath, status: 'added' });
        } else if (status === 'M') {
          changes.push({ path: filePath, status: 'modified' });
        } else if (status === 'D') {
          changes.push({ path: filePath, status: 'deleted' });
        } else if (status.startsWith('R')) {
          // Rename: R100 old new (R followed by similarity percentage)
          const oldPath = parts[1];
          changes.push({
            path: filePath,
            status: 'renamed',
            oldPath,
          });
        }
      }

      // Optionally include uncommitted changes
      if (options.includeUncommitted) {
        const status = await git.status();

        // Modified but not staged
        for (const file of status.modified) {
          if (!changes.some(c => c.path === file)) {
            changes.push({ path: file, status: 'modified' });
          }
        }

        // Staged for deletion
        for (const file of status.deleted) {
          if (!changes.some(c => c.path === file)) {
            changes.push({ path: file, status: 'deleted' });
          }
        }

        // Untracked files (new files not yet added)
        for (const file of status.not_added) {
          if (!changes.some(c => c.path === file)) {
            changes.push({ path: file, status: 'added' });
          }
        }

        // Staged files (new or modified)
        for (const file of status.staged) {
          if (!changes.some(c => c.path === file)) {
            changes.push({ path: file, status: 'added' });
          }
        }
      }

      return {
        currentCommit,
        baseCommit,
        changes,
        includesUncommitted: options.includeUncommitted ?? false,
      };
    }

    /**
     * Compute SHA-256 hash of a file's content.
     *
     * @param filePath - Absolute path to the file
     * @returns Hex-encoded SHA-256 hash
     */
    export async function computeContentHash(filePath: string): Promise<string> {
      const content = await readFile(filePath);
      return createHash('sha256').update(content).digest('hex');
    }
    ```

    Key implementation details:
    - Uses simple-git's diff with --name-status for structured output
    - -M flag enables rename detection with 50% similarity threshold
    - Parses git status codes: A (added), M (modified), D (deleted), R (renamed)
    - Renames include oldPath for tracking
    - Uncommitted changes merged without duplicates
    - SHA-256 via Node.js crypto (hardware-accelerated on modern CPUs)
  </action>
  <verify>
    TypeScript compiles: `npm run build`
    `cat src/change-detection/detector.ts` shows all functions.
  </verify>
  <done>
    detector.ts exports isGitRepo, getCurrentCommit, getChangedFiles, computeContentHash.
    Handles all change types including renames.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create module index with public exports</name>
  <files>src/change-detection/index.ts</files>
  <action>
    Create src/change-detection/index.ts with public exports:

    ```typescript
    /**
     * Change detection module
     *
     * Provides git-based change detection for incremental updates.
     * Detects added, modified, deleted, and renamed files.
     */
    export {
      isGitRepo,
      getCurrentCommit,
      getChangedFiles,
      computeContentHash,
    } from './detector.js';

    export type {
      ChangeType,
      FileChange,
      ChangeDetectionResult,
      ChangeDetectionOptions,
    } from './types.js';
    ```

    Export both functions and types for use by update orchestrator.
  </action>
  <verify>
    `npm run build` completes without errors.
    `ls src/change-detection/` shows types.ts, detector.ts, index.ts.
  </verify>
  <done>
    index.ts exports all public functions and types.
    Module ready for use by update orchestrator.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes without TypeScript errors
2. `ls src/change-detection/` shows types.ts, detector.ts, index.ts
3. All exports are importable via src/change-detection/index.ts
4. simple-git already in package.json (no new dependencies needed)
</verification>

<success_criteria>
- Change detection module created with git operations
- Rename detection working with oldPath tracking
- Content hashing via SHA-256
- All change types covered: added, modified, deleted, renamed
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-incremental-updates/03-02-SUMMARY.md`
</output>
