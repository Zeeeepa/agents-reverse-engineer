---
phase: 03-incremental-updates
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/update/types.ts
  - src/update/orphan-cleaner.ts
autonomous: true

must_haves:
  truths:
    - ".sum files deleted when source file is deleted"
    - ".sum files deleted when source file is renamed (old path)"
    - "AGENTS.md deleted from directories with no remaining source files"
    - "Cleanup results report all deleted files"
  artifacts:
    - path: "src/update/types.ts"
      provides: "Update types including CleanupResult"
      exports: ["CleanupResult", "UpdateOptions", "UpdateResult"]
    - path: "src/update/orphan-cleaner.ts"
      provides: "Orphan cleanup logic"
      exports: ["cleanupOrphans", "cleanupEmptyDirectoryDocs"]
  key_links:
    - from: "src/update/orphan-cleaner.ts"
      to: "node:fs/promises"
      via: "unlink, readdir, stat"
      pattern: "from 'node:fs/promises'"
    - from: "src/update/orphan-cleaner.ts"
      to: "src/change-detection/types.ts"
      via: "FileChange type"
      pattern: "import.*FileChange"
---

<objective>
Create orphan cleanup module for removing stale .sum and AGENTS.md files.

Purpose: When files are deleted or renamed, their corresponding .sum files and potentially empty AGENTS.md files must be removed to prevent documentation drift.

Output: Orphan cleaner module with cleanup functions and result tracking.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-incremental-updates/03-RESEARCH.md
@.planning/phases/03-incremental-updates/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create update types</name>
  <files>src/update/types.ts</files>
  <action>
    Create src/update/types.ts with types for the update workflow:

    ```typescript
    /**
     * Types for incremental update workflow
     */
    import type { FileChange } from '../change-detection/types.js';

    /**
     * Result of orphan cleanup
     */
    export interface CleanupResult {
      /** .sum files that were deleted */
      deletedSumFiles: string[];
      /** AGENTS.md files that were deleted (from empty directories) */
      deletedAgentsMd: string[];
    }

    /**
     * Options for the update command
     */
    export interface UpdateOptions {
      /** Include uncommitted changes (staged + working directory) */
      includeUncommitted?: boolean;
      /** Suppress output except errors */
      quiet?: boolean;
      /** Show detailed output */
      verbose?: boolean;
      /** Dry run - show what would change without making changes */
      dryRun?: boolean;
      /** Override token budget */
      budget?: number;
    }

    /**
     * Result of an update run
     */
    export interface UpdateResult {
      /** Files that were analyzed (added or modified) */
      analyzedFiles: string[];
      /** Files that were skipped (unchanged) */
      skippedFiles: string[];
      /** Cleanup result (deleted .sum and AGENTS.md files) */
      cleanup: CleanupResult;
      /** Directories whose AGENTS.md was regenerated */
      regeneratedDirs: string[];
      /** Git commit hash at start of update */
      baseCommit: string;
      /** Git commit hash at end of update */
      currentCommit: string;
      /** Token budget used */
      tokensUsed: number;
      /** Whether this was a dry run */
      dryRun: boolean;
    }

    /**
     * Progress callback for update operations
     */
    export interface UpdateProgress {
      /** Called when a file is about to be processed */
      onFileStart?: (path: string, status: 'analyzing' | 'skipping') => void;
      /** Called when a file is done processing */
      onFileDone?: (path: string, status: 'analyzed' | 'skipped' | 'error') => void;
      /** Called when cleanup deletes a file */
      onCleanup?: (path: string, type: 'sum' | 'agents-md') => void;
      /** Called when a directory AGENTS.md is regenerated */
      onDirRegenerate?: (path: string) => void;
    }
    ```

    Types cover:
    - CleanupResult: tracks deleted .sum and AGENTS.md files
    - UpdateOptions: CLI options for update command
    - UpdateResult: comprehensive result of update run
    - UpdateProgress: callbacks for progress display
  </action>
  <verify>
    `cat src/update/types.ts` shows all types.
  </verify>
  <done>
    types.ts exports CleanupResult, UpdateOptions, UpdateResult, UpdateProgress.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create orphan cleanup module</name>
  <files>src/update/orphan-cleaner.ts</files>
  <action>
    Create src/update/orphan-cleaner.ts implementing orphan cleanup:

    ```typescript
    /**
     * Orphan cleanup for stale .sum and AGENTS.md files
     *
     * Handles:
     * - Deleting .sum files when source files are deleted
     * - Deleting .sum files for renamed files (at old path)
     * - Deleting AGENTS.md from directories with no remaining source files
     */
    import { unlink, readdir, stat } from 'node:fs/promises';
    import * as path from 'node:path';
    import type { FileChange } from '../change-detection/types.js';
    import type { CleanupResult } from './types.js';

    /**
     * Files to ignore when checking if a directory has source files.
     * These are generated files, not source files.
     */
    const GENERATED_FILES = new Set([
      'AGENTS.md',
      'CLAUDE.md',
      'ARCHITECTURE.md',
      'STACK.md',
    ]);

    /**
     * Clean up orphaned .sum files and empty AGENTS.md files.
     *
     * @param projectRoot - Absolute path to project root
     * @param changes - List of file changes (deleted and renamed files need cleanup)
     * @param dryRun - If true, don't actually delete files
     * @returns Cleanup result with lists of deleted files
     */
    export async function cleanupOrphans(
      projectRoot: string,
      changes: FileChange[],
      dryRun: boolean = false
    ): Promise<CleanupResult> {
      const result: CleanupResult = {
        deletedSumFiles: [],
        deletedAgentsMd: [],
      };

      // Collect paths that need .sum cleanup
      const pathsToClean: string[] = [];

      for (const change of changes) {
        if (change.status === 'deleted') {
          pathsToClean.push(change.path);
        } else if (change.status === 'renamed' && change.oldPath) {
          // For renames, clean up the old path's .sum
          pathsToClean.push(change.oldPath);
        }
      }

      // Delete .sum files for deleted/renamed source files
      for (const relativePath of pathsToClean) {
        const sumPath = path.join(projectRoot, `${relativePath}.sum`);
        const deleted = await deleteIfExists(sumPath, dryRun);
        if (deleted) {
          result.deletedSumFiles.push(relativePath + '.sum');
        }
      }

      // Collect affected directories for AGENTS.md cleanup
      const affectedDirs = new Set<string>();
      for (const relativePath of pathsToClean) {
        const dir = path.dirname(relativePath);
        if (dir && dir !== '.') {
          affectedDirs.add(dir);
        }
      }

      // Check each affected directory for empty AGENTS.md
      for (const dir of affectedDirs) {
        const dirPath = path.join(projectRoot, dir);
        const cleaned = await cleanupEmptyDirectoryDocs(dirPath, dryRun);
        if (cleaned) {
          result.deletedAgentsMd.push(path.join(dir, 'AGENTS.md'));
        }
      }

      return result;
    }

    /**
     * Delete a file if it exists.
     *
     * @returns true if file was deleted (or would be in dry run)
     */
    async function deleteIfExists(filePath: string, dryRun: boolean): Promise<boolean> {
      try {
        await stat(filePath);
        if (!dryRun) {
          await unlink(filePath);
        }
        return true;
      } catch {
        // File doesn't exist
        return false;
      }
    }

    /**
     * Check if a directory has any source files remaining.
     * If not, delete its AGENTS.md.
     *
     * @param dirPath - Absolute path to directory
     * @param dryRun - If true, don't actually delete
     * @returns true if AGENTS.md was deleted
     */
    export async function cleanupEmptyDirectoryDocs(
      dirPath: string,
      dryRun: boolean = false
    ): Promise<boolean> {
      try {
        const entries = await readdir(dirPath);

        // Check if directory has any source files
        // Source files are: not .sum files, not generated docs, not hidden files
        const hasSourceFiles = entries.some(entry => {
          // Skip hidden files
          if (entry.startsWith('.')) return false;
          // Skip .sum files
          if (entry.endsWith('.sum')) return false;
          // Skip known generated files
          if (GENERATED_FILES.has(entry)) return false;
          // Everything else counts as a source file
          return true;
        });

        if (!hasSourceFiles) {
          const agentsPath = path.join(dirPath, 'AGENTS.md');
          return await deleteIfExists(agentsPath, dryRun);
        }

        return false;
      } catch {
        // Directory doesn't exist or can't be read
        return false;
      }
    }

    /**
     * Get list of directories that should have their AGENTS.md regenerated.
     *
     * Includes parent directories of changed files up to project root.
     *
     * @param changes - List of file changes (non-deleted files)
     * @returns Set of relative directory paths
     */
    export function getAffectedDirectories(changes: FileChange[]): Set<string> {
      const dirs = new Set<string>();

      for (const change of changes) {
        // Skip deleted files - they don't affect directory docs
        if (change.status === 'deleted') continue;

        // Add all parent directories up to root
        let dir = path.dirname(change.path);
        while (dir && dir !== '.') {
          dirs.add(dir);
          dir = path.dirname(dir);
        }
        // Include root directory
        dirs.add('.');
      }

      return dirs;
    }
    ```

    Key implementation details:
    - Handles deleted files: delete corresponding .sum
    - Handles renamed files: delete .sum at old path (new path gets regenerated)
    - Tracks affected directories for AGENTS.md cleanup
    - Only deletes AGENTS.md when no source files remain
    - Distinguishes source files from generated files (.sum, AGENTS.md, etc.)
    - getAffectedDirectories helper for AGENTS.md regeneration
    - dryRun support for all operations
  </action>
  <verify>
    TypeScript compiles: `npm run build`
    `cat src/update/orphan-cleaner.ts` shows all functions.
  </verify>
  <done>
    orphan-cleaner.ts exports cleanupOrphans, cleanupEmptyDirectoryDocs, getAffectedDirectories.
    Handles all orphan scenarios from CONTEXT.md decisions.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes without TypeScript errors
2. `ls src/update/` shows types.ts, orphan-cleaner.ts
3. Types import correctly from change-detection module
4. All cleanup scenarios covered per CONTEXT.md decisions
</verification>

<success_criteria>
- Update types created with CleanupResult, UpdateOptions, UpdateResult
- Orphan cleaner handles deleted and renamed files
- AGENTS.md cleanup for empty directories
- Dry run support for all operations
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-incremental-updates/03-03-SUMMARY.md`
</output>
