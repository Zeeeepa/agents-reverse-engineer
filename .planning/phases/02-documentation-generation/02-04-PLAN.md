---
phase: 02-documentation-generation 
plan: 04
type: execute
wave: 2
depends_on: ["02-01", "02-02", "02-03"]
files_modified:
  - src/generation/writers/sum.ts
  - src/generation/writers/agents-md.ts
  - src/generation/writers/claude-md.ts
  - src/generation/writers/index.ts
autonomous: true

must_haves:
  truths:
    - ".sum files are written alongside source files (foo.ts -> foo.ts.sum)"
    - "AGENTS.md files group files by purpose, not flat listing"
    - "AGENTS.md files include a synthesized directory description from .sum metadata"
    - "CLAUDE.md points to AGENTS.md for Anthropic compatibility"
    - "Writers handle file system operations (create directories, write files)"
  artifacts:
    - path: "src/generation/writers/sum.ts"
      provides: ".sum file writer"
      exports: ["writeSumFile", "SumFileContent"]
    - path: "src/generation/writers/agents-md.ts"
      provides: "AGENTS.md generator with directory description synthesis"
      exports: ["writeAgentsMd", "DirectoryDoc", "buildAgentsMd", "buildDirectoryDoc"]
    - path: "src/generation/writers/claude-md.ts"
      provides: "CLAUDE.md generator"
      exports: ["writeClaudeMd"]
    - path: "src/generation/writers/index.ts"
      provides: "Re-exports for writers module"
  key_links:
    - from: "src/generation/writers/agents-md.ts"
      to: "src/generation/writers/sum.ts"
      via: "reads .sum files to aggregate into AGENTS.md"
      pattern: "readSumFile"
---

<objective>
Create file writers for documentation output (.sum files, AGENTS.md, CLAUDE.md).

Purpose: Writers transform analysis results into files on disk. They implement the documentation hierarchy: individual .sum files for each source file, AGENTS.md for each directory, and CLAUDE.md at the root for Anthropic compatibility.

Output: Writer modules that create well-formatted documentation files following AGENTS.md specification and CONTEXT.md decisions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-documentation-generation/02-CONTEXT.md
@.planning/phases/02-documentation-generation/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create .sum file writer</name>
  <files>src/generation/writers/sum.ts</files>
  <action>
Create src/generation/writers/sum.ts for writing summary files:

```typescript
import { writeFile, readFile, mkdir } from 'node:fs/promises';
import path from 'node:path';
import type { SummaryMetadata } from '../types.js';

/**
 * Content structure for a .sum file.
 */
export interface SumFileContent {
  /** Main summary text */
  summary: string;
  /** Extracted metadata */
  metadata: SummaryMetadata;
  /** File type that was detected */
  fileType: string;
  /** Generation timestamp */
  generatedAt: string;
}

/**
 * Parse a .sum file back into structured content.
 * Returns null if file doesn't exist or is invalid.
 */
export async function readSumFile(sumPath: string): Promise<SumFileContent | null> {
  try {
    const content = await readFile(sumPath, 'utf-8');
    return parseSumFile(content);
  } catch {
    return null;
  }
}

/**
 * Parse .sum file content into structured data.
 */
function parseSumFile(content: string): SumFileContent | null {
  try {
    // Extract frontmatter
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---\n/);
    if (!frontmatterMatch) return null;

    const frontmatter = frontmatterMatch[1];
    const summary = content.slice(frontmatterMatch[0].length).trim();

    // Parse frontmatter (simple YAML-like parsing)
    const fileType = frontmatter.match(/file_type:\s*(.+)/)?.[1]?.trim() ?? 'generic';
    const generatedAt = frontmatter.match(/generated_at:\s*(.+)/)?.[1]?.trim() ?? '';

    // Parse metadata sections
    const metadata: SummaryMetadata = {
      purpose: '',
      publicInterface: [],
      dependencies: [],
      patterns: [],
    };

    // Extract purpose from summary (first paragraph after any heading)
    const purposeMatch = summary.match(/##?\s*Purpose\n([\s\S]*?)(?=\n##|\n\n##|$)/i);
    if (purposeMatch) {
      metadata.purpose = purposeMatch[1].trim();
    }

    return {
      summary,
      metadata,
      fileType,
      generatedAt,
    };
  } catch {
    return null;
  }
}

/**
 * Format .sum file content for writing.
 */
function formatSumFile(content: SumFileContent): string {
  const frontmatter = [
    '---',
    `file_type: ${content.fileType}`,
    `generated_at: ${content.generatedAt}`,
    '---',
    '',
  ].join('\n');

  return frontmatter + content.summary;
}

/**
 * Write a .sum file alongside a source file.
 * Creates: foo.ts -> foo.ts.sum
 *
 * @param sourcePath - Path to the source file
 * @param content - Summary content to write
 * @returns Path to the written .sum file
 */
export async function writeSumFile(
  sourcePath: string,
  content: SumFileContent
): Promise<string> {
  const sumPath = `${sourcePath}.sum`;
  const dir = path.dirname(sumPath);

  // Ensure directory exists
  await mkdir(dir, { recursive: true });

  // Write file
  const formatted = formatSumFile(content);
  await writeFile(sumPath, formatted, 'utf-8');

  return sumPath;
}

/**
 * Get the .sum path for a source file.
 */
export function getSumPath(sourcePath: string): string {
  return `${sourcePath}.sum`;
}

/**
 * Check if a .sum file exists for a source file.
 */
export async function sumFileExists(sourcePath: string): Promise<boolean> {
  const sumPath = getSumPath(sourcePath);
  const content = await readSumFile(sumPath);
  return content !== null;
}
```

Create the writers directory: `mkdir -p src/generation/writers`
  </action>
  <verify>npx tsc --noEmit src/generation/writers/sum.ts</verify>
  <done>Sum writer exports writeSumFile, readSumFile, getSumPath, SumFileContent</done>
</task>

<task type="auto">
  <name>Task 2: Create AGENTS.md writer</name>
  <files>src/generation/writers/agents-md.ts</files>
  <action>
Create src/generation/writers/agents-md.ts for directory documentation:

```typescript
import { writeFile, readdir, stat, mkdir } from 'node:fs/promises';
import path from 'node:path';
import { readSumFile, getSumPath } from './sum.js';

/**
 * Reference to a file in a directory.
 */
export interface FileRef {
  /** File name */
  name: string;
  /** Brief description from .sum file */
  description: string;
  /** Whether this is a critical/frequently modified file */
  critical?: boolean;
}

/**
 * Group of files by purpose.
 */
export interface FileGroup {
  /** Purpose/category of this group */
  purpose: string;
  /** Files in this group */
  files: FileRef[];
}

/**
 * Summary of a subdirectory.
 */
export interface SubdirSummary {
  /** Directory name */
  name: string;
  /** Brief summary (from child AGENTS.md or inferred) */
  summary: string;
}

/**
 * Complete directory documentation structure.
 */
export interface DirectoryDoc {
  /** Directory path (relative to project root) */
  path: string;
  /** Directory description */
  description: string;
  /** Files grouped by purpose */
  files: FileGroup[];
  /** Subdirectories with summaries */
  subdirectories: SubdirSummary[];
  /** Related directories (from imports, config) */
  relatedDirectories: string[];
  /** Patterns/conventions in this directory */
  patterns: string[];
}

/**
 * Build AGENTS.md content from directory documentation.
 */
export function buildAgentsMd(doc: DirectoryDoc): string {
  const sections: string[] = [];
  const dirName = path.basename(doc.path) || 'Project Root';

  // Header
  sections.push(`# ${dirName}\n`);
  if (doc.description) {
    sections.push(`${doc.description}\n`);
  }

  // Files grouped by purpose (not flat listing)
  if (doc.files.length > 0) {
    sections.push('## Contents\n');
    for (const group of doc.files) {
      if (group.files.length === 0) continue;

      sections.push(`### ${group.purpose}\n`);
      for (const file of group.files) {
        const marker = file.critical ? ' **[critical]**' : '';
        sections.push(`- [${file.name}](./${file.name}) - ${file.description}${marker}`);
      }
      sections.push('');
    }
  }

  // Subdirectories
  if (doc.subdirectories.length > 0) {
    sections.push('## Subdirectories\n');
    for (const subdir of doc.subdirectories) {
      sections.push(`- [${subdir.name}/](./${subdir.name}/) - ${subdir.summary}`);
    }
    sections.push('');
  }

  // Related directories
  if (doc.relatedDirectories.length > 0) {
    sections.push('## Related\n');
    for (const related of doc.relatedDirectories) {
      sections.push(`- [${related}](${related})`);
    }
    sections.push('');
  }

  // Patterns/Conventions
  if (doc.patterns.length > 0) {
    sections.push('## Patterns\n');
    for (const pattern of doc.patterns) {
      sections.push(`- ${pattern}`);
    }
    sections.push('');
  }

  return sections.join('\n').trim() + '\n';
}

/**
 * Categorize files by purpose based on file type and name.
 */
function categorizeFile(fileName: string, fileType: string): string {
  // Use file type for categorization
  const typeCategories: Record<string, string> = {
    component: 'Components',
    service: 'Services',
    util: 'Utilities',
    type: 'Types',
    test: 'Tests',
    config: 'Configuration',
    api: 'API Routes',
    model: 'Models',
    hook: 'Hooks',
    schema: 'Schemas',
    generic: 'Core',
  };

  return typeCategories[fileType] ?? 'Other';
}

/**
 * Synthesize a directory description from aggregated .sum file metadata.
 *
 * This function creates a meaningful directory-level description by:
 * 1. Collecting all purposes from .sum files in the directory
 * 2. Identifying common patterns and themes
 * 3. Generating a concise summary of the directory's role
 *
 * @param files - Map of category to file references with descriptions
 * @param dirName - Name of the directory
 * @returns A synthesized description of the directory's purpose
 */
function synthesizeDirectoryDescription(
  files: Map<string, FileRef[]>,
  dirName: string
): string {
  // Collect all file purposes/descriptions
  const allDescriptions: string[] = [];
  const categories: string[] = [];

  for (const [category, fileRefs] of files) {
    categories.push(category);
    for (const file of fileRefs) {
      if (file.description && file.description !== 'No description') {
        allDescriptions.push(file.description);
      }
    }
  }

  // If no descriptions available, create a basic description from categories
  if (allDescriptions.length === 0) {
    if (categories.length === 0) {
      return `Contains ${dirName} related files.`;
    }
    const categoryList = categories.slice(0, 3).join(', ');
    return `Contains ${categoryList.toLowerCase()} for ${dirName}.`;
  }

  // Synthesize description from available metadata
  // Extract common themes from descriptions (simple keyword extraction)
  const keywords = new Map<string, number>();
  const commonWords = new Set([
    'the', 'a', 'an', 'and', 'or', 'for', 'to', 'of', 'in', 'on', 'with',
    'this', 'that', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
    'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could',
    'should', 'may', 'might', 'must', 'can', 'from', 'by', 'as', 'at',
  ]);

  for (const desc of allDescriptions) {
    const words = desc.toLowerCase()
      .replace(/[^a-z\s]/g, '')
      .split(/\s+/)
      .filter(w => w.length > 3 && !commonWords.has(w));

    for (const word of words) {
      keywords.set(word, (keywords.get(word) ?? 0) + 1);
    }
  }

  // Get top themes
  const topThemes = Array.from(keywords.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 3)
    .map(([word]) => word);

  // Build description
  if (topThemes.length > 0) {
    const themePhrase = topThemes.join(', ');
    const primaryCategory = categories[0]?.toLowerCase() ?? 'files';
    return `${capitalizeFirst(dirName)} ${primaryCategory} for ${themePhrase}.`;
  }

  // Fallback: use first description as base
  const firstDesc = allDescriptions[0];
  if (firstDesc.length <= 80) {
    return `${capitalizeFirst(dirName)} directory: ${firstDesc}`;
  }
  return `${capitalizeFirst(dirName)} directory containing ${categories.length} file type(s).`;
}

/**
 * Capitalize first letter of a string.
 */
function capitalizeFirst(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Build directory documentation from .sum files.
 */
export async function buildDirectoryDoc(
  dirPath: string,
  projectRoot: string
): Promise<DirectoryDoc> {
  const relativePath = path.relative(projectRoot, dirPath) || '.';
  const dirName = path.basename(dirPath) || 'root';
  const doc: DirectoryDoc = {
    path: relativePath,
    description: '', // Will be populated after collecting file metadata
    files: [],
    subdirectories: [],
    relatedDirectories: [],
    patterns: [],
  };

  const entries = await readdir(dirPath, { withFileTypes: true });
  const filesByCategory = new Map<string, FileRef[]>();

  for (const entry of entries) {
    const entryPath = path.join(dirPath, entry.name);

    if (entry.isDirectory()) {
      // Check for AGENTS.md in subdirectory
      const childAgentsPath = path.join(entryPath, 'AGENTS.md');
      try {
        await stat(childAgentsPath);
        // Has AGENTS.md - extract first line as summary
        doc.subdirectories.push({
          name: entry.name,
          summary: `See ${entry.name}/AGENTS.md`,
        });
      } catch {
        // No AGENTS.md - just note the directory exists
        doc.subdirectories.push({
          name: entry.name,
          summary: `${entry.name} directory`,
        });
      }
    } else if (entry.isFile() && !entry.name.endsWith('.sum') && !entry.name.startsWith('.')) {
      // Try to read .sum file for this source file
      const sumPath = getSumPath(entryPath);
      const sumContent = await readSumFile(sumPath);

      if (sumContent) {
        const category = categorizeFile(entry.name, sumContent.fileType);
        const files = filesByCategory.get(category) ?? [];
        files.push({
          name: entry.name,
          description: sumContent.metadata.purpose || 'No description',
        });
        filesByCategory.set(category, files);
      }
    }
  }

  // Synthesize directory description from collected .sum metadata
  doc.description = synthesizeDirectoryDescription(filesByCategory, dirName);

  // Convert map to sorted groups
  const categoryOrder = [
    'Configuration', 'Types', 'Models', 'Schemas',
    'Services', 'API Routes', 'Hooks', 'Components',
    'Utilities', 'Tests', 'Core', 'Other',
  ];

  for (const category of categoryOrder) {
    const files = filesByCategory.get(category);
    if (files && files.length > 0) {
      doc.files.push({
        purpose: category,
        files: files.sort((a, b) => a.name.localeCompare(b.name)),
      });
    }
  }

  return doc;
}

/**
 * Write AGENTS.md for a directory.
 *
 * @param dirPath - Directory to write AGENTS.md for
 * @param projectRoot - Project root for relative paths
 * @returns Path to written AGENTS.md
 */
export async function writeAgentsMd(
  dirPath: string,
  projectRoot: string
): Promise<string> {
  const doc = await buildDirectoryDoc(dirPath, projectRoot);
  const content = buildAgentsMd(doc);
  const agentsPath = path.join(dirPath, 'AGENTS.md');

  await mkdir(path.dirname(agentsPath), { recursive: true });
  await writeFile(agentsPath, content, 'utf-8');

  return agentsPath;
}
```
  </action>
  <verify>npx tsc --noEmit src/generation/writers/agents-md.ts</verify>
  <done>AGENTS.md writer exports writeAgentsMd, buildAgentsMd, buildDirectoryDoc, DirectoryDoc type. Directory description is synthesized from aggregated .sum file metadata using synthesizeDirectoryDescription.</done>
</task>

<task type="auto">
  <name>Task 3: Create CLAUDE.md writer and index</name>
  <files>src/generation/writers/claude-md.ts, src/generation/writers/index.ts</files>
  <action>
Create src/generation/writers/claude-md.ts:

```typescript
import { writeFile } from 'node:fs/promises';
import path from 'node:path';

/**
 * Standard CLAUDE.md content - simple pointer to AGENTS.md.
 *
 * Per CONTEXT.md: "Simple pointer to AGENTS.md for Anthropic compatibility"
 */
const CLAUDE_MD_CONTENT = `# CLAUDE.md

See [AGENTS.md](./AGENTS.md) for codebase documentation.

This file exists for Anthropic compatibility. The actual documentation
is maintained in AGENTS.md files throughout the codebase.
`;

/**
 * Write CLAUDE.md at the project root.
 *
 * @param projectRoot - Project root directory
 * @returns Path to written CLAUDE.md
 */
export async function writeClaudeMd(projectRoot: string): Promise<string> {
  const claudePath = path.join(projectRoot, 'CLAUDE.md');
  await writeFile(claudePath, CLAUDE_MD_CONTENT, 'utf-8');
  return claudePath;
}

/**
 * Get the content that would be written to CLAUDE.md.
 * Useful for previewing without writing.
 */
export function getClaudeMdContent(): string {
  return CLAUDE_MD_CONTENT;
}
```

Then create src/generation/writers/index.ts:

```typescript
export {
  writeSumFile,
  readSumFile,
  getSumPath,
  sumFileExists,
  type SumFileContent,
} from './sum.js';

export {
  writeAgentsMd,
  buildAgentsMd,
  buildDirectoryDoc,
  type DirectoryDoc,
  type FileGroup,
  type FileRef,
  type SubdirSummary,
} from './agents-md.js';

export {
  writeClaudeMd,
  getClaudeMdContent,
} from './claude-md.js';
```
  </action>
  <verify>npx tsc --noEmit src/generation/writers/index.ts</verify>
  <done>CLAUDE.md writer exports writeClaudeMd, getClaudeMdContent. Index re-exports all writer functionality.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` - Full project compiles without errors
2. Verify writers are accessible:
```typescript
import { writeSumFile, writeAgentsMd, writeClaudeMd } from './src/generation/writers/index.js';
```
</verification>

<success_criteria>
- [ ] src/generation/writers/sum.ts exports writeSumFile, readSumFile, SumFileContent
- [ ] src/generation/writers/agents-md.ts exports writeAgentsMd, buildAgentsMd, buildDirectoryDoc, DirectoryDoc
- [ ] src/generation/writers/claude-md.ts exports writeClaudeMd, getClaudeMdContent
- [ ] .sum files include frontmatter with file_type and generated_at
- [ ] AGENTS.md groups files by purpose (not flat listing)
- [ ] AGENTS.md includes a synthesized directory description (not empty)
- [ ] CLAUDE.md is a simple pointer to AGENTS.md
</success_criteria>

<output>
After completion, create `.planning/phases/02-documentation-generation/02-04-SUMMARY.md`
</output>
