---
phase: 02-documentation-generation
plan: 06
type: execute
wave: 3
depends_on: ["02-01", "02-02", "02-03", "02-04", "02-05"]
files_modified:
  - src/generation/orchestrator.ts
  - src/cli/generate.ts
  - src/cli/index.ts
  - src/config/schema.ts
autonomous: true

must_haves:
  truths:
    - "ar generate command discovers files and produces generation plan"
    - "Generation orchestrator coordinates file analysis and documentation writing"
    - "Orchestrator includes directory-summary tasks for LLM-generated directory descriptions"
    - "Token budget is tracked and reported"
    - "Config schema extended for generation options"
  artifacts:
    - path: "src/generation/orchestrator.ts"
      provides: "Generation workflow orchestration"
      exports: ["GenerationOrchestrator", "GenerationResult"]
    - path: "src/cli/generate.ts"
      provides: "CLI generate command"
      exports: ["generateCommand", "GenerateOptions"]
    - path: "src/cli/index.ts"
      provides: "Updated CLI with generate command"
    - path: "src/config/schema.ts"
      provides: "Extended config schema for generation"
  key_links:
    - from: "src/cli/generate.ts"
      to: "src/generation/orchestrator.ts"
      via: "uses orchestrator for generation workflow"
      pattern: "import.*orchestrator"
    - from: "src/generation/orchestrator.ts"
      to: "src/generation/writers/index.ts"
      via: "uses writers for file output"
      pattern: "import.*writers"
---

<objective>
Create the generation orchestrator and CLI command that ties all modules together.

Purpose: The orchestrator coordinates the generation workflow: discover files, detect types, build prompts, track budget, and write documentation. The CLI command exposes this as `ar generate` for users.

Output: `ar generate` command that produces a generation plan with prompts for the host LLM to analyze files.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-documentation-generation/02-CONTEXT.md
@.planning/phases/02-documentation-generation/02-RESEARCH.md
@src/cli/index.ts
@src/config/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend config schema for generation</name>
  <files>src/config/schema.ts</files>
  <action>
Update src/config/schema.ts to add generation configuration section:

Add a new GenerationSchema after the existing schemas:

```typescript
/**
 * Schema for generation configuration
 */
const GenerationSchema = z.object({
  /** Token budget for entire project (default: 100,000) */
  tokenBudget: z.number().positive().default(100_000),
  /** Generate ARCHITECTURE.md when thresholds met (default: true) */
  generateArchitecture: z.boolean().default(true),
  /** Generate STACK.md from package.json (default: true) */
  generateStack: z.boolean().default(true),
  /** Output directory for supplementary docs (default: project root) */
  supplementaryDocsDir: z.string().optional(),
  /** Chunk size for large files in tokens (default: 3000) */
  chunkSize: z.number().positive().default(3000),
}).default({});
```

Update the main ConfigSchema to include generation:

```typescript
export const ConfigSchema = z.object({
  /** Exclusion rules for files and directories */
  exclude: ExcludeSchema,
  /** Discovery options */
  options: OptionsSchema,
  /** Output formatting options */
  output: OutputSchema,
  /** Generation options */
  generation: GenerationSchema,
}).default({});
```

Add the type export:

```typescript
/**
 * Type for the generation section of config
 */
export type GenerationConfig = z.infer<typeof GenerationSchema>;
```
  </action>
  <verify>npx tsc --noEmit src/config/schema.ts</verify>
  <done>Config schema extended with generation section including tokenBudget, generateArchitecture, generateStack</done>
</task>

<task type="auto">
  <name>Task 2: Create generation orchestrator</name>
  <files>src/generation/orchestrator.ts</files>
  <action>
Create src/generation/orchestrator.ts to coordinate the generation workflow:

```typescript
import { readFile } from 'node:fs/promises';
import path from 'node:path';
import type { Config } from '../config/schema.js';
import type { DiscoveryResult } from '../types/index.js';
import { detectFileType } from './detection/detector.js';
import type { FileType, AnalysisRequest } from './types.js';
import { BudgetTracker, countTokens, needsChunking, chunkFile } from './budget/index.js';
import { buildPrompt, buildChunkPrompt, buildSynthesisPrompt } from './prompts/index.js';
import { analyzeComplexity, shouldGenerateArchitecture, shouldGenerateStack } from './complexity.js';
import type { ComplexityMetrics } from './complexity.js';
// Note: path module already imported above for directory operations

/**
 * A file prepared for analysis.
 */
export interface PreparedFile {
  /** Absolute path to the file */
  filePath: string;
  /** Relative path from project root */
  relativePath: string;
  /** File content */
  content: string;
  /** Detected file type */
  fileType: FileType;
  /** Token count of content */
  tokens: number;
  /** Whether file needs chunking */
  needsChunking: boolean;
}

/**
 * Analysis request for a file or chunk.
 */
export interface AnalysisTask {
  /** Type of task */
  type: 'file' | 'chunk' | 'synthesis' | 'directory-summary';
  /** File or directory path */
  filePath: string;
  /** System prompt */
  systemPrompt: string;
  /** User prompt */
  userPrompt: string;
  /** Estimated tokens for this task */
  estimatedTokens: number;
  /** Chunk info if applicable */
  chunkInfo?: {
    index: number;
    total: number;
    startLine: number;
    endLine: number;
  };
  /** Directory info for directory-summary tasks */
  directoryInfo?: {
    /** Paths of .sum files in this directory */
    sumFiles: string[];
    /** Number of files analyzed */
    fileCount: number;
  };
}

/**
 * Result of the generation planning process.
 */
export interface GenerationPlan {
  /** Files to be analyzed */
  files: PreparedFile[];
  /** Analysis tasks to execute */
  tasks: AnalysisTask[];
  /** Complexity metrics */
  complexity: ComplexityMetrics;
  /** Whether to generate ARCHITECTURE.md */
  generateArchitecture: boolean;
  /** Whether to generate STACK.md */
  generateStack: boolean;
  /** Budget tracker state */
  budget: {
    total: number;
    estimated: number;
    remaining: number;
  };
  /** Files skipped due to budget */
  skippedFiles: string[];
}

/**
 * Orchestrates the documentation generation workflow.
 */
export class GenerationOrchestrator {
  private config: Config;
  private projectRoot: string;
  private budgetTracker: BudgetTracker;

  constructor(config: Config, projectRoot: string, totalFiles: number) {
    this.config = config;
    this.projectRoot = projectRoot;
    this.budgetTracker = new BudgetTracker(
      config.generation.tokenBudget,
      totalFiles
    );
  }

  /**
   * Prepare files for analysis by reading content and detecting types.
   */
  async prepareFiles(discoveryResult: DiscoveryResult): Promise<PreparedFile[]> {
    const prepared: PreparedFile[] = [];

    for (const filePath of discoveryResult.files) {
      try {
        const content = await readFile(filePath, 'utf-8');
        const tokens = countTokens(content);
        const fileType = detectFileType(filePath, content);
        const relativePath = path.relative(this.projectRoot, filePath);

        prepared.push({
          filePath,
          relativePath,
          content,
          fileType,
          tokens,
          needsChunking: needsChunking(content, this.config.generation.chunkSize),
        });
      } catch (error) {
        // Skip files that can't be read (permission errors, etc.)
        console.error(`Warning: Could not read ${filePath}`);
      }
    }

    // Sort by token count (smaller files first for breadth-first coverage)
    return prepared.sort((a, b) => a.tokens - b.tokens);
  }

  /**
   * Create analysis tasks for files within budget.
   */
  createTasks(files: PreparedFile[]): {
    tasks: AnalysisTask[];
    skipped: string[];
  } {
    const tasks: AnalysisTask[] = [];
    const skipped: string[] = [];

    for (const file of files) {
      const promptOverhead = 600; // Approximate overhead for prompts
      const estimatedTotal = file.tokens + promptOverhead;

      if (!this.budgetTracker.canProcess(estimatedTotal)) {
        this.budgetTracker.recordSkipped(file.relativePath);
        skipped.push(file.relativePath);
        continue;
      }

      if (file.needsChunking) {
        // Create chunk tasks
        const chunks = chunkFile(file.content, {
          chunkSize: this.config.generation.chunkSize,
        });

        for (const chunk of chunks) {
          const chunkPrompt = buildChunkPrompt({
            filePath: file.filePath,
            content: chunk.content,
            fileType: file.fileType,
            chunkIndex: chunk.index,
            totalChunks: chunks.length,
            lineRange: { start: chunk.startLine, end: chunk.endLine },
          });

          tasks.push({
            type: 'chunk',
            filePath: file.relativePath,
            systemPrompt: chunkPrompt.system,
            userPrompt: chunkPrompt.user,
            estimatedTokens: chunk.tokens + promptOverhead,
            chunkInfo: {
              index: chunk.index,
              total: chunks.length,
              startLine: chunk.startLine,
              endLine: chunk.endLine,
            },
          });
        }

        // Add synthesis task (will be executed after chunks)
        tasks.push({
          type: 'synthesis',
          filePath: file.relativePath,
          systemPrompt: '', // Will be set during execution
          userPrompt: `Synthesize summaries for ${file.relativePath}`,
          estimatedTokens: promptOverhead,
        });
      } else {
        // Single file task
        const prompt = buildPrompt({
          filePath: file.filePath,
          content: file.content,
          fileType: file.fileType,
        });

        tasks.push({
          type: 'file',
          filePath: file.relativePath,
          systemPrompt: prompt.system,
          userPrompt: prompt.user,
          estimatedTokens: estimatedTotal,
        });
      }

      this.budgetTracker.recordProcessed(file.relativePath, estimatedTotal);
    }

    return { tasks, skipped };
  }

  /**
   * Create directory-summary tasks for LLM-generated directory descriptions.
   * These tasks run after all files in a directory are analyzed, allowing
   * the LLM to synthesize a richer directory overview from the .sum files.
   */
  createDirectorySummaryTasks(files: PreparedFile[]): AnalysisTask[] {
    const tasks: AnalysisTask[] = [];

    // Group files by directory
    const filesByDir = new Map<string, PreparedFile[]>();
    for (const file of files) {
      const dir = path.dirname(file.relativePath);
      const dirFiles = filesByDir.get(dir) ?? [];
      dirFiles.push(file);
      filesByDir.set(dir, dirFiles);
    }

    // Create a directory-summary task for each directory with analyzed files
    for (const [dir, dirFiles] of filesByDir) {
      const sumFilePaths = dirFiles.map(f => `${f.relativePath}.sum`);
      const promptOverhead = 800; // Overhead for directory summary prompts

      tasks.push({
        type: 'directory-summary',
        filePath: dir || '.',
        systemPrompt: `You are generating a directory description for documentation.
Analyze the provided .sum file contents to create a concise, informative directory overview.
Focus on:
1. The primary purpose of this directory
2. How the files work together
3. Key patterns or conventions used
Keep the description to 1-3 sentences.`,
        userPrompt: `Generate a directory description for "${dir || 'root'}" based on ${dirFiles.length} analyzed files.
The .sum files contain individual file summaries - synthesize them into a cohesive directory overview.`,
        estimatedTokens: promptOverhead,
        directoryInfo: {
          sumFiles: sumFilePaths,
          fileCount: dirFiles.length,
        },
      });
    }

    return tasks;
  }

  /**
   * Create a complete generation plan.
   */
  async createPlan(discoveryResult: DiscoveryResult): Promise<GenerationPlan> {
    const files = await this.prepareFiles(discoveryResult);
    const complexity = analyzeComplexity(
      files.map(f => f.filePath),
      this.projectRoot
    );

    const { tasks: fileTasks, skipped } = this.createTasks(files);

    // Add directory-summary tasks for LLM-generated directory descriptions
    // These run after file analysis to synthesize richer directory overviews
    const dirTasks = this.createDirectorySummaryTasks(files);
    const tasks = [...fileTasks, ...dirTasks];

    // Check for package.json to determine STACK.md generation
    const hasPackageJson = await this.hasPackageJson();

    return {
      files,
      tasks,
      complexity,
      generateArchitecture: this.config.generation.generateArchitecture &&
        shouldGenerateArchitecture(complexity),
      generateStack: this.config.generation.generateStack &&
        hasPackageJson &&
        shouldGenerateStack(hasPackageJson),
      budget: {
        total: this.config.generation.tokenBudget,
        estimated: this.budgetTracker.getReport().used,
        remaining: this.budgetTracker.remaining,
      },
      skippedFiles: skipped,
    };
  }

  /**
   * Check if package.json exists in project root.
   */
  private async hasPackageJson(): Promise<boolean> {
    try {
      await readFile(path.join(this.projectRoot, 'package.json'), 'utf-8');
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Get budget report.
   */
  getBudgetReport() {
    return this.budgetTracker.getReport();
  }
}

/**
 * Create a generation orchestrator with default config.
 */
export function createOrchestrator(
  config: Config,
  projectRoot: string,
  totalFiles: number
): GenerationOrchestrator {
  return new GenerationOrchestrator(config, projectRoot, totalFiles);
}
```
  </action>
  <verify>npx tsc --noEmit src/generation/orchestrator.ts</verify>
  <done>Orchestrator exports GenerationOrchestrator, createOrchestrator, GenerationPlan, PreparedFile, AnalysisTask. Includes createDirectorySummaryTasks method that generates directory-summary tasks for LLM-based directory descriptions.</done>
</task>

<task type="auto">
  <name>Task 3: Create generate CLI command and update index</name>
  <files>src/cli/generate.ts, src/cli/index.ts</files>
  <action>
Create src/cli/generate.ts:

```typescript
import path from 'node:path';
import { loadConfig } from '../config/loader.js';
import { createLogger } from '../output/logger.js';
import { discoverFiles } from '../discovery/walker.js';
import { createFilterChain } from '../discovery/filters/index.js';
import { createOrchestrator, type GenerationPlan } from '../generation/orchestrator.js';

/**
 * Options for the generate command.
 */
export interface GenerateOptions {
  /** Suppress output except errors */
  quiet?: boolean;
  /** Show detailed task breakdown */
  verbose?: boolean;
  /** Dry run - show plan without generating */
  dryRun?: boolean;
  /** Override token budget */
  budget?: number;
}

/**
 * Format file type distribution for display.
 */
function formatTypeDistribution(plan: GenerationPlan): string {
  const typeCounts = new Map<string, number>();

  for (const file of plan.files) {
    const count = typeCounts.get(file.fileType) ?? 0;
    typeCounts.set(file.fileType, count + 1);
  }

  return Array.from(typeCounts.entries())
    .sort((a, b) => b[1] - a[1])
    .map(([type, count]) => `  ${type}: ${count}`)
    .join('\n');
}

/**
 * Format the generation plan for display.
 */
function formatPlan(plan: GenerationPlan): string {
  const lines: string[] = [];

  lines.push(`\n=== Generation Plan ===\n`);

  // File summary
  lines.push(`Files to analyze: ${plan.files.length}`);
  lines.push(`Tasks to execute: ${plan.tasks.length}`);
  lines.push('');

  // File type distribution
  lines.push('File types:');
  lines.push(formatTypeDistribution(plan));
  lines.push('');

  // Budget
  lines.push('Token budget:');
  lines.push(`  Total: ${plan.budget.total.toLocaleString()}`);
  lines.push(`  Estimated: ${plan.budget.estimated.toLocaleString()}`);
  lines.push(`  Remaining: ${plan.budget.remaining.toLocaleString()}`);
  lines.push('');

  // Complexity
  lines.push('Complexity:');
  lines.push(`  Files: ${plan.complexity.fileCount}`);
  lines.push(`  Directory depth: ${plan.complexity.directoryDepth}`);
  if (plan.complexity.architecturalPatterns.length > 0) {
    lines.push(`  Patterns: ${plan.complexity.architecturalPatterns.join(', ')}`);
  }
  lines.push('');

  // Supplementary docs
  lines.push('Supplementary docs:');
  lines.push(`  ARCHITECTURE.md: ${plan.generateArchitecture ? 'yes' : 'no'}`);
  lines.push(`  STACK.md: ${plan.generateStack ? 'yes' : 'no'}`);
  lines.push('');

  // Skipped files
  if (plan.skippedFiles.length > 0) {
    lines.push(`Skipped (budget): ${plan.skippedFiles.length} files`);
    if (plan.skippedFiles.length <= 5) {
      for (const file of plan.skippedFiles) {
        lines.push(`  - ${file}`);
      }
    }
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Generate command - creates documentation generation plan.
 *
 * This command:
 * 1. Discovers files to analyze
 * 2. Detects file types
 * 3. Creates analysis tasks (prompts)
 * 4. Reports budget and plan
 *
 * The actual analysis is performed by the host LLM using the generated prompts.
 */
export async function generateCommand(
  targetPath: string,
  options: GenerateOptions
): Promise<void> {
  const absolutePath = path.resolve(targetPath);
  const logger = createLogger({
    colors: true,
    verbose: options.verbose ?? false,
    quiet: options.quiet ?? false,
  });

  logger.info(`Generating documentation plan for: ${absolutePath}`);

  // Load configuration
  const config = await loadConfig(absolutePath);

  // Override budget if specified
  if (options.budget) {
    config.generation.tokenBudget = options.budget;
  }

  // Discover files
  logger.info('Discovering files...');
  const filterChain = await createFilterChain(absolutePath, config);
  const discoveryResult = await discoverFiles(absolutePath, filterChain, {
    followSymlinks: config.options.followSymlinks,
    maxFileSize: config.options.maxFileSize,
  });

  logger.info(`Found ${discoveryResult.files.length} files to analyze`);

  // Create generation plan
  logger.info('Creating generation plan...');
  const orchestrator = createOrchestrator(
    config,
    absolutePath,
    discoveryResult.files.length
  );
  const plan = await orchestrator.createPlan(discoveryResult);

  // Display plan
  if (!options.quiet) {
    console.log(formatPlan(plan));
  }

  if (options.dryRun) {
    logger.info('Dry run complete. No files written.');
    return;
  }

  // Output task instructions for the host LLM
  console.log('\n=== Ready for Analysis ===\n');
  console.log(`This plan contains ${plan.tasks.length} analysis tasks.`);
  console.log('The host LLM will process each file and generate summaries.');
  console.log('\nTo proceed, the host should:');
  console.log('1. Read each file and its prompt');
  console.log('2. Generate summaries following the prompt guidelines');
  console.log('3. Write .sum files alongside source files');
  console.log('4. Generate AGENTS.md for each directory');
  console.log('5. Generate CLAUDE.md at the project root');

  if (plan.generateArchitecture) {
    console.log('6. Generate ARCHITECTURE.md (complexity threshold met)');
  }
  if (plan.generateStack) {
    console.log('7. Generate STACK.md (package.json found)');
  }

  // Summary
  const budgetReport = orchestrator.getBudgetReport();
  logger.info(`\nPlan ready. Estimated tokens: ${budgetReport.used.toLocaleString()}`);
}
```

Update src/cli/index.ts to add the generate command:

```typescript
#!/usr/bin/env node
/**
 * CLI entry point for agents-reverse
 *
 * Commands:
 *   init              Create default configuration
 *   discover [path]   Discover files to analyze
 *   generate [path]   Generate documentation plan
 */

import { initCommand, type InitOptions } from './init.js';
import { discoverCommand, type DiscoverOptions } from './discover.js';
import { generateCommand, type GenerateOptions } from './generate.js';

const USAGE = `
agents-reverse - AI-friendly codebase documentation

Commands:
  init              Create default configuration
  discover [path]   Discover files to analyze (default: current directory)
  generate [path]   Generate documentation plan (default: current directory)

Options:
  --quiet, -q       Suppress output except errors
  --verbose, -v     Show detailed output
  --show-excluded   List each excluded file (discover only)
  --dry-run         Show plan without writing files (generate only)
  --budget <n>      Override token budget (generate only)
  --help, -h        Show this help

Examples:
  ar init
  ar discover
  ar generate --dry-run
  ar generate ./my-project --budget 50000
`;

/**
 * Parse command-line arguments.
 *
 * Extracts the command, positional arguments, and flags.
 * Handles global flags (--help, -h) that may appear before the command.
 */
function parseArgs(args: string[]): {
  command: string | undefined;
  positional: string[];
  flags: Set<string>;
  values: Map<string, string>;
} {
  let command: string | undefined;
  const positional: string[] = [];
  const flags = new Set<string>();
  const values = new Map<string, string>();

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg.startsWith('--')) {
      const flagName = arg.slice(2);
      // Check if next arg is a value (not starting with -)
      if (i + 1 < args.length && !args[i + 1].startsWith('-')) {
        values.set(flagName, args[i + 1]);
        i++; // Skip the value
      } else {
        flags.add(flagName);
      }
    } else if (arg.startsWith('-')) {
      // Handle short flags (e.g., -q, -h, -v)
      for (const char of arg.slice(1)) {
        switch (char) {
          case 'q':
            flags.add('quiet');
            break;
          case 'h':
            flags.add('help');
            break;
          case 'v':
            flags.add('verbose');
            break;
          default:
            // Unknown short flag - ignore
            break;
        }
      }
    } else if (!command) {
      // First non-flag argument is the command
      command = arg;
    } else {
      // Subsequent non-flag arguments are positional
      positional.push(arg);
    }
  }

  return { command, positional, flags, values };
}

/**
 * Show usage information and exit.
 */
function showHelp(): void {
  console.log(USAGE);
  process.exit(0);
}

/**
 * Show error for unknown command and exit.
 */
function showUnknownCommand(command: string): void {
  console.error(`Unknown command: ${command}`);
  console.error(`Run 'ar --help' for usage information.`);
  process.exit(1);
}

/**
 * Main CLI entry point.
 */
async function main(): Promise<void> {
  const args = process.argv.slice(2);
  const { command, positional, flags, values } = parseArgs(args);

  // Handle help flag anywhere
  if (flags.has('help') || args.length === 0) {
    showHelp();
  }

  // Route to command handlers
  switch (command) {
    case 'init': {
      const options: InitOptions = {
        interactive: flags.has('interactive'),
      };
      await initCommand(positional[0] || '.', options);
      break;
    }

    case 'discover': {
      const options: DiscoverOptions = {
        quiet: flags.has('quiet'),
        showExcluded: flags.has('show-excluded'),
        verbose: !flags.has('quiet'),
      };
      await discoverCommand(positional[0] || '.', options);
      break;
    }

    case 'generate': {
      const options: GenerateOptions = {
        quiet: flags.has('quiet'),
        verbose: flags.has('verbose'),
        dryRun: flags.has('dry-run'),
        budget: values.has('budget') ? parseInt(values.get('budget')!, 10) : undefined,
      };
      await generateCommand(positional[0] || '.', options);
      break;
    }

    default:
      if (command) {
        showUnknownCommand(command);
      }
      showHelp();
  }
}

// Run main and handle any uncaught errors
main().catch((err: Error) => {
  console.error(`Error: ${err.message}`);
  process.exit(1);
});
```
  </action>
  <verify>npx tsc --noEmit src/cli/index.ts</verify>
  <done>CLI updated with generate command that creates documentation plan. Supports --dry-run, --budget, --verbose flags.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` - Full project compiles without errors
2. `npm run build` - Project builds successfully
3. Test CLI:
```bash
npx tsx src/cli/index.ts generate --dry-run
npx tsx src/cli/index.ts generate --help
```
</verification>

<success_criteria>
- [ ] src/config/schema.ts extended with generation section
- [ ] src/generation/orchestrator.ts exports GenerationOrchestrator, GenerationPlan
- [ ] Orchestrator creates directory-summary tasks for each directory with analyzed files
- [ ] Directory-summary tasks include prompts for LLM to synthesize directory descriptions
- [ ] src/cli/generate.ts exports generateCommand
- [ ] CLI index routes 'generate' command correctly
- [ ] `ar generate --dry-run` shows plan without writing files
- [ ] Token budget is tracked and reported
</success_criteria>

<output>
After completion, create `.planning/phases/02-documentation-generation/02-06-SUMMARY.md`
</output>
