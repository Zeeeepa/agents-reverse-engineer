---
phase: 11-rebuild-command
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - src/rebuild/prompts.ts
  - src/rebuild/orchestrator.ts
  - src/rebuild/index.ts
  - src/cli/rebuild.ts
  - src/cli/index.ts
autonomous: true

must_haves:
  truths:
    - "Running 'are rebuild' reads specs, creates rebuild units, executes AI calls, and writes generated files to output directory"
    - "Dry-run mode shows the rebuild plan without making AI calls or writing files"
    - "After partial completion, re-running the command auto-resumes from checkpoint, skipping already-done modules"
    - "Forcing a fresh start wipes the output directory and rebuilds from scratch"
    - "A custom output directory can be specified instead of the default rebuild/"
    - "Progress is shown during execution (module name, X of Y, ETA)"
    - "Failed modules are logged and checkpointed as failed; remaining modules continue"
    - "Rebuild units with the same ordering number execute concurrently; different ordering groups execute sequentially (group 1 finishes before group 2 starts)"
    - "Context from completed modules (exported type signatures) is passed to subsequent module prompts"
  artifacts:
    - path: "src/rebuild/prompts.ts"
      provides: "System prompt and per-unit user prompt builder for project reconstruction"
      exports: ["REBUILD_SYSTEM_PROMPT", "buildRebuildPrompt"]
    - path: "src/rebuild/orchestrator.ts"
      provides: "executeRebuild function wiring pool, AIService, checkpoint, progress"
      exports: ["executeRebuild"]
    - path: "src/cli/rebuild.ts"
      provides: "CLI rebuild command handler with RebuildOptions"
      exports: ["rebuildCommand", "RebuildOptions"]
    - path: "src/cli/index.ts"
      provides: "rebuild command registration in CLI router"
      contains: "case 'rebuild'"
  key_links:
    - from: "src/rebuild/orchestrator.ts"
      to: "src/rebuild/checkpoint.ts"
      via: "CheckpointManager.load/createFresh for session continuity"
      pattern: "CheckpointManager"
    - from: "src/rebuild/orchestrator.ts"
      to: "src/orchestration/pool.ts"
      via: "runPool for concurrent module rebuild within each order group"
      pattern: "runPool"
    - from: "src/rebuild/orchestrator.ts"
      to: "src/ai/service.ts"
      via: "AIService.call for each rebuild unit"
      pattern: "aiService\\.call"
    - from: "src/rebuild/orchestrator.ts"
      to: "src/rebuild/output-parser.ts"
      via: "parseModuleOutput to extract files from AI response"
      pattern: "parseModuleOutput"
    - from: "src/rebuild/orchestrator.ts"
      to: "src/rebuild/prompts.ts"
      via: "buildRebuildPrompt with builtContext for context accumulation"
      pattern: "buildRebuildPrompt.*builtContext"
    - from: "src/rebuild/orchestrator.ts"
      to: "src/rebuild/orchestrator.ts"
      via: "Sequential for-loop over order groups ensures ordering dependency"
      pattern: "for.*of.*orderGroups|for.*const.*order"
    - from: "src/cli/rebuild.ts"
      to: "src/rebuild/orchestrator.ts"
      via: "executeRebuild call from CLI handler"
      pattern: "executeRebuild"
    - from: "src/cli/index.ts"
      to: "src/cli/rebuild.ts"
      via: "import and switch case routing"
      pattern: "rebuildCommand"
---

<objective>
Build the rebuild execution pipeline: prompt templates, orchestrator, CLI command handler, and CLI registration.

Purpose: This plan wires the foundation from Plan 01 into a working `are rebuild` command that reads specs, calls AI to reconstruct modules, writes output files, tracks progress via checkpoint, and integrates into the existing CLI.
Output: Working `are rebuild` command with --dry-run, --force, --output, --fail-fast, --concurrency, --debug, --trace flags.
</objective>

<execution_context>
@./.claude/agents/gsd-planner.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-rebuild-command/11-CONTEXT.md
@.planning/phases/11-rebuild-command/11-RESEARCH.md
@.planning/phases/11-rebuild-command/11-01-SUMMARY.md

Key source files to follow patterns from:
@src/cli/generate.ts (CLI command handler pattern: config load, backend resolve, AIService create, runner execute, finalize)
@src/cli/specify.ts (extended timeout pattern, single-call AI invocation, progress log)
@src/cli/index.ts (command registration pattern: import, switch case, flag parsing)
@src/orchestration/runner.ts (executeGenerate pattern: pool + progress + tracer + plan tracker)
@src/orchestration/pool.ts (runPool API, PoolOptions)
@src/orchestration/progress.ts (ProgressReporter, ProgressLog)
@src/orchestration/types.ts (CommandRunOptions, RunSummary, FileTaskResult)
@src/specify/prompts.ts (SPEC_SYSTEM_PROMPT pattern for rebuild system prompt)
@src/ai/service.ts (AIService.call, AIService.finalize)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Prompt Templates and Rebuild Orchestrator</name>
  <files>src/rebuild/prompts.ts, src/rebuild/orchestrator.ts, src/rebuild/index.ts</files>
  <action>
**prompts.ts** -- System prompt and per-unit user prompt builder for AI-driven project reconstruction.

`REBUILD_SYSTEM_PROMPT` (exported const string):
- Role: You reconstruct source code from a project specification
- Task: Generate all source files for the described module/phase
- Output format: Use `===FILE: relative/path.ext===` before each file and `===END_FILE===` after each file's content. Every file must use this format. Generate ONLY the file content between delimiters (no markdown fencing, no commentary)
- Quality: Code must compile. Use exact type names, function signatures, and constants from the spec. Follow the architecture and patterns described. Imports must reference real modules from the spec.
- Constraints: Generate production code only (no tests). Do not invent features not in the spec. Do not add comments explaining what the spec says -- write the code the spec describes.
- Context awareness: When "Already Built" context is provided, import from those modules and use their exported types/functions. Do not redefine types that already exist in built modules.

`buildRebuildPrompt(unit: RebuildUnit, fullSpec: string, builtContext: string | undefined): { system: string; user: string }`:
- system: Return REBUILD_SYSTEM_PROMPT
- user: Build a prompt containing:
  1. "Reconstruct the following module from this specification."
  2. "## Full Specification\n\n" + fullSpec (always include full spec for reference)
  3. "## Current Phase\n\n" + "Build the module described in this phase:\n\n" + unit.specContent
  4. If builtContext provided: "## Already Built\n\nThe following modules have been built. Import from them as needed:\n\n" + builtContext
  5. "## Output Format\n\nEmit each file using:\n===FILE: path/to/file.ext===\n[content]\n===END_FILE===\n\nGenerate ALL files needed for this phase. Use relative paths from the project root."

**orchestrator.ts** -- The core rebuild execution function. This is NOT a method on CommandRunner (avoid modifying runner.ts). It's a standalone async function.

```typescript
import * as path from 'node:path';
import { writeFile, mkdir, readFile, rm } from 'node:fs/promises';
import type { AIService } from '../ai/index.js';
import type { AIResponse } from '../ai/types.js';
import { runPool, ProgressReporter, ProgressLog, type ITraceWriter } from '../orchestration/index.js';
import { CheckpointManager, readSpecFiles, partitionSpec, parseModuleOutput, type RebuildPlan, type RebuildUnit, type RebuildResult } from './index.js';
import { buildRebuildPrompt } from './prompts.js';

export interface RebuildExecutionOptions {
  outputDir: string;
  concurrency: number;
  failFast?: boolean;
  force?: boolean;
  debug?: boolean;
  tracer?: ITraceWriter;
  progressLog?: ProgressLog;
}

export async function executeRebuild(
  aiService: AIService,
  projectRoot: string,
  options: RebuildExecutionOptions,
): Promise<{ modulesProcessed: number; modulesFailed: number; modulesSkipped: number }> {
  // ... implementation
}
```

Implementation flow for `executeRebuild`:

1. **Read specs**: `const specFiles = await readSpecFiles(projectRoot);`

2. **Partition into units**: `const units = partitionSpec(specFiles);`
   - Log unit count and names if debug enabled

3. **Handle --force**: If `options.force`, delete the output directory with `rm(outputDir, { recursive: true, force: true })`, then create fresh

4. **Load/create checkpoint**:
   ```typescript
   const { manager: checkpoint, isResume } = await CheckpointManager.load(outputDir, specFiles);
   ```
   - If isResume, log "Resuming from checkpoint: X of Y modules already complete"
   - If not resume (fresh or drift detected), call `CheckpointManager.createFresh(outputDir, specFiles, units.map(u => u.name))`

5. **Initialize checkpoint**: `await checkpoint.initialize();`

6. **Filter to pending units**: Skip units where `checkpoint.isDone(unit.name)` is true. Track skipped count.

7. **Create progress reporter**: `new ProgressReporter(pendingUnits.length, 0, options.progressLog)`
   - Use file count = pendingUnits.length, dir count = 0

8. **Concatenate full spec**: Join all spec file contents for the full spec context parameter

9. **Build context accumulator**: `let builtContext = '';` -- after each successful order group, append a summary of its exported types/interfaces (extracted from generated files via simple regex). This is best-effort extraction (not comprehensive AST parsing) -- complex exports like destructured re-exports or default exports without names may be missed. This is acceptable because the full spec is always included in every prompt.

10. **CRITICAL - Group units by order, then process groups sequentially**:
    ```typescript
    // Group units by their order value
    const orderGroups = new Map<number, RebuildUnit[]>();
    for (const unit of pendingUnits) {
      const group = orderGroups.get(unit.order) ?? [];
      group.push(unit);
      orderGroups.set(unit.order, group);
    }

    // Sort order keys ascending
    const sortedOrders = [...orderGroups.keys()].sort((a, b) => a - b);

    // Process each order group SEQUENTIALLY (await each group before starting next)
    for (const orderValue of sortedOrders) {
      const groupUnits = orderGroups.get(orderValue)!;
      // ... build tasks for this group, run via runPool, await completion
      // ... then update builtContext before moving to next group
    }
    ```
    This ensures ordering dependencies are respected: all units in group 1 complete before group 2 starts. Within each group, units run concurrently via runPool.

11. **For each order group**, create pool tasks:
    ```typescript
    const groupTasks = groupUnits.map((unit) => async (): Promise<RebuildResult> => {
      reporter.onFileStart(unit.name);
      const callStart = Date.now();

      const prompt = buildRebuildPrompt(unit, fullSpec, builtContext || undefined);
      const response: AIResponse = await aiService.call({
        prompt: prompt.user,
        systemPrompt: prompt.system,
        taskLabel: `rebuild:${unit.name}`,
      });

      // Parse files from response
      const files = parseModuleOutput(response.text);
      if (files.size === 0) {
        throw new Error(`AI produced no files for unit "${unit.name}". Response may have used unexpected format.`);
      }

      // Write files to output directory
      const filesWritten: string[] = [];
      for (const [filePath, content] of files) {
        const absolutePath = path.join(options.outputDir, filePath);
        await mkdir(path.dirname(absolutePath), { recursive: true });
        await writeFile(absolutePath, content, 'utf-8');
        filesWritten.push(filePath);
      }

      // Update checkpoint
      checkpoint.markDone(unit.name, filesWritten);

      const durationMs = Date.now() - callStart;
      return {
        unitName: unit.name,
        success: true,
        filesWritten,
        tokensIn: response.inputTokens,
        tokensOut: response.outputTokens,
        cacheReadTokens: response.cacheReadTokens,
        cacheCreationTokens: response.cacheCreationTokens,
        durationMs,
        model: response.model,
      };
    });
    ```

12. **Run pool with onComplete callback**:
    ```typescript
    await runPool(groupTasks, {
      concurrency: options.concurrency,
      failFast: options.failFast,
      tracer: options.tracer,
      phaseLabel: `rebuild-order-${orderValue}`,
      taskLabels: groupUnits.map(u => u.name),
    }, (result) => {
      if (result.success && result.value) {
        const v = result.value;
        modulesProcessed++;
        reporter.onFileDone(v.unitName, v.durationMs, v.tokensIn, v.tokensOut, v.model, v.cacheReadTokens, v.cacheCreationTokens);
      } else {
        modulesFailed++;
        const errorMsg = result.error?.message ?? 'Unknown error';
        const unitName = groupUnits[result.index]?.name ?? `unit-${result.index}`;
        checkpoint.markFailed(unitName, errorMsg);
        reporter.onFileError(unitName, errorMsg);
      }
    });
    ```

13. **After each group completes**, update builtContext by reading the exported type signatures from the files that were just written. Use a simple regex scan. Wrap file reading in try-catch to handle I/O errors gracefully (log warning, continue without that file's exports):
    ```typescript
    // Best-effort export extraction (not comprehensive AST parsing)
    // Complex patterns (destructured, namespace, default without name) may be missed
    for (const filePath of filesWrittenInGroup) {
      try {
        const content = await readFile(path.join(options.outputDir, filePath), 'utf-8');
        const exportLines = content
          .split('\n')
          .filter(line => /^export\s+(type|interface|class|function|const|enum|default)\s+/.test(line));
        if (exportLines.length > 0) {
          builtContext += `\n// From: ${filePath}\n${exportLines.join('\n')}\n`;
        }
      } catch {
        // Non-critical: file may have been written by a failed task that was cleaned up
        console.error(`[warn] Could not read exports from ${filePath}`);
      }
    }
    ```

14. **Flush checkpoint**: `await checkpoint.flush();`

15. **Return summary**: `{ modulesProcessed, modulesFailed, modulesSkipped }`

Emit tracer events following the pattern in runner.ts:
- `phase:start` / `phase:end` for each order group
- The pool handles `task:start` / `task:done` internally

**Update src/rebuild/index.ts** barrel to add new exports:
```typescript
export { REBUILD_SYSTEM_PROMPT, buildRebuildPrompt } from './prompts.js';
export { executeRebuild, type RebuildExecutionOptions } from './orchestrator.js';
```
  </action>
  <verify>
Run `npx tsc --noEmit` to verify all files compile cleanly. Check critical wiring:
```bash
# Import verification
grep 'runPool' src/rebuild/orchestrator.ts       # Must import from orchestration
grep 'AIService' src/rebuild/orchestrator.ts      # Must import from ai
grep 'CheckpointManager' src/rebuild/orchestrator.ts  # Must import from ./checkpoint or ./index
grep 'parseModuleOutput' src/rebuild/orchestrator.ts   # Must import from ./output-parser or ./index

# Sequential group execution verification
grep 'orderGroups' src/rebuild/orchestrator.ts         # Must have grouping logic
grep 'for.*of.*sortedOrders\|for.*const.*order' src/rebuild/orchestrator.ts  # Must have sequential for-loop
grep 'await.*runPool' src/rebuild/orchestrator.ts      # runPool must be awaited inside the loop

# Context accumulation wiring verification
grep 'buildRebuildPrompt.*builtContext\|builtContext.*buildRebuildPrompt' src/rebuild/orchestrator.ts  # Must pass builtContext to prompt builder
grep 'try.*catch' src/rebuild/orchestrator.ts          # Must have try-catch around file reading for exports
```
  </verify>
  <done>
prompts.ts exports REBUILD_SYSTEM_PROMPT and buildRebuildPrompt (accepting builtContext parameter). orchestrator.ts exports executeRebuild that: (1) groups units by order value into a Map, (2) processes groups sequentially via a for-loop with await, (3) runs units concurrently within each group via runPool, (4) accumulates builtContext from exported signatures after each group with try-catch error handling, (5) passes builtContext to buildRebuildPrompt for subsequent groups. Barrel index.ts updated with new exports. `npx tsc --noEmit` passes cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: CLI Command Handler and Registration</name>
  <files>src/cli/rebuild.ts, src/cli/index.ts</files>
  <action>
**src/cli/rebuild.ts** -- Follow the exact pattern from `src/cli/generate.ts` and `src/cli/specify.ts`.

```typescript
export interface RebuildOptions {
  output?: string;        // Custom output directory (default: rebuild/)
  force?: boolean;        // Wipe output dir and start fresh
  dryRun?: boolean;       // Show plan without executing
  concurrency?: number;   // Override worker pool size
  failFast?: boolean;     // Stop on first failure
  debug?: boolean;        // Verbose subprocess logging
  trace?: boolean;        // Enable NDJSON tracing
}

export async function rebuildCommand(
  targetPath: string,
  options: RebuildOptions,
): Promise<void> {
  // ... implementation
}
```

Implementation flow:

1. `const absolutePath = path.resolve(targetPath);`
2. `const outputDir = options.output ? path.resolve(options.output) : path.join(absolutePath, 'rebuild');`
3. Create tracer: `const tracer = createTraceWriter(absolutePath, options.trace ?? false);`
4. Load config: `const config = await loadConfig(absolutePath, { tracer, debug: options.debug });`
5. Read spec files (early, before backend resolution): `const specFiles = await readSpecFiles(absolutePath);`
6. Partition specs: `const units = partitionSpec(specFiles);`

7. **Dry-run mode** (before backend resolution -- matches generate.ts pattern):
   ```typescript
   if (options.dryRun) {
     console.log(pc.bold('\n--- Dry Run Summary ---\n'));
     console.log(`  Spec files:        ${pc.cyan(String(specFiles.length))}`);
     console.log(`  Rebuild units:     ${pc.cyan(String(units.length))}`);
     console.log(`  Output directory:  ${pc.cyan(outputDir)}`);
     console.log('');
     console.log(pc.dim('Rebuild units:'));
     for (const unit of units) {
       console.log(pc.dim(`  ${unit.order}. ${unit.name}`));
     }
     // If checkpoint exists, show resume info
     const { manager: checkpoint, isResume } = await CheckpointManager.load(outputDir, specFiles);
     if (isResume) {
       const pending = checkpoint.getPendingUnits();
       console.log('');
       console.log(pc.yellow(`Checkpoint found: ${units.length - pending.length} of ${units.length} modules already complete.`));
       console.log(pc.yellow(`Would resume with ${pending.length} remaining modules.`));
     }
     console.log('');
     console.log(pc.dim('No AI calls made (dry run).'));
     return;
   }
   ```

8. **Handle --force**: Log warning if output dir will be wiped

9. **Resolve backend** (same pattern as generate.ts):
   ```typescript
   const registry = createBackendRegistry();
   let backend;
   try {
     backend = await resolveBackend(registry, config.ai.backend);
   } catch (error) {
     if (error instanceof AIServiceError && error.code === 'CLI_NOT_FOUND') {
       console.error(pc.red('Error: No AI CLI found.\n'));
       console.error(getInstallInstructions(registry));
       process.exit(2);
     }
     throw error;
   }
   ```

10. **Create AI service with extended timeout** (follow specify.ts pattern but 15min minimum):
    ```typescript
    const aiService = new AIService(backend, {
      timeoutMs: Math.max(config.ai.timeoutMs, 900_000), // 15min minimum
      maxRetries: config.ai.maxRetries,
      model: config.ai.model,
      telemetry: { keepRuns: config.ai.telemetry.keepRuns },
    });
    if (options.debug) aiService.setDebug(true);
    ```

11. **Enable subprocess logging if trace**:
    ```typescript
    if (options.trace) {
      const logDir = path.join(absolutePath, '.agents-reverse-engineer', 'subprocess-logs',
        new Date().toISOString().replace(/[:.]/g, '-'));
      aiService.setSubprocessLogDir(logDir);
      console.error(pc.dim(`[trace] Subprocess logs -> ${logDir}`));
    }
    ```

12. **Create progress log**:
    ```typescript
    const progressLog = ProgressLog.create(absolutePath);
    progressLog.write(`=== ARE Rebuild (${new Date().toISOString()}) ===`);
    progressLog.write(`Project: ${absolutePath}`);
    progressLog.write(`Output: ${outputDir}`);
    progressLog.write(`Rebuild units: ${units.length}`);
    progressLog.write('');
    ```

13. **Determine concurrency**: `const concurrency = options.concurrency ?? config.ai.concurrency;`

14. **Execute rebuild**:
    ```typescript
    console.log(pc.bold(`Rebuilding project from ${specFiles.length} spec file(s)...`));
    console.log(pc.dim(`Output directory: ${outputDir}`));
    console.log(pc.dim(`Rebuild units: ${units.length}`));
    console.log('');

    const result = await executeRebuild(aiService, absolutePath, {
      outputDir,
      concurrency,
      failFast: options.failFast,
      force: options.force,
      debug: options.debug,
      tracer,
      progressLog,
    });
    ```

15. **Finalize** (telemetry, trace, progress log):
    ```typescript
    await aiService.finalize(absolutePath);
    await progressLog.finalize();
    await tracer.finalize();
    if (options.trace) {
      await cleanupOldTraces(absolutePath);
    }
    ```

16. **Print summary and set exit code** (follow generate.ts pattern):
    ```typescript
    console.log('');
    console.log(pc.bold('Rebuild complete:'));
    console.log(`  Modules processed: ${pc.green(String(result.modulesProcessed))}`);
    if (result.modulesSkipped > 0) {
      console.log(`  Modules skipped:   ${pc.yellow(String(result.modulesSkipped))} (already complete)`);
    }
    if (result.modulesFailed > 0) {
      console.log(`  Modules failed:    ${pc.red(String(result.modulesFailed))}`);
    }
    console.log(`  Output directory:  ${pc.cyan(outputDir)}`);

    if (result.modulesProcessed === 0 && result.modulesFailed > 0) {
      process.exit(2);
    } else if (result.modulesFailed > 0) {
      process.exit(1);
    }
    ```

**src/cli/index.ts** -- Add rebuild command:

1. Add import at top: `import { rebuildCommand, type RebuildOptions } from './rebuild.js';`

2. Update USAGE string:
   - Add `rebuild [path]   Reconstruct project from specification` in Commands section
   - Add `--output <dir>   Output directory for rebuild (default: rebuild/)` in General Options (update existing --output line to mention both specify and rebuild)
   - Add example: `are rebuild --dry-run`

3. Add switch case (between 'specify' and 'default'):
   ```typescript
   case 'rebuild': {
     const rebuildOpts: RebuildOptions = {
       output: values.get('output'),
       force: flags.has('force'),
       dryRun: flags.has('dry-run'),
       concurrency: values.has('concurrency')
         ? parseInt(values.get('concurrency')!, 10) : undefined,
       failFast: flags.has('fail-fast'),
       debug: flags.has('debug'),
       trace: flags.has('trace'),
     };
     await rebuildCommand(positional[0] || '.', rebuildOpts);
     break;
   }
   ```
  </action>
  <verify>
1. `npx tsc --noEmit` passes cleanly
2. `node dist/cli/index.js rebuild --help` shows rebuild in the command list (requires build first: `npm run build`)
3. `node dist/cli/index.js rebuild --dry-run` either shows dry-run output or fails with "No spec files found" (both are correct behavior depending on whether specs/ exists)
4. Verify the CLI registration:
   ```bash
   grep "case 'rebuild'" src/cli/index.ts          # Must exist
   grep "rebuildCommand" src/cli/index.ts           # Must be imported
   grep "rebuild" src/cli/index.ts | head -5        # Should show import, USAGE, and case
   ```
  </verify>
  <done>
`are rebuild` command is fully wired: CLI handler creates AIService with 15min timeout, calls executeRebuild, finalizes telemetry/trace/progress. Supports --output, --force, --dry-run, --concurrency, --fail-fast, --debug, --trace flags. Command registered in CLI router. `npx tsc --noEmit` passes. `are rebuild --dry-run` shows rebuild plan when specs/ exists.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` completes successfully
3. `node dist/cli/index.js --help` lists rebuild command
4. `node dist/cli/index.js rebuild --dry-run` shows dry-run output (when specs/ exists) or descriptive error (when specs/ doesn't exist)
5. All rebuild module files exist: types.ts, spec-reader.ts, output-parser.ts, checkpoint.ts, prompts.ts, orchestrator.ts, index.ts
6. Orchestrator groups units by order value and processes groups sequentially via for-loop with await
7. Orchestrator runs units concurrently within each group via runPool
8. Orchestrator passes builtContext to buildRebuildPrompt for context accumulation
9. Orchestrator wraps export file reading in try-catch for error resilience
10. Orchestrator uses CheckpointManager for session continuity
11. CLI handler follows generate.ts pattern (config load -> backend resolve -> AIService create -> execute -> finalize)
</verification>

<success_criteria>
- `are rebuild --dry-run` shows spec files, rebuild units with ordering, output directory, and checkpoint resume status
- `are rebuild` executes AI calls for each rebuild unit, writes files to output directory, updates checkpoint
- `are rebuild` after partial completion resumes from where it left off (checkpoint-based)
- Forcing fresh start wipes output directory and rebuilds from scratch
- Custom output directory writes to the specified directory
- Stopping on first failure halts execution immediately
- Progress is visible during execution (module name, X of Y, ETA) in terminal and progress.log
- Order groups execute sequentially (group 1 completes before group 2); units within a group execute concurrently
- Telemetry logged to `.agents-reverse-engineer/logs/`
- Exit code 0 on full success, 1 on partial failure, 2 on total failure
</success_criteria>

<output>
After completion, create `.planning/phases/11-rebuild-command/11-02-SUMMARY.md`
</output>
