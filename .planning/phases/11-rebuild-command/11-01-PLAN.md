---
phase: 11-rebuild-command
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/rebuild/types.ts
  - src/rebuild/spec-reader.ts
  - src/rebuild/output-parser.ts
  - src/rebuild/checkpoint.ts
  - src/rebuild/index.ts
autonomous: true

must_haves:
  truths:
    - "Spec files in specs/ can be read and partitioned into rebuild units"
    - "AI multi-file output with ===FILE:=== delimiters can be parsed into a Map of file paths to contents"
    - "Checkpoint state can be saved, loaded, and validated with spec drift detection"
    - "Previously completed modules are skipped on resume"
    - "Malformed specs that have neither Build Plan section nor top-level headings produce a descriptive error, not silent failures"
  artifacts:
    - path: "src/rebuild/types.ts"
      provides: "RebuildCheckpoint, RebuildTask, RebuildPlan, RebuildUnit, RebuildResult types"
      exports: ["RebuildCheckpoint", "RebuildTask", "RebuildPlan", "RebuildUnit", "RebuildResult"]
    - path: "src/rebuild/spec-reader.ts"
      provides: "Read spec files from specs/ and partition into rebuild units"
      exports: ["readSpecFiles", "partitionSpec"]
    - path: "src/rebuild/output-parser.ts"
      provides: "Parse multi-file AI output into Map<filePath, content>"
      exports: ["parseModuleOutput"]
    - path: "src/rebuild/checkpoint.ts"
      provides: "CheckpointManager class with promise-chain serialized writes"
      exports: ["CheckpointManager"]
    - path: "src/rebuild/index.ts"
      provides: "Barrel re-export of all rebuild module exports"
  key_links:
    - from: "src/rebuild/checkpoint.ts"
      to: "src/change-detection/index.ts"
      via: "import computeContentHashFromString"
      pattern: "computeContentHashFromString"
    - from: "src/rebuild/checkpoint.ts"
      to: "src/rebuild/types.ts"
      via: "import RebuildCheckpoint type"
      pattern: "import.*RebuildCheckpoint"
    - from: "src/rebuild/spec-reader.ts"
      to: "src/rebuild/types.ts"
      via: "import RebuildUnit type"
      pattern: "import.*RebuildUnit"
---

<objective>
Create the rebuild module's foundation: types, spec reader, AI output parser, and checkpoint manager.

Purpose: These are the data-layer building blocks that the rebuild orchestrator and CLI command will consume. They have no AI service dependency and can be built and verified independently.
Output: Five files in `src/rebuild/` providing types, spec reading/partitioning, output parsing, checkpoint persistence, and a barrel export.
</objective>

<execution_context>
@./.claude/agents/gsd-planner.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-rebuild-command/11-CONTEXT.md
@.planning/phases/11-rebuild-command/11-RESEARCH.md

Key source files to follow patterns from:
@src/orchestration/plan-tracker.ts (promise-chain write serialization pattern for CheckpointManager)
@src/change-detection/index.ts (computeContentHashFromString for spec drift detection)
@src/change-detection/types.ts (FileChange type pattern to follow for RebuildTask)
@src/specify/index.ts (barrel export pattern)
@src/specify/prompts.ts (AgentsDocs type used by spec reader)
@src/generation/collector.ts (collectAgentsDocs pattern for reading files from a directory)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Types, Spec Reader, and Output Parser</name>
  <files>src/rebuild/types.ts, src/rebuild/spec-reader.ts, src/rebuild/output-parser.ts</files>
  <action>
Create `src/rebuild/` directory and three files:

**types.ts** -- All types for the rebuild module. Use Zod for the checkpoint schema (validated on load from disk). Include:

```typescript
// Zod schema for checkpoint (validated when reading from disk)
const RebuildCheckpointSchema = z.object({
  version: z.string(),
  createdAt: z.string(),
  updatedAt: z.string(),
  outputDir: z.string(),
  specHashes: z.record(z.string()),  // { "specs/SPEC.md": "sha256hex" }
  modules: z.record(z.object({
    status: z.enum(['pending', 'done', 'failed']),
    completedAt: z.string().optional(),
    error: z.string().optional(),
    filesWritten: z.array(z.string()).optional(),
  })),
});
type RebuildCheckpoint = z.infer<typeof RebuildCheckpointSchema>;

// A single rebuild unit (one AI call produces all files for this unit)
interface RebuildUnit {
  name: string;           // Unit name (derived from spec section heading)
  specContent: string;    // The spec section content for this unit
  order: number;          // Execution order (from Build Plan phase numbering)
}

// The full rebuild plan (computed from spec files before execution)
interface RebuildPlan {
  specFiles: Array<{ relativePath: string; content: string }>;
  units: RebuildUnit[];
  outputDir: string;
}

// Result of rebuilding a single unit
interface RebuildResult {
  unitName: string;
  success: boolean;
  filesWritten: string[];     // Relative paths within output dir
  tokensIn: number;
  tokensOut: number;
  cacheReadTokens: number;
  cacheCreationTokens: number;
  durationMs: number;
  model: string;
  error?: string;
}
```

Export the Zod schema and all types. Export `RebuildCheckpointSchema` as a named export so checkpoint.ts can use it for validation.

**spec-reader.ts** -- Two functions:

1. `readSpecFiles(projectRoot: string): Promise<Array<{ relativePath: string; content: string }>>` -- Reads all `.md` files from `specs/` directory (or `specs/SPEC.md` for single-file mode). Sort files alphabetically. Follow the `collectAgentsDocs` pattern from `src/generation/collector.ts`. If `specs/` doesn't exist or has no `.md` files, throw a descriptive error (e.g., `new Error('No spec files found in specs/. Run "are specify" first.')`).

2. `partitionSpec(specFiles: Array<{ relativePath: string; content: string }>): RebuildUnit[]` -- Parses spec content to extract rebuild units. Strategy:
   - Concatenate all spec file contents (for multi-file mode, join in file order)
   - Look for the "Build Plan" section (heading matching `## 9. Build Plan` or `## Build Plan`)
   - Within the Build Plan, find phase headings (e.g., `### Phase 1:`, `### Phase 2:`)
   - Each phase becomes a RebuildUnit with `name` from the phase heading, `order` from the phase number
   - The `specContent` for each unit includes: (a) the full Architecture section for context, (b) the full Public API Surface section for type definitions, (c) the specific Build Plan phase content
   - If no Build Plan section found, fall back to splitting on top-level `## ` headings, each becoming a unit with order matching its position
   - **IMPORTANT: Error handling for malformed specs.** After both parsing strategies (Build Plan and fallback), validate that at least one RebuildUnit was produced. If the result is an empty array, throw a descriptive error: `new Error('Could not extract rebuild units from spec files. Expected either a "## Build Plan" section with "### Phase N:" subsections, or top-level "## " headings. Check your spec file format.')`. Also validate that each unit has non-empty `specContent` -- skip units with empty/whitespace-only content and log a warning to stderr (e.g., `console.error(\`[warn] Skipping empty spec section: "${name}"\`)`).
   - Return units sorted by `order`

**output-parser.ts** -- One function:

`parseModuleOutput(responseText: string): Map<string, string>` -- Extracts files from AI response using `===FILE: path===` / `===END_FILE===` delimiters. The regex pattern: `/===FILE:\s*(.+?)===\n([\s\S]*?)===END_FILE===/g`. Trim the file path. Do NOT trim the file content (preserve leading whitespace for indentation). If no files found via delimiters, try fallback: look for markdown fenced code blocks with file path annotation (`` ```language:path/to/file ```) as a second attempt. Return empty Map if neither format matches (caller handles the error case).
  </action>
  <verify>
Run `npx tsc --noEmit` to verify all types compile correctly. Verify exports are accessible:
```bash
# Check that the files exist and have expected exports
grep -c 'export' src/rebuild/types.ts      # Should be >= 5
grep -c 'export' src/rebuild/spec-reader.ts # Should be >= 2
grep -c 'export' src/rebuild/output-parser.ts # Should be >= 1
# Verify error handling for malformed specs
grep 'Could not extract rebuild units' src/rebuild/spec-reader.ts  # Must exist
grep 'Skipping empty spec section' src/rebuild/spec-reader.ts      # Must exist
```
  </verify>
  <done>
types.ts exports RebuildCheckpointSchema, RebuildCheckpoint, RebuildUnit, RebuildPlan, RebuildResult. spec-reader.ts exports readSpecFiles and partitionSpec with descriptive errors for missing specs and malformed spec content (empty units array or empty section content). output-parser.ts exports parseModuleOutput. All compile cleanly with `npx tsc --noEmit`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Checkpoint Manager and Barrel Export</name>
  <files>src/rebuild/checkpoint.ts, src/rebuild/index.ts</files>
  <action>
**checkpoint.ts** -- `CheckpointManager` class following the `PlanTracker` promise-chain pattern from `src/orchestration/plan-tracker.ts`. Key implementation:

```typescript
import { writeFile, readFile, mkdir, rm } from 'node:fs/promises';
import * as path from 'node:path';
import { computeContentHashFromString } from '../change-detection/index.js';
import { RebuildCheckpointSchema, type RebuildCheckpoint } from './types.js';
import { getVersion } from '../version.js';

export class CheckpointManager {
  private data: RebuildCheckpoint;
  private readonly checkpointPath: string;
  private writeQueue: Promise<void> = Promise.resolve();

  constructor(outputDir: string, initialData: RebuildCheckpoint) {
    this.checkpointPath = path.join(outputDir, '.rebuild-checkpoint');
    this.data = initialData;
  }

  // Static factory: load existing checkpoint or create new one
  static async load(outputDir: string, specFiles: Array<{ relativePath: string; content: string }>): Promise<{ manager: CheckpointManager; isResume: boolean }> {
    // ... implementation
  }

  // Static factory: create fresh checkpoint (called when --force or spec drift detected)
  static createFresh(outputDir: string, specFiles: Array<{ relativePath: string; content: string }>, unitNames: string[]): CheckpointManager {
    // ... implementation
  }
}
```

Static `load()` method:
1. Try to read `.rebuild-checkpoint` from outputDir
2. If file exists, parse JSON and validate with `RebuildCheckpointSchema.safeParse()`
3. If validation fails, return fresh checkpoint (isResume: false)
4. Check for spec drift: compare stored `specHashes` against current spec file hashes using `computeContentHashFromString()`. If any hash differs or files added/removed, return fresh checkpoint (isResume: false)
5. If valid and no drift, return loaded checkpoint (isResume: true)

Static `createFresh()` method:
1. Build specHashes by hashing each spec file's content with `computeContentHashFromString()`
2. Initialize all modules as `{ status: 'pending' }`
3. Set version from `getVersion()`, timestamps to now

Instance methods:
- `markDone(unitName: string, filesWritten: string[])`: Set module status to 'done', record completedAt and filesWritten, queue write
- `markFailed(unitName: string, error: string)`: Set module status to 'failed', record error, queue write
- `getPendingUnits(): string[]`: Return unit names with status 'pending' or 'failed'
- `isDone(unitName: string): boolean`: Check if unit status is 'done'
- `async flush(): Promise<void>`: Await writeQueue
- `async initialize(): Promise<void>`: Create outputDir if needed, write initial checkpoint file
- `getData(): RebuildCheckpoint`: Return current checkpoint data (for dry-run display)

All write methods use promise-chain serialization:
```typescript
this.writeQueue = this.writeQueue
  .then(() => writeFile(this.checkpointPath, JSON.stringify(this.data, null, 2), 'utf-8'))
  .catch(() => { /* non-critical */ });
```

**index.ts** -- Barrel export for the rebuild module:
```typescript
export type { RebuildCheckpoint, RebuildUnit, RebuildPlan, RebuildResult } from './types.js';
export { RebuildCheckpointSchema } from './types.js';
export { readSpecFiles, partitionSpec } from './spec-reader.js';
export { parseModuleOutput } from './output-parser.js';
export { CheckpointManager } from './checkpoint.js';
```

Do NOT export prompts or orchestrator from the barrel yet -- those are created in Plan 02.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify everything compiles. Verify the barrel export is importable:
```bash
# Check barrel exports the expected symbols
grep 'export' src/rebuild/index.ts | wc -l  # Should be >= 5
```
  </verify>
  <done>
CheckpointManager class implements load/createFresh static factories, markDone/markFailed/getPendingUnits/isDone/flush/initialize/getData instance methods with promise-chain write serialization. Barrel index.ts re-exports all public types, schema, functions, and classes. `npx tsc --noEmit` passes cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. All five files exist in `src/rebuild/`
3. Barrel export (`src/rebuild/index.ts`) re-exports all public symbols
4. CheckpointManager uses promise-chain write serialization (grep for `writeQueue`)
5. Spec reader throws descriptive error when no spec files found
6. Spec reader throws descriptive error when spec content produces zero rebuild units (malformed format)
7. Spec reader logs warning for empty spec sections and skips them
8. Output parser handles both `===FILE:===` delimiter format and markdown fenced block fallback
</verification>

<success_criteria>
- `src/rebuild/` directory exists with types.ts, spec-reader.ts, output-parser.ts, checkpoint.ts, index.ts
- All files compile cleanly (`npx tsc --noEmit` exit code 0)
- Types match the RebuildCheckpoint schema defined in 11-RESEARCH.md
- CheckpointManager follows PlanTracker promise-chain pattern
- Spec reader can read from specs/ directory and partition into RebuildUnit array
- Spec reader produces descriptive errors for both missing specs/ and malformed spec content
- Output parser extracts files from `===FILE:===` / `===END_FILE===` delimited AI output
</success_criteria>

<output>
After completion, create `.planning/phases/11-rebuild-command/11-01-SUMMARY.md`
</output>
