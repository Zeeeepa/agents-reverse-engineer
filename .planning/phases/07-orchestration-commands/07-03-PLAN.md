---
phase: 07-orchestration-commands
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - src/cli/update.ts
  - src/cli/discover.ts
autonomous: true

must_haves:
  truths:
    - "Running `are update` on a project with changed files calls AIService for each changed file and writes real AI-generated .sum content"
    - "Running `are update --dry-run` shows changed files without making AI calls"
    - "Running `are update` concurrently processes changed files with streaming progress output"
    - "Running `are update` prints a run summary with total calls, tokens in/out, time, and error count"
    - "On partial file failure during update, the command exits with code 1 and skips failed files"
    - "Running `are discover` continues to work with no behavior changes"
  artifacts:
    - path: "src/cli/update.ts"
      provides: "Update command rewritten to use AIService + CommandRunner"
      exports: ["updateCommand", "UpdateCommandOptions"]
    - path: "src/cli/discover.ts"
      provides: "Discover command with minor consistency updates"
      exports: ["discoverCommand", "DiscoverOptions"]
  key_links:
    - from: "src/cli/update.ts"
      to: "src/ai/index.ts"
      via: "AIService instantiation and backend resolution"
      pattern: "resolveBackend|new AIService"
    - from: "src/cli/update.ts"
      to: "src/orchestration/index.ts"
      via: "CommandRunner for concurrent file analysis"
      pattern: "CommandRunner"
    - from: "src/cli/update.ts"
      to: "src/update/orchestrator.ts"
      via: "UpdateOrchestrator for change detection and plan preparation"
      pattern: "createUpdateOrchestrator"
---

<objective>
Rewrite the update command to use AI service for real analysis, and apply minor consistency updates to the discover command.

Purpose: The update command currently writes placeholder .sum content ("Analysis Pending. Full analysis requires LLM integration."). This plan replaces that with real AI-generated summaries using the same orchestration engine as generate. The discover command gets minor flag consistency.
Output: Rewritten `src/cli/update.ts` with AI-backed analysis and concurrent processing. Updated `src/cli/discover.ts` with minor changes.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-orchestration-commands/07-CONTEXT.md
@.planning/phases/07-orchestration-commands/07-RESEARCH.md
@.planning/phases/07-orchestration-commands/07-01-SUMMARY.md
@.planning/phases/07-orchestration-commands/07-02-SUMMARY.md

@src/cli/update.ts
@src/cli/discover.ts
@src/cli/index.ts
@src/ai/index.ts
@src/orchestration/index.ts
@src/update/orchestrator.ts
@src/generation/writers/sum.ts
@src/generation/writers/agents-md.ts
@src/generation/detection/detector.ts
@src/generation/prompts/index.ts
@src/change-detection/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite update command to use AIService for real analysis</name>
  <files>src/cli/update.ts</files>
  <action>
Rewrite the `updateCommand` in `src/cli/update.ts` to use the AI service for actual file analysis instead of generating placeholder summaries.

**Update UpdateCommandOptions interface:**
- Keep existing: `uncommitted`, `quiet`, `verbose`, `dryRun`, `budget`
- Add: `concurrency?: number`, `failFast?: boolean`, `debug?: boolean`

**Rewrite the analyzeFile function** (or replace it):

Replace the current `analyzeFile` function that generates placeholder content. The new implementation:
1. Read the source file content with `readFile(filePath, 'utf-8')`
2. Detect file type with `detectFileType(filePath, content)`
3. Build the prompt with `buildPrompt({ filePath: change.path, content, fileType })`
4. Call `aiService.call({ prompt: userPrompt, systemPrompt })` where the prompts come from `buildPrompt`
5. Compute content hash via `computeContentHash(filePath)`
6. Construct `SumFileContent` with `response.text` as summary, metadata extracted from the response (purpose from first line or empty, empty arrays for publicInterface/dependencies/patterns), fileType, timestamp, and content hash
7. Write the .sum file via `writeSumFile(filePath, sumContent)`
8. Return a `FileTaskResult` with token counts, timing, and model from the AI response

**Rewrite the main updateCommand flow:**

1. **Setup phase** (keep): resolve path, load config, create logger, create orchestrator, prepare plan, display plan, handle first-run/no-changes/dry-run cases

2. **Backend resolution** (new): Same pattern as generate command -- call `resolveBackend(createBackendRegistry(), config.ai.backend)`. On `CLI_NOT_FOUND`, print install instructions and exit with code 2.

3. **AI service setup** (new): Create `AIService` with resolved backend and config options

4. **File analysis phase** (rewrite):
   - Create `ProgressReporter` from `../orchestration/index.js` with `plan.filesToAnalyze.length` as total and `quiet` option
   - Determine concurrency: `options.concurrency ?? config.ai.concurrency`
   - Map each `FileChange` in `plan.filesToAnalyze` to an async task function that:
     - Calls `reporter.onFileStart(change.path)`
     - Runs the new analyzeFile logic (read file, detect type, build prompt, AI call, write .sum)
     - On success: calls `reporter.onFileDone()` with timing and tokens
     - On error: throws (pool catches and calls `reporter.onFileError()`)
   - Execute via `runPool(tasks, { concurrency, failFast: options.failFast }, onComplete callback)`
   - Collect results to count successes and failures

5. **AGENTS.md regeneration** (keep existing logic): Loop through `plan.affectedDirs` and call `writeAgentsMd()`. Use the reporter for directory-done output.

6. **Telemetry finalization** (new): Call `aiService.finalize(absolutePath)` to write the run log

7. **Summary and exit** (rewrite):
   - Build `RunSummary` from pool results + AI service summary
   - Call `reporter.printSummary(summary)` for the end-of-run output
   - Exit code: 0 for all success, 1 for partial failure, 2 for total failure

**Remove:**
- The old `formatCleanup` function can stay (still used for plan display)
- The old `analyzeFile` function is replaced entirely
- The old manual "=== Analyzing Changed Files ===" and "=== Update Complete ===" console output is replaced by the ProgressReporter

**Keep:**
- The `formatPlan` function for displaying the update plan before execution
- The orchestrator's `preparePlan` and change detection logic (Phase 7 consumes this, doesn't replace it)
- The cleanup step (deleting orphaned .sum files)
- The `recordFileAnalyzed`, `recordRun` calls (they are no-ops in frontmatter mode but maintain API compatibility)
  </action>
  <verify>
Run `npx tsc --noEmit`. Verify:
1. `UpdateCommandOptions` has concurrency, failFast, debug fields
2. The function imports from `../ai/index.js` and `../orchestration/index.js`
3. The analyzeFile replacement calls `aiService.call()` not placeholder text
4. Concurrent execution via `runPool` with configurable concurrency
5. Exit codes follow the 0/1/2 scheme
  </verify>
  <done>
`src/cli/update.ts` uses AIService for real file analysis. Changed files are processed concurrently via runPool with streaming progress. Run summary printed at end. Exit codes: 0/1/2. No placeholder summaries remain.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update discover command and verify full compilation</name>
  <files>src/cli/discover.ts</files>
  <action>
**Minor discover command updates:**

The discover command (CMD-03) needs only consistency improvements since it doesn't make AI calls. Apply these changes to `src/cli/discover.ts`:

1. **Remove `process.exit(0)` at the end of discoverCommand.** The function should return normally; `process.exit(0)` prevents proper cleanup and is inconsistent with generate/update which only exit on failure. Keep the `process.exit(1)` error paths.

2. **No AI-related changes.** Discover feeds plans to generate; it doesn't make AI calls itself. This is per RESEARCH.md recommendation: "Minimal changes to discover: add flag parsing for consistency, but the core behavior stays the same."

**Full compilation verification:**

After making the discover change, verify the entire project compiles:
1. Run `npx tsc --noEmit` -- must pass with zero errors
2. Check that all import paths resolve correctly across the new orchestration module, modified CLI commands, and existing modules
3. Verify no circular dependencies were introduced
  </action>
  <verify>
Run `npx tsc --noEmit` from the project root. Must pass with zero errors. Also run `npm run build` if a build script exists to verify the full build pipeline.
  </verify>
  <done>
`src/cli/discover.ts` updated to remove `process.exit(0)`. Full project compiles cleanly with `npx tsc --noEmit`. All import paths resolve. No circular dependencies. All three commands (generate, update, discover) are consistent.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors for the entire project
2. Update command imports AIService and uses it for file analysis (no placeholder text)
3. Update command uses runPool for concurrent processing
4. Update command prints streaming progress and end-of-run summary
5. Discover command compiles and works (no behavioral changes beyond exit cleanup)
6. Exit codes: generate and update both use 0/1/2 scheme
</verification>

<success_criteria>
- `are update` replaces placeholder summaries with real AI-generated analysis
- Changed files are processed concurrently with streaming progress
- Run summary shows total calls, tokens in/out, total time, error count
- On partial failure, exit code is 1; on total failure, exit code is 2
- Discover command continues to work unchanged
- Full project compiles with zero type errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-orchestration-commands/07-03-SUMMARY.md`
</output>
