---
phase: 07-orchestration-commands
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/orchestration/types.ts
  - src/orchestration/pool.ts
  - src/orchestration/progress.ts
  - src/orchestration/runner.ts
  - src/orchestration/index.ts
  - src/config/schema.ts
autonomous: true

must_haves:
  truths:
    - "runPool executes tasks concurrently up to the configured parallelism limit"
    - "runPool supports fail-fast mode that stops pulling new tasks on first error"
    - "ProgressReporter outputs streaming build-log lines for start, done, and fail events"
    - "ProgressReporter computes ETA via moving average after 2+ completions"
    - "CommandRunner processes file tasks concurrently, then directory tasks post-order, then root tasks"
    - "Config schema accepts concurrency field (1-20, default 5) in the ai section"
  artifacts:
    - path: "src/orchestration/pool.ts"
      provides: "Iterator-based concurrency pool with fail-fast support"
      exports: ["runPool", "PoolOptions", "TaskResult"]
    - path: "src/orchestration/types.ts"
      provides: "Shared types for orchestration module"
      exports: ["FileTaskResult", "RunSummary", "ProgressEvent", "CommandRunOptions"]
    - path: "src/orchestration/progress.ts"
      provides: "Streaming build-log progress reporter with ETA"
      exports: ["ProgressReporter"]
    - path: "src/orchestration/runner.ts"
      provides: "Three-phase command runner (files->dirs->roots)"
      exports: ["CommandRunner"]
    - path: "src/orchestration/index.ts"
      provides: "Barrel export for orchestration module"
    - path: "src/config/schema.ts"
      provides: "Extended config with concurrency setting"
      contains: "concurrency"
  key_links:
    - from: "src/orchestration/runner.ts"
      to: "src/ai/service.ts"
      via: "AIService.call() for each file task"
      pattern: "aiService\\.call"
    - from: "src/orchestration/runner.ts"
      to: "src/orchestration/pool.ts"
      via: "runPool for concurrent file processing"
      pattern: "runPool"
    - from: "src/orchestration/runner.ts"
      to: "src/orchestration/progress.ts"
      via: "ProgressReporter for streaming output"
      pattern: "ProgressReporter"
    - from: "src/orchestration/runner.ts"
      to: "src/generation/executor.ts"
      via: "ExecutionPlan consumption"
      pattern: "ExecutionPlan"
---

<objective>
Build the orchestration engine that enables concurrent AI-driven file analysis with streaming progress output.

Purpose: This is the foundation module that all command rewrites (generate, update) depend on. It provides the concurrency pool, progress reporting, and the three-phase command runner that ties AIService + ExecutionPlan together.
Output: New `src/orchestration/` module with pool, types, progress, runner, and barrel export. Extended config schema with concurrency setting.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-orchestration-commands/07-CONTEXT.md
@.planning/phases/07-orchestration-commands/07-RESEARCH.md
@.planning/phases/06-ai-service-foundation/06-03-SUMMARY.md

@src/ai/index.ts
@src/ai/service.ts
@src/ai/types.ts
@src/generation/executor.ts
@src/generation/writers/sum.ts
@src/generation/writers/agents-md.ts
@src/config/schema.ts
@src/change-detection/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create concurrency pool, types, and progress reporter</name>
  <files>
    src/orchestration/types.ts
    src/orchestration/pool.ts
    src/orchestration/progress.ts
  </files>
  <action>
Create three new files in `src/orchestration/`:

**types.ts** -- Shared types for the orchestration module:
- `FileTaskResult`: `{ path: string; success: boolean; tokensIn: number; tokensOut: number; durationMs: number; model: string; error?: string }`
- `RunSummary`: `{ filesProcessed: number; filesFailed: number; filesSkipped: number; totalCalls: number; totalInputTokens: number; totalOutputTokens: number; totalDurationMs: number; errorCount: number; retryCount: number }`
- `ProgressEvent`: `{ type: 'start' | 'done' | 'error' | 'dir-done' | 'root-done'; filePath: string; index: number; total: number; durationMs?: number; tokensIn?: number; tokensOut?: number; model?: string; error?: string }`
- `CommandRunOptions`: `{ concurrency: number; failFast?: boolean; quiet?: boolean; debug?: boolean; dryRun?: boolean }`

**pool.ts** -- Iterator-based concurrency pool:
- Export `PoolOptions` interface: `{ concurrency: number; failFast?: boolean }`
- Export `TaskResult<T>` interface: `{ index: number; success: boolean; value?: T; error?: Error }`
- Export `runPool<T>(tasks: Array<() => Promise<T>>, options: PoolOptions, onComplete?: (result: TaskResult<T>) => void): Promise<TaskResult<T>[]>`
- Implementation uses the shared-iterator/worker pattern from RESEARCH.md:
  - Create an iterator from `tasks.entries()`
  - Spawn `Math.min(concurrency, tasks.length)` async workers that each pull from the shared iterator
  - Each worker: for-of the iterator, await the task, record result, call onComplete callback
  - Use a shared `aborted` boolean flag; workers check it before pulling next task; set it on error when failFast is true
  - Use `Promise.allSettled(workers)` to wait for all workers
  - Return results array (sparse -- indexed by task index)

**progress.ts** -- Streaming build-log progress reporter:
- Export `ProgressReporter` class
- Constructor takes `(totalFiles: number, quiet: boolean)`
- Uses `picocolors` for colored output
- Methods:
  - `onFileStart(filePath: string)`: logs `[X/Y] ANALYZING path` in cyan
  - `onFileDone(filePath: string, durationMs: number, tokensIn: number, tokensOut: number, model: string)`: logs `[X/Y] DONE path Xs in/out tok ~Ns remaining` in green. Increments completed count and records completion time for ETA.
  - `onFileError(filePath: string, error: string)`: logs `[X/Y] FAIL path error` in red. Increments failed count.
  - `onDirectoryDone(dirPath: string)`: logs `[dir] DONE dirPath/AGENTS.md` in blue
  - `onRootDone(docPath: string)`: logs `[root] DONE docPath` in blue
  - `printSummary(summary: RunSummary)`: prints multi-line end-of-run summary with files processed, tokens in/out, time, errors, retries (always printed even in quiet mode)
- ETA calculation: maintain a sliding window of last 10 completion times. After 2+ completions, compute average and multiply by remaining files. Format as `~Xs remaining` or `~Xm Ys remaining`.
- All methods except `printSummary` are no-ops when `quiet` is true.
- Each log line is a single `console.log()` call (atomic, no cursor manipulation).
  </action>
  <verify>
Run `npx tsc --noEmit` from the project root. All three files should compile without errors. Verify the exports are correct by checking the TypeScript output.
  </verify>
  <done>
Three files exist: `src/orchestration/types.ts`, `src/orchestration/pool.ts`, `src/orchestration/progress.ts`. All compile. `runPool` has correct generics and abort support. `ProgressReporter` uses picocolors and has ETA calculation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create command runner, barrel export, and extend config schema</name>
  <files>
    src/orchestration/runner.ts
    src/orchestration/index.ts
    src/config/schema.ts
  </files>
  <action>
**runner.ts** -- The CommandRunner that wires ExecutionPlan + AIService + pool + progress:
- Export `CommandRunner` class
- Constructor takes `(aiService: AIService, options: CommandRunOptions)`
- Method `executeGenerate(plan: ExecutionPlan): Promise<RunSummary>`:
  1. Create `ProgressReporter` with `plan.fileTasks.length` as total
  2. **Phase 1 - File analysis (concurrent):** Map each file task to an async function that:
     - Calls `reporter.onFileStart(task.path)`
     - Reads the source file content with `readFile(task.absolutePath, 'utf-8')`
     - Calls `aiService.call({ prompt: task.userPrompt, systemPrompt: task.systemPrompt })`
     - Computes content hash via `computeContentHash(task.absolutePath)` (imported from `../change-detection/index.js`)
     - Constructs `SumFileContent` with `response.text` as summary, empty metadata arrays (purpose extracted from first line of response or empty), fileType from task metadata, current timestamp, and the content hash
     - Writes .sum file via `writeSumFile(task.absolutePath, sumContent)`
     - Returns `FileTaskResult` with token counts and timing from the AI response
     - On error: throws (pool catches it and records failure)
  3. Run tasks through `runPool(tasks, { concurrency: options.concurrency, failFast: options.failFast })` with onComplete callback that calls reporter methods
  4. **Phase 2 - Directory docs (sequential, post-order):** Loop through `plan.directoryTasks` and call `writeAgentsMd(task.absolutePath, plan.projectRoot)` for each. Call `reporter.onDirectoryDone()`.
  5. **Phase 3 - Root documents (sequential):** Loop through `plan.rootTasks` and call `aiService.call()` with the task's prompts. Write result to `task.outputPath` using `writeFile()`. Call `reporter.onRootDone()`.
  6. Get summary from `aiService.getSummary()` and construct `RunSummary`. Call `reporter.printSummary()`.
  7. Return the `RunSummary`.
- Method `executeUpdate(filesToAnalyze: FileChange[], projectRoot: string, config: Config): Promise<RunSummary>`:
  1. Similar to generate but only Phase 1 (file analysis):
     - For each file in `filesToAnalyze`, detect file type, build prompt, call AI service
     - Write .sum files with real AI-generated content
  2. Does NOT do directory or root doc phases (the update command handles AGENTS.md regeneration itself)
  3. Returns `RunSummary`
- Import `AIService` from `../ai/index.js`, `ExecutionPlan` and `ExecutionTask` from `../generation/executor.js`, `writeSumFile` and `SumFileContent` from `../generation/writers/sum.js`, `writeAgentsMd` from `../generation/writers/agents-md.js`, `computeContentHash` from `../change-detection/index.js`, `readFile` and `writeFile` from `node:fs/promises`, `detectFileType` from `../generation/detection/detector.js`, `buildPrompt` from `../generation/prompts/index.js`.

**index.ts** -- Barrel export:
- Re-export all public types and classes from types.ts, pool.ts, progress.ts, runner.ts
- This is the single import point for the orchestration module

**config/schema.ts** -- Extend AISchema:
- Add `concurrency: z.number().min(1).max(20).default(5)` to the existing AISchema object
- This field controls the default parallelism for concurrent AI calls
- The CLI `--concurrency` flag (added in Plan 02) will override this at runtime
  </action>
  <verify>
Run `npx tsc --noEmit` from the project root. All files should compile without errors. Verify that:
1. `src/orchestration/index.ts` exports `CommandRunner`, `ProgressReporter`, `runPool`, and all types
2. `src/config/schema.ts` parses `{ ai: { concurrency: 3 } }` correctly and defaults to 5 when omitted
3. The `CommandRunner` correctly imports from `../ai/index.js`, `../generation/executor.js`, and `../generation/writers/sum.js`
  </verify>
  <done>
`src/orchestration/runner.ts` exists with `CommandRunner` class that wires AIService + pool + progress. `src/orchestration/index.ts` barrel exports all public API. `src/config/schema.ts` has `concurrency` field in AISchema with min 1, max 20, default 5. All files compile cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. The `src/orchestration/` directory contains 5 files: types.ts, pool.ts, progress.ts, runner.ts, index.ts
3. Config schema parses `{}` and populates `ai.concurrency` with default value 5
4. All imports between orchestration module and existing modules resolve correctly
</verification>

<success_criteria>
- New orchestration module with concurrency pool, progress reporter, and command runner compiles and is ready for commands to use
- Config schema extended with concurrency setting (backward compatible -- existing configs still parse)
- Zero new npm dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/07-orchestration-commands/07-01-SUMMARY.md`
</output>
