---
phase: 10-specify-command
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/specify/prompts.ts
  - src/specify/writer.ts
  - tests/specify/writer.test.ts
autonomous: true

must_haves:
  truths:
    - "buildSpecPrompt() produces a system prompt that instructs conceptual grouping (not folder mirroring) and prohibits exact file paths"
    - "buildSpecPrompt() produces a user prompt that injects all AGENTS.md and .sum content with clear section delimiters"
    - "writeSpec() creates the output directory and writes the spec file atomically"
    - "writeSpec() refuses to overwrite existing files unless force=true, printing a warning to stderr"
    - "writeSpec() in multi-file mode splits AI output on top-level '# ' headings into separate files"
  artifacts:
    - path: "src/specify/prompts.ts"
      provides: "System and user prompt templates for spec generation"
      exports: ["buildSpecPrompt", "SpecPrompt"]
    - path: "src/specify/writer.ts"
      provides: "Spec output writing with overwrite protection and multi-file split"
      exports: ["writeSpec", "WriteSpecOptions"]
    - path: "tests/specify/writer.test.ts"
      provides: "Unit tests for writer module"
  key_links:
    - from: "src/specify/prompts.ts"
      to: "src/specify/collector.ts"
      via: "SpecInput type import for prompt building"
      pattern: "SpecInput"
    - from: "src/specify/writer.ts"
      to: "node:fs/promises"
      via: "writeFile, mkdir, access for atomic writes and overwrite checking"
      pattern: "access.*F_OK"
---

<objective>
Create the prompt templates for spec generation and the output writer with overwrite protection and multi-file splitting.

Purpose: The prompts define the quality of the AI-synthesized spec (conceptual grouping, no file paths, build plan inclusion). The writer handles safe output with overwrite protection per the user's requirements.
Output: `src/specify/prompts.ts` for prompt building, `src/specify/writer.ts` for output writing, and unit tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-specify-command/10-CONTEXT.md
@.planning/phases/10-specify-command/10-RESEARCH.md

@src/generation/prompts/templates.ts
@src/generation/prompts/builder.ts
@src/generation/writers/agents-md.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create prompt templates for spec generation</name>
  <files>src/specify/prompts.ts</files>
  <action>
Create `src/specify/prompts.ts` with:

1. **SpecPrompt interface:**
   ```typescript
   interface SpecPrompt {
     system: string;
     user: string;
   }
   ```

2. **SPEC_SYSTEM_PROMPT constant** -- a detailed system prompt for AI spec generation:
   - Audience: AI agents (LLMs) -- structured, precise, instruction-oriented language
   - Organization: MANDATORY conceptual grouping by concern, NOT by directory structure. Sections:
     1. Project Overview -- purpose, core value, problem solved, tech stack
     2. Architecture -- system design, module boundaries, data flow patterns, key design decisions
     3. Public API Surface -- all exported interfaces, function signatures, type definitions, error contracts
     4. Data Structures & State -- key types, schemas, config objects, state management patterns
     5. Configuration -- all config options with types, defaults, validation rules
     6. Dependencies -- each dependency with version and rationale
     7. Behavioral Contracts -- error handling, retry logic, concurrency model, lifecycle hooks
     8. Test Contracts -- what each module's tests should verify (scenarios, edge cases, expected behaviors)
     9. Build Plan -- phased implementation sequence, what to build first and why, dependency order
   - Rules: describe MODULE BOUNDARIES not file paths; use exact function/type/const names; include full type signatures for public APIs; do NOT prescribe exact filenames; do NOT mirror folder structure; include version numbers for all dependencies; build plan must list implementation order with dependencies
   - Output format: Raw markdown, no preamble, no meta-commentary

3. **buildSpecPrompt(input: SpecInput): SpecPrompt** function that:
   - Takes a `SpecInput` from the collector (import the type from `./collector.js`)
   - Builds a user prompt that:
     a. Opens with "Generate a comprehensive project specification from the following documentation."
     b. Injects AGENTS.md sections under `## AGENTS.md Files ({count} directories)` with each file as `### {relativePath}\n\n{content}`
     c. Injects .sum sections under `## File Summaries ({count} files)` with each as `### {relativePath}\n**Purpose:** {purpose}\n\n{summary}`
     d. Injects package.json metadata if available under `## Package Metadata`
     e. Ends with `## Output Requirements` reiterating the section structure and "Output ONLY the markdown content. No preamble."
   - Returns `{ system: SPEC_SYSTEM_PROMPT, user: userPrompt }`

Export `SpecPrompt` type and `buildSpecPrompt` function. Follow the coding style of `src/generation/prompts/templates.ts` for the system prompt constant.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors. Verify the system prompt contains "conceptual grouping", "module boundaries", and "Build Plan". Verify it does NOT contain any reference to "directory structure" as an organization principle.
  </verify>
  <done>
buildSpecPrompt() returns a system prompt enforcing conceptual organization and a user prompt with all AGENTS.md and .sum content properly sectioned. The system prompt explicitly prohibits folder-mirroring and file path prescriptions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create output writer with overwrite protection and multi-file split</name>
  <files>src/specify/writer.ts, tests/specify/writer.test.ts</files>
  <action>
Create `src/specify/writer.ts` with:

1. **WriteSpecOptions interface:**
   ```typescript
   interface WriteSpecOptions {
     outputPath: string;    // Full path to output file (e.g., /project/specs/SPEC.md)
     force: boolean;        // Overwrite existing files
     multiFile: boolean;    // Split into multiple files by top-level heading
   }
   ```

2. **writeSpec(content: string, options: WriteSpecOptions): Promise<string[]>** function that:
   - **Single-file mode** (multiFile=false):
     a. Check if `outputPath` exists using `access(outputPath, constants.F_OK)`
     b. If exists and force=false: print warning to stderr (`Spec already exists: ${outputPath}\nUse --force to overwrite.`) and throw an error (do NOT call process.exit -- let the CLI handler decide)
     c. Create parent directory with `mkdir(dirname(outputPath), { recursive: true })`
     d. Write content to outputPath with `writeFile(outputPath, content, 'utf-8')`
     e. Return `[outputPath]` (array of written files)
   - **Multi-file mode** (multiFile=true):
     a. Split content on top-level `# ` headings (regex: `/^# /m`)
     b. For each section, derive filename from heading text: lowercase, replace spaces with hyphens, remove non-alphanumeric chars except hyphens, append `.md` (e.g., "# Build Plan" -> "build-plan.md")
     c. Any content before the first `# ` heading goes into `00-preamble.md`
     d. Write each file to the directory of `outputPath` (using the directory as the output dir)
     e. Apply same overwrite protection per file (check existence, respect force flag)
     f. Return array of all written file paths

3. **SpecExistsError class** extending Error -- thrown when overwrite protection triggers. Has a `paths` property listing the conflicting file paths.

Export `WriteSpecOptions`, `writeSpec`, and `SpecExistsError`.

Create `tests/specify/writer.test.ts` with test cases:
1. **Single-file write** -- writes content to a new file, creates parent dirs
2. **Single-file overwrite protection** -- existing file + force=false throws SpecExistsError
3. **Single-file force overwrite** -- existing file + force=true overwrites successfully
4. **Multi-file split** -- content with 3 `# ` headings splits into 3 files with correct names
5. **Multi-file with preamble** -- content starting with text before first `# ` creates 00-preamble.md
6. **Multi-file filename sanitization** -- heading with special chars produces valid filename
7. **Returns written file paths** -- both modes return correct arrays

Use temp directories for all tests.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors. Run `npx vitest run tests/specify/writer.test.ts` -- all tests pass.
  </verify>
  <done>
writeSpec() correctly writes single-file and multi-file output with overwrite protection. SpecExistsError is thrown (not process.exit) when files exist without --force. All 7 test cases pass.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npx vitest run tests/specify/writer.test.ts` -- all tests pass
3. The system prompt contains "conceptual grouping", "module boundaries", "Build Plan", and "Test Contracts"
4. The system prompt prohibits file path prescription and folder-structure mirroring
5. writeSpec() throws SpecExistsError (not process.exit) on overwrite conflict
</verification>

<success_criteria>
- buildSpecPrompt() produces well-structured prompts that enforce conceptual organization
- writeSpec() safely writes output with overwrite protection
- Multi-file mode correctly splits on `# ` headings with sanitized filenames
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/10-specify-command/10-02-SUMMARY.md`
</output>
