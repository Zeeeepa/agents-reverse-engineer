---
phase: 06-ai-service-foundation
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/ai/backends/claude.ts
  - src/ai/backends/gemini.ts
  - src/ai/backends/opencode.ts
  - src/ai/registry.ts
autonomous: true

must_haves:
  truths:
    - "The Claude backend can build CLI args for a prompt and parse the JSON response into a normalized AIResponse"
    - "The Gemini and OpenCode backends exist as stubs that throw 'not implemented' when parseResponse is called"
    - "The registry auto-detects which AI CLI is available on PATH in priority order: Claude > Gemini > OpenCode"
    - "When no AI CLI is found, the registry provides actionable install instructions for all supported backends"
    - "All three backends implement the AIBackend interface from types.ts"
  artifacts:
    - path: "src/ai/backends/claude.ts"
      provides: "Full Claude CLI backend adapter with Zod response parsing"
      exports: ["ClaudeBackend"]
    - path: "src/ai/backends/gemini.ts"
      provides: "Gemini CLI backend stub"
      exports: ["GeminiBackend"]
    - path: "src/ai/backends/opencode.ts"
      provides: "OpenCode CLI backend stub"
      exports: ["OpenCodeBackend"]
    - path: "src/ai/registry.ts"
      provides: "Backend registry, factory, and auto-detection"
      exports: ["BackendRegistry", "createBackendRegistry", "detectBackend", "getInstallInstructions"]
  key_links:
    - from: "src/ai/backends/claude.ts"
      to: "src/ai/types.ts"
      via: "implements AIBackend interface"
      pattern: "implements AIBackend"
    - from: "src/ai/registry.ts"
      to: "src/ai/backends/claude.ts"
      via: "registers Claude backend"
      pattern: "ClaudeBackend"
    - from: "src/ai/backends/claude.ts"
      to: "zod"
      via: "Zod schema for Claude CLI JSON output validation"
      pattern: "z\\.object"
---

<objective>
Build the backend adapters (Claude full, Gemini/OpenCode stubs) and the registry that auto-detects available CLIs.

Purpose: The backend abstraction enables the AI service to work with multiple CLI tools through a common interface. The Claude adapter is the primary implementation. The registry provides runtime detection and a factory pattern for selecting the right backend.

Output: Four files implementing the Strategy pattern for AI backend selection.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-ai-service-foundation/06-RESEARCH.md
@.planning/phases/06-ai-service-foundation/06-CONTEXT.md
@.planning/phases/06-ai-service-foundation/06-01-SUMMARY.md
@src/ai/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Claude backend adapter</name>
  <files>src/ai/backends/claude.ts</files>
  <action>
Create `src/ai/backends/claude.ts` with a full Claude CLI adapter implementing the `AIBackend` interface.

Implementation details:

1. **Zod schema for Claude CLI JSON output** (verified against Claude CLI v2.1.31):
   ```
   ClaudeResponseSchema = z.object({
     type: z.literal('result'),
     subtype: z.enum(['success', 'error']),
     is_error: z.boolean(),
     duration_ms: z.number(),
     duration_api_ms: z.number(),
     num_turns: z.number(),
     result: z.string(),
     session_id: z.string(),
     total_cost_usd: z.number(),
     usage: z.object({
       input_tokens: z.number(),
       cache_creation_input_tokens: z.number(),
       cache_read_input_tokens: z.number(),
       output_tokens: z.number(),
     }),
     modelUsage: z.record(z.object({
       inputTokens: z.number(),
       outputTokens: z.number(),
       cacheReadInputTokens: z.number(),
       cacheCreationInputTokens: z.number(),
       costUSD: z.number(),
     })),
   })
   ```

2. **ClaudeBackend class** implementing AIBackend:
   - `name = 'claude'`, `cliCommand = 'claude'`
   - `isAvailable()`: Use `isCommandOnPath('claude')` helper (check PATH dirs with `fs.stat`, handle PATHEXT on Windows per research Pitfall 5)
   - `buildArgs(options)`: Return `['-p', '--output-format', 'json', '--no-session-persistence']` plus optional `--model`, `--system-prompt`, `--max-turns` flags. The prompt itself is NOT in args -- it goes to stdin via the subprocess wrapper.
   - `parseResponse(stdout, durationMs, exitCode)`: Find first `{` in stdout (defensive JSON parsing per Pitfall 4), parse with Zod schema, extract model name from `modelUsage` keys, return normalized `AIResponse`
   - `getInstallInstructions()`: Return multi-line string with npm install command and URL

3. **isCommandOnPath helper** (private to this module or exported for reuse):
   - Split `process.env.PATH` by `path.delimiter`
   - On Windows: iterate `process.env.PATHEXT` extensions
   - On other platforms: check bare command name
   - Use `fs.stat` to verify the candidate is a file

Export `ClaudeBackend` class and the `isCommandOnPath` utility (other backends will use it).
  </action>
  <verify>Run `npx tsc --noEmit`. Verify the Zod schema matches the documented Claude CLI output structure from RESEARCH.md.</verify>
  <done>ClaudeBackend implements AIBackend, builds correct CLI args, parses Claude JSON with Zod validation, detects CLI on PATH cross-platform, and provides install instructions.</done>
</task>

<task type="auto">
  <name>Task 2: Create Gemini and OpenCode backend stubs</name>
  <files>src/ai/backends/gemini.ts, src/ai/backends/opencode.ts</files>
  <action>
Create stub backends for Gemini and OpenCode that implement the AIBackend interface but throw "not implemented" for `parseResponse`.

**src/ai/backends/gemini.ts:**
- `GeminiBackend` class implementing AIBackend
- `name = 'gemini'`, `cliCommand = 'gemini'`
- `isAvailable()`: Use `isCommandOnPath('gemini')` from claude.ts
- `buildArgs()`: Return `['-p', '--output-format', 'json']` (documented flags from research)
- `parseResponse()`: Throw `new AIServiceError('Gemini backend is not yet implemented. Use Claude backend.', 'SUBPROCESS_ERROR')`
- `getInstallInstructions()`: Return string with `npm install -g @anthropic-ai/gemini-cli` and URL

**src/ai/backends/opencode.ts:**
- `OpenCodeBackend` class implementing AIBackend
- `name = 'opencode'`, `cliCommand = 'opencode'`
- `isAvailable()`: Use `isCommandOnPath('opencode')` from claude.ts
- `buildArgs()`: Return `['run', '--format', 'json']` (documented flags from research)
- `parseResponse()`: Throw `new AIServiceError('OpenCode backend is not yet implemented. Use Claude backend.', 'SUBPROCESS_ERROR')`
- `getInstallInstructions()`: Return string with curl install command and URL

Both stubs exist to demonstrate the extension pattern and enable auto-detection. They are NOT functional for actual AI calls.
  </action>
  <verify>Run `npx tsc --noEmit`. Verify both classes implement the full AIBackend interface.</verify>
  <done>Gemini and OpenCode stubs compile, implement AIBackend, detect their CLIs on PATH, but throw clear "not implemented" errors when parseResponse is called.</done>
</task>

<task type="auto">
  <name>Task 3: Build backend registry with auto-detection</name>
  <files>src/ai/registry.ts</files>
  <action>
Create `src/ai/registry.ts` that manages backend registration, selection, and auto-detection.

Implementation details:

1. **BackendRegistry class:**
   - Private `backends: Map<string, AIBackend>` storing registered backends
   - `register(backend: AIBackend): void` -- add a backend to the registry
   - `get(name: string): AIBackend | undefined` -- get a specific backend by name
   - `getAll(): AIBackend[]` -- list all registered backends

2. **createBackendRegistry() function:**
   - Creates a new BackendRegistry
   - Registers ClaudeBackend, GeminiBackend, OpenCodeBackend
   - Returns the populated registry

3. **detectBackend(registry: BackendRegistry) function:**
   - Iterates backends in priority order: claude, gemini, opencode
   - Calls `isAvailable()` on each
   - Returns the first available backend, or null if none found

4. **getInstallInstructions(registry: BackendRegistry) function:**
   - Returns a formatted string with install instructions for ALL registered backends
   - Format matches the error message template from RESEARCH.md:
     ```
     Error: No AI CLI found on your system.

     Install one of the following:

       Claude Code (recommended):
         npm install -g @anthropic-ai/claude-code
         https://code.claude.com
       ...
     ```

5. **resolveBackend(registry: BackendRegistry, requested: string | 'auto') function:**
   - If `requested === 'auto'`: call `detectBackend()`, throw AIServiceError with install instructions if none found
   - If specific backend requested: get from registry, throw if not found, check isAvailable(), throw if not available
   - Returns the resolved AIBackend

Export: `BackendRegistry`, `createBackendRegistry`, `detectBackend`, `getInstallInstructions`, `resolveBackend`.
  </action>
  <verify>Run `npx tsc --noEmit`. Verify the registry correctly imports all three backends and the resolution logic covers all paths (auto, specific, not found).</verify>
  <done>The registry registers all three backends, auto-detects in priority order, resolves explicit backend requests, and provides clear error messages with install instructions when no CLI is found.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. All four files exist under `src/ai/backends/` and `src/ai/`
3. ClaudeBackend correctly parses the documented Claude CLI JSON schema
4. GeminiBackend and OpenCodeBackend throw "not implemented" on parseResponse
5. `resolveBackend` with `'auto'` returns Claude when available, throws with install instructions when nothing available
6. `isCommandOnPath` handles both Unix and Windows PATH formats
</verification>

<success_criteria>
- `src/ai/backends/claude.ts` exports ClaudeBackend with full Zod-validated response parsing
- `src/ai/backends/gemini.ts` exports GeminiBackend stub
- `src/ai/backends/opencode.ts` exports OpenCodeBackend stub
- `src/ai/registry.ts` exports BackendRegistry with auto-detection and resolution
- All files compile with `npx tsc --noEmit`
- No new runtime dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/06-ai-service-foundation/06-02-SUMMARY.md`
</output>
