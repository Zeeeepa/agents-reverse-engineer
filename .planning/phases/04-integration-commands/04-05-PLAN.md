---
phase: 04-integration-commands
plan: 05
type: execute
wave: 1
depends_on: []
files_modified: [src/cli/init.ts]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Running init --integration generates integration files even when config already exists"
    - "Config-exists warning still appears when config exists"
    - "Integration files are generated regardless of config existence"
  artifacts:
    - path: "src/cli/init.ts"
      provides: "Decoupled control flow for config vs integration"
      contains: "options.integration check outside config-exists branch"
  key_links:
    - from: "src/cli/init.ts"
      to: "src/integration/generate.ts"
      via: "dynamic import regardless of config state"
      pattern: "generateIntegrationFiles.*regardless of config"
---

<objective>
Fix --integration flag being ignored when config already exists

Purpose: Users who already have config should still be able to generate integration files with --integration flag. Currently, the early return at line 62 prevents the integration code from ever running.

Output: Restructured init.ts with decoupled control flow - config creation and integration generation are independent operations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-integration-commands/04-02-SUMMARY.md
@src/cli/init.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Restructure init command control flow</name>
  <files>src/cli/init.ts</files>
  <action>
Refactor the initCommand function to decouple config creation from integration file generation:

1. **Change the config-exists check behavior:**
   - Instead of `return` when config exists, just log the warning
   - Only skip config creation if config exists (not the whole function)
   - Store whether config was created or already existed for later messaging

2. **Move integration handling outside config branch:**
   The integration file generation should run AFTER config handling, not INSIDE it.

   Current structure (broken):
   ```
   if (configExists) { warn; return; }    // <-- exits here
   createConfig();
   if (options.integration) { ... }       // <-- never reached if config exists
   ```

   Target structure (fixed):
   ```
   if (configExists) {
     warn;
   } else {
     createConfig();
     logConfigInstructions();
   }

   // Integration runs regardless of config state
   if (options.integration) { ... }
   else { logIntegrationHint(); }
   ```

3. **Adjust messaging:**
   - When config exists AND integration requested: Show warning, then proceed with integration
   - When config created AND integration requested: Show config success, then proceed with integration
   - When only config created: Show config success + integration hint
   - When only config exists (no --integration): Show warning + edit hint

4. **Preserve existing behavior for non-integration case:**
   If no --integration flag is passed, behavior should be identical to before (warn about existing config and exit).

   Wait - actually we should NOT exit early. The hint about "Run with --integration" should still show. So the early return should be removed entirely, and we just skip the config creation step.

5. **Final structure:**
   ```typescript
   let configCreated = false;

   if (await configExists(resolvedRoot)) {
     logger.warn(`Config already exists at ${configPath}`);
     logger.info('Edit the file to customize exclusions and options.');
   } else {
     await writeDefaultConfig(resolvedRoot);
     configCreated = true;
     logger.info(`Created configuration at ${configPath}`);
     // ... config instructions
   }

   // Handle integration (always runs if flag present)
   if (options.integration) {
     // ... integration code (unchanged)
   } else if (configCreated) {
     // Only show integration hint if we just created config
     logger.info('');
     logger.info('Run with --integration <name> to set up AI assistant commands');
     logger.info('  Supported: claude, opencode, gemini, aider');
   }
   ```
  </action>
  <verify>
1. Build succeeds: `npm run build`
2. Test with existing config: Create config first, then run `npx are init --integration claude` - should generate Claude files
3. Test without existing config: Remove config, run `npx are init --integration claude` - should create config AND generate Claude files
4. Test no flag with existing config: `npx are init` - should warn about existing config, no integration hint
5. Test no flag without config: `npx are init` - should create config and show integration hint
  </verify>
  <done>
- Running `are init --integration claude` when config exists generates integration files
- Warning about existing config still appears
- Config creation and integration generation are decoupled
- No regression in existing behavior for the no-flag case
  </done>
</task>

</tasks>

<verification>
After restructuring:
1. `rm -rf .agents-reverse && npx are init` - Creates config, shows integration hint
2. `npx are init` - Warns config exists, no crash
3. `npx are init --integration claude` - Warns config exists, BUT generates Claude files
4. `rm -rf .agents-reverse .claude/commands/are && npx are init --integration claude` - Creates both config and Claude files
</verification>

<success_criteria>
- Config existence does NOT block integration file generation
- --integration flag honored regardless of config state
- Existing no-flag behavior preserved (warn if exists, hint if created)
- Build passes with no type errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-integration-commands/04-05-SUMMARY.md`
</output>
